<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    <title>Docker学习笔记 | JiFu&#39;s Wiki</title>
    
    
        <meta name="keywords" content="Docker,笔记">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Docker 简介 Docker 两个主要部件：  Docker: 开源的容器虚拟化平台 Docker Hub: 用于分享、管理 Docker 容器的 Docker SaaS 平台 – Docker Hub  Docker 使用客户端-服务器 (C/S) 架构模式。Docker 客户端会与 Docker 守护进程进行通信。Docker 守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Do">
<meta name="keywords" content="Docker,笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker学习笔记">
<meta property="og:url" content="http://www.jifu.io/posts/1245529498/index.html">
<meta property="og:site_name" content="JiFu&#39;s Wiki">
<meta property="og:description" content="Docker 简介 Docker 两个主要部件：  Docker: 开源的容器虚拟化平台 Docker Hub: 用于分享、管理 Docker 容器的 Docker SaaS 平台 – Docker Hub  Docker 使用客户端-服务器 (C/S) 架构模式。Docker 客户端会与 Docker 守护进程进行通信。Docker 守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Do">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://www.jifu.io/images/2/20190403181303.png">
<meta property="og:updated_time" content="2020-08-11T05:17:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker学习笔记">
<meta name="twitter:description" content="Docker 简介 Docker 两个主要部件：  Docker: 开源的容器虚拟化平台 Docker Hub: 用于分享、管理 Docker 容器的 Docker SaaS 平台 – Docker Hub  Docker 使用客户端-服务器 (C/S) 架构模式。Docker 客户端会与 Docker 守护进程进行通信。Docker 守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Do">
<meta name="twitter:image" content="https://www.jifu.io/images/2/20190403181303.png">
    

    
        <link rel="alternate" href="/atom.xml" title="JiFu&#39;s Wiki" type="application/atom+xml">
    

    
        <link rel="icon" href="/favicon.ico">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">
    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?efa1eb5f56c438a850a0f60609fd7755";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>

    


<link rel="stylesheet" href="/css/prism-duotone-light.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
</html>
<body>
    <div id="container">
        <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

<header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">JiFu&#39;s Wiki</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id='categories'>
        <h3 class="widget-title">
            <span>分类</span>
            &nbsp;
            <a id='allExpand' href="#">
                <i class="fa fa-angle-double-up fa-2x"></i>
            </a>
        </h3>

        
        
         <ul class="unstyled" id="tree" style="display: block;"> 
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Android Development
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/1797699998/">深入了解 gradle 和 maven 的区别</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Design
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/1907494021/">PS快捷键使用指南</a></li>  <li class="file"><a href="/posts/729727978/">快速改善用户界面的10个技巧</a></li>  <li class="file"><a href="/posts/1525329016/">提高效率！24 个高手常用的 Sketch 技巧合集（附实用快捷键）</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                HR
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/3142539384/">HR常用的招聘邮件模板</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Hardware
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/3904818761/">MacBook十年进化史</a></li>  </ul> 
                        </li>
                        
                        <li class="directory-open" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder-open"></i>
                                &nbsp;
                                OPS
                            </a>
                             <ul class="unstyled" id="tree" style="display: block;"> 
                        <li class="directory-open" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Docker
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file active"><a href="/posts/1245529498/">Docker学习笔记</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Editor
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/4167799419/">Build personal development editor with vscode</a></li>  <li class="file"><a href="/posts/4165683660/">REST Client 简单好用的接口测试辅助工具</a></li>  <li class="file"><a href="/posts/151598530/">VScdoe error:Could not create temporary directory Permission denied</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder-open"></i>
                                &nbsp;
                                Linux
                            </a>
                             <ul class="unstyled" id="tree" style="display: block;"> 
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                CentOS
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/1867760035/">CentOS7编译安装VIM8</a></li>  <li class="file"><a href="/posts/4057676473/">yum提示Error: rpmdb open failed的解决方案</a></li>  <li class="file"><a href="/posts/1153610031/">centos7修改启动内核，删除无用内核</a></li>  <li class="file"><a href="/posts/920993072/">CentOS update Ruby</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                System Service
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/4024224000/">Linux swap分区及作用详解</a></li>  <li class="file"><a href="/posts/709002730/">使用 systemctl 添加自定义服务</a></li>  <li class="file"><a href="/posts/797311580/">服务管理工具 - systemctl</a></li>  <li class="file"><a href="/posts/55221137/">防火墙工具 - firewalld</a></li>  </ul> 
                        </li>
                         <li class="file"><a href="/posts/3897848060/">Mac使用SSH登录Google Cloud Platform</a></li>  <li class="file"><a href="/posts/4070386720/">Linux系统目录结构及详细说明</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                MacOS
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/4001059579/">Compiling PyQt5 for Python2.7 on Mac OS</a></li>  <li class="file"><a href="/posts/662287335/">MACOS BOOT CAMP – THE STARTUP DISK DOES NOT HAVE ENOUGH SPACE TO BE PARTITIONED</a></li>  <li class="file"><a href="/posts/3746871293/">Charles从入门到精通</a></li>  <li class="file"><a href="/posts/2776773816/">Mac OS X设置SMB进行文件共享</a></li>  <li class="file"><a href="/posts/581320548/">Homebrew：让你从 Mac 切换到 Linux 更轻松</a></li>  <li class="file"><a href="/posts/3837318570/">Mac VSCode 禁用GPU加速</a></li>  <li class="file"><a href="/posts/294187676/">Mac版迅雷优化,删除无用插件</a></li>  <li class="file"><a href="/posts/2733308530/">Mac定时任务-利用launchctl定时启动任务</a></li>  <li class="file"><a href="/posts/1208074722/">Mac重置系统管理控制器SMC</a></li>  <li class="file"><a href="/posts/1883980072/">Mac OS系统加速：干掉那些「炫酷」的动画</a></li>  <li class="file"><a href="/posts/2652542772/">macOS 下 FFmpeg 视频转码入门及进阶使用心得</a></li>  <li class="file"><a href="/posts/1070186292/">SafariBookmarksSyncAgent意外退出解决方法</a></li>  <li class="file"><a href="/posts/2768996547/">一览Mac OS 图形界面的发展史</a></li>  <li class="file"><a href="/posts/1623087360/">修复破解Mac应用启动时闪退（原因是由于苹果移除了TNT证书）</a></li>  <li class="file"><a href="/posts/582618556/">Mac的最大连接数限制和端口的相关参数的设置</a></li>  <li class="file"><a href="/posts/1525358532/">在 M1 芯片 Mac 上使用 Homebrew</a></li>  <li class="file"><a href="/posts/4263562837/">一个惊人快速的终端录像工具，也能录制 VSCode 和 Chrome 窗口</a></li>  <li class="file"><a href="/posts/4147446761/">Mac 时间机器 Time Machine 备份速度太慢的解决方法 (加速备份命令)</a></li>  <li class="file"><a href="/posts/3366946474/">Mac高效使用技巧</a></li>  <li class="file"><a href="/posts/646546052/">如何查看 macOS 系统日志，辅助排除应用程序和系统故障</a></li>  <li class="file"><a href="/posts/3807466731/">如何彻底和CrossOver说GoodBye</a></li>  <li class="file"><a href="/posts/3430780623/">解决Mac修改DNS卡死-命令行修改Mac OS系统DNS设置</a></li>  <li class="file"><a href="/posts/558776221/">解决“Mac应用”已损坏，无法打开的问题</a></li>  <li class="file"><a href="/posts/3653564083/">苹果 Mac 重置 SMC、NVRAM、PRAM 方法教程 - 解决 macOS 卡顿或无法启动</a></li>  <li class="file"><a href="/posts/3920589165/">如何重置Mac上的NVRAM</a></li>  <li class="file"><a href="/posts/1207571108/">强制退出Mac程序的六种方法</a></li>  <li class="file"><a href="/posts/647907268/">苹果M1芯片Macbook安装win10</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Others
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/760033837/">平铺式窗口管理器 - Awesome</a></li>  <li class="file"><a href="/posts/2867836530/">Axel:命令行下轻量级多线程下载程序</a></li>  <li class="file"><a href="/posts/1073812833/">linux下测试磁盘的读写IO速度(IO物理测速)</a></li>  <li class="file"><a href="/posts/3895039994/">命令行信息截图工具 - ScreenFetch</a></li>  <li class="file"><a href="/posts/3784546227/">Git忽略提交规则 - .gitignore配置总结</a></li>  <li class="file"><a href="/posts/3101956195/">Git中.gitignore无效的解决办法</a></li>  <li class="file"><a href="/posts/1413974522/">用好这些隐藏「小开关」，让 Chrome 浏览器更好用</a></li>  <li class="file"><a href="/posts/2006196850/">私有化TM备份与共享服务器 - Netatalk</a></li>  <li class="file"><a href="/posts/3413649842/">Linux实用工具</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Vim
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/258379777/">VIM下使用Vundle搭建python开发环境</a></li>  <li class="file"><a href="/posts/3374749959/">Vim快捷键使用总结</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Windows
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/913943227/">解决EXCEL按上下左右键不是单元格移动的问题</a></li>  <li class="file"><a href="/posts/3426016246/">利用windows内置工具测试硬盘速度 - winsat</a></li>  <li class="file"><a href="/posts/3669230936/">为远程桌面启用Windows防火墙例外</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Wordpress
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/1067246247/">WordPress启用memcached动态缓存以及报错解决</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                command
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/3200906184/">find命令快速技巧：如何定位一个文件</a></li>  <li class="file"><a href="/posts/3403344661/">定时任务Crontab命令详解</a></li>  <li class="file"><a href="/posts/2407250830/">history命令设置linux查看历史命令显示执行时间</a></li>  <li class="file"><a href="/posts/3241041753/">通过编写 chroot 来认识 chroot 发挥的作用和它带来的好处</a></li>  </ul> 
                        </li>
                         <li class="file"><a href="/posts/404814820/">DevOps简介</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder-open"></i>
                                &nbsp;
                                Soft engineering
                            </a>
                             <ul class="unstyled" id="tree" style="display: block;"> 
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Algorithm
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/1453950584/">8大排序算法图文讲解</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Architecture
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/2097636152/">工作两三年了，整不明白架构图都画啥？</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Cheat Sheets
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/2993634676/">Cheat Sheets - Git</a></li>  <li class="file"><a href="/posts/3048024619/">Cheat Sheets - Django Reference Sheet</a></li>  <li class="file"><a href="/posts/3433268710/">Cheat Sheets - Shell Script</a></li>  <li class="file"><a href="/posts/3327139081/">Cheat Sheets – C++</a></li>  <li class="file"><a href="/posts/2137528313/">Cheat Sheets – CSS</a></li>  <li class="file"><a href="/posts/2623330927/">Cheat Sheets - PostgreSQL</a></li>  <li class="file"><a href="/posts/59285358/">Cheat Sheets – HTML and XHTML</a></li>  <li class="file"><a href="/posts/3766000533/">Cheat Sheets – HTTP</a></li>  <li class="file"><a href="/posts/2920272111/">Cheat Sheets – Nodejs</a></li>  <li class="file"><a href="/posts/1362596080/">Cheat Sheets – PHP</a></li>  <li class="file"><a href="/posts/305297407/">Cheat Sheets – C</a></li>  <li class="file"><a href="/posts/2663199359/">Cheat Sheets – Java</a></li>  <li class="file"><a href="/posts/1053003126/">Cheat Sheets – Python</a></li>  <li class="file"><a href="/posts/2038387758/">Cheat Sheets – MySQL</a></li>  <li class="file"><a href="/posts/316669616/">Cheat Sheets – Mac OS X</a></li>  <li class="file"><a href="/posts/982990798/">Cheat Sheets – Linux</a></li>  <li class="file"><a href="/posts/1130312566/">Cheat Sheets – SQLite</a></li>  <li class="file"><a href="/posts/4169548679/">Cheat Sheets - .NET</a></li>  <li class="file"><a href="/posts/3905631645/">Cheat sheets - Xcode</a></li>  <li class="file"><a href="/posts/4169548678/">Cheat Sheets - Photoshop</a></li>  <li class="file"><a href="/posts/3586350539/">Cheat sheets - Mac OS</a></li>  <li class="file"><a href="/posts/3167589601/">Cheat Sheets – Perl</a></li>  <li class="file"><a href="/posts/2789789845/">Cheat Sheets – jQuery</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Project
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/467054247/">如何编写开源项目的README文档</a></li>  <li class="file"><a href="/posts/1755831586/">软件发布版本区别介绍</a></li>  </ul> 
                        </li>
                         </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder-open"></i>
                                &nbsp;
                                back-end
                            </a>
                             <ul class="unstyled" id="tree" style="display: block;"> 
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder-open"></i>
                                &nbsp;
                                Middle-ware
                            </a>
                             <ul class="unstyled" id="tree" style="display: block;"> 
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Gogs
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/4076369309/">Gogs数据备份、恢复</a></li>  <li class="file"><a href="/posts/612684965/">私人Git服务器 -- gogs</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Jenkins
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/2282359188/">jenkins密码重置</a></li>  <li class="file"><a href="/posts/388825549/">利用Jenkins持续集成iOS项目</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Logstash
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/2615120416/">日志搜集处理框架Logstash-安装配置</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                MySQL
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/2625460784/">MySQL延迟复制</a></li>  <li class="file"><a href="/posts/554387356/">MySQL 排序的艺术：你真的懂 Order By 吗？</a></li>  <li class="file"><a href="/posts/2654174479/">分库分表 vs NewSQL数据库</a></li>  <li class="file"><a href="/posts/4284065059/">MySQL 调优/优化的 101 个建议</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Nginx
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/1350143519/">高性能 Nginx HTTPS 调优 - 如何为 HTTPS 提速 30%</a></li>  <li class="file"><a href="/posts/1544228005/">高性能Web服务器 - Nginx配置详解</a></li>  <li class="file"><a href="/posts/524919010/">Nginx正向代理与Client设置代理上网</a></li>  <li class="file"><a href="/posts/3996389515/">Nginx配置跨域请求 Access-Control-Allow-Origin *</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                RabbitMQ
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/2846671594/">RabbitMQ 集群高可用原理及实战部署介绍</a></li>  <li class="file"><a href="/posts/3135873234/">RabbitMQ入门</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Redis
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/156114019/">Redis Stream应用案例</a></li>  <li class="file"><a href="/posts/2864310564/">深入分析Redis特点及应用场景</a></li>  <li class="file"><a href="/posts/2992538737/">redis.conf参数配置及解释</a></li>  <li class="file"><a href="/posts/3909951181/">Redis Manual</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Sentry
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/1303728868/">错误日志收集平台 - Sentry(Redis+MySQL)</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Shadowsocks
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/3154796955/">Vultr快速搭建SS科学上网</a></li>  </ul> 
                        </li>
                         </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                NodeJS
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/2653381572/">NodeJS Package Manage Tool - NPM</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder-open"></i>
                                &nbsp;
                                Python
                            </a>
                             <ul class="unstyled" id="tree" style="display: block;"> 
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Build-in
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/857250976/">Python build-in functions - List</a></li>  <li class="file"><a href="/posts/2858153934/">Python build-in functions - collections</a></li>  <li class="file"><a href="/posts/3208674450/">Python build-in module - os</a></li>  <li class="file"><a href="/posts/2434599799/">Python build-in functions</a></li>  <li class="file"><a href="/posts/5/">Python多线程和锁</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Configuration
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/3568487154/">更改pip源至国内镜像 - 显著提升下载速度</a></li>  </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                Library
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/4096440342/">Python Library - SQLAlchemy</a></li>  <li class="file"><a href="/posts/383305840/">Python Library - Flask SQLAlchemy</a></li>  <li class="file"><a href="/posts/55626181/">发布你自己的轮子 - PyPI打包上传实践</a></li>  <li class="file"><a href="/posts/3634498847/">我用 Python 的 Seaborn 库，绘制了 17 个超好看图表!</a></li>  </ul> 
                        </li>
                         <li class="file"><a href="/posts/272954362/">sys.stdout.write实现Python控制台实时刷新打印</a></li>  </ul> 
                        </li>
                         </ul> 
                        </li>
                        
                        <li class="directory" id="">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                iOS Development
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/posts/684390890/">Swift 5.4 有什么新功能？</a></li>  <li class="file"><a href="/posts/1054462359/">Apple Store上iOS App上架流程</a></li>  <li class="file"><a href="/posts/3772598043/">Swift：解包的正确姿势</a></li>  <li class="file"><a href="/posts/1098789015/">Xcode开发中Build与version区别/build自增设置/build随时间变化？</a></li>  </ul> 
                        </li>
                         </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });
        });
    </script>


    
        
    <div class="widget-wrap">
        <h3 class="widget-title"><span>最新文章</span></h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/posts/647907268/" class="thumbnail">
    
    
        <span style="background-image:url(https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210416015030.jpg)" alt="苹果M1芯片Macbook安装win10" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/OPS/">OPS</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/OPS/MacOS/">MacOS</a></p>
                            <p class="item-title"><a href="/posts/647907268/" class="title">苹果M1芯片Macbook安装win10</a></p>
                            <p class="item-date"><time datetime="2021-04-15T13:28:19.000Z" itemprop="datePublished">2021-04-16</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/posts/4263562837/" class="thumbnail">
    
    
        <span style="background-image:url(https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210328134957.png)" alt="一个惊人快速的终端录像工具，也能录制 VSCode 和 Chrome 窗口" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/OPS/">OPS</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/OPS/MacOS/">MacOS</a></p>
                            <p class="item-title"><a href="/posts/4263562837/" class="title">一个惊人快速的终端录像工具，也能录制 VSCode 和 Chrome 窗口</a></p>
                            <p class="item-date"><time datetime="2021-03-28T00:02:47.000Z" itemprop="datePublished">2021-03-28</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/posts/3634498847/" class="thumbnail">
    
    
        <span style="background-image:url(https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111745.png)" alt="我用 Python 的 Seaborn 库，绘制了 17 个超好看图表!" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/back-end/">back-end</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/back-end/Python/">Python</a></p>
                            <p class="item-title"><a href="/posts/3634498847/" class="title">我用 Python 的 Seaborn 库，绘制了 17 个超好看图表!</a></p>
                            <p class="item-date"><time datetime="2021-03-08T22:18:11.000Z" itemprop="datePublished">2021-03-09</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/posts/2097636152/" class="thumbnail">
    
    
        <span style="background-image:url(https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210303212435.jpg)" alt="工作两三年了，整不明白架构图都画啥？" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Soft-engineering/">Soft engineering</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Soft-engineering/Architecture/">Architecture</a></p>
                            <p class="item-title"><a href="/posts/2097636152/" class="title">工作两三年了，整不明白架构图都画啥？</a></p>
                            <p class="item-date"><time datetime="2021-03-03T08:09:53.000Z" itemprop="datePublished">2021-03-03</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/posts/2846671594/" class="thumbnail">
    
    
        <span style="background-image:url(https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228142136.jpg)" alt="RabbitMQ 集群高可用原理及实战部署介绍" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/back-end/">back-end</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/back-end/Middle-ware/">Middle-ware</a></p>
                            <p class="item-title"><a href="/posts/2846671594/" class="title">RabbitMQ 集群高可用原理及实战部署介绍</a></p>
                            <p class="item-date"><time datetime="2021-02-28T01:06:06.000Z" itemprop="datePublished">2021-02-28</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-OPS/Docker/Docker学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/OPS/">OPS</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/OPS/Docker/">Docker</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Docker/">Docker</a>, <a class="tag-link" href="/tags/笔记/">笔记</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/posts/1245529498/">
            <time datetime="2019-04-02T03:48:38.000Z" itemprop="datePublished">2019-04-02</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            Docker学习笔记
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                <div id="toc" class="toc-article">
                <strong class="toc-title">文章目录</strong>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-简介"><span class="toc-number">1.</span> <span class="toc-text">Docker 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-守护进程"><span class="toc-number">1.1.</span> <span class="toc-text">Docker 守护进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-客户端"><span class="toc-number">1.2.</span> <span class="toc-text">Docker 客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-内部"><span class="toc-number">1.3.</span> <span class="toc-text">Docker 内部</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-镜像"><span class="toc-number">1.3.1.</span> <span class="toc-text">Docker 镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-仓库"><span class="toc-number">1.3.2.</span> <span class="toc-text">Docker 仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-容器"><span class="toc-number">1.3.3.</span> <span class="toc-text">Docker 容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#libcontainer"><span class="toc-number">1.4.</span> <span class="toc-text">libcontainer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命名空间「Namespaces」"><span class="toc-number">1.5.</span> <span class="toc-text">命名空间「Namespaces」</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pid-namespace"><span class="toc-number">1.5.1.</span> <span class="toc-text">pid namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mnt-namespace"><span class="toc-number">1.5.2.</span> <span class="toc-text">mnt namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#net-namespace"><span class="toc-number">1.5.3.</span> <span class="toc-text">net namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uts-namespace"><span class="toc-number">1.5.4.</span> <span class="toc-text">uts namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ipc-namespace"><span class="toc-number">1.5.5.</span> <span class="toc-text">ipc namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#user-namespace"><span class="toc-number">1.5.6.</span> <span class="toc-text">user namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference"><span class="toc-number">1.5.7.</span> <span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资源配额「cgroups」"><span class="toc-number">1.6.</span> <span class="toc-text">资源配额「cgroups」</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-安装"><span class="toc-number">2.</span> <span class="toc-text">Docker 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#获取当前-docker-版本"><span class="toc-number">2.1.</span> <span class="toc-text">获取当前 docker 版本</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-基础用法"><span class="toc-number">3.</span> <span class="toc-text">Docker 基础用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Search-images"><span class="toc-number">3.1.</span> <span class="toc-text">Search images</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pull-images"><span class="toc-number">3.2.</span> <span class="toc-text">Pull images</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Running-an-interactive-shell"><span class="toc-number">3.3.</span> <span class="toc-text">Running an interactive shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关快捷键"><span class="toc-number">3.4.</span> <span class="toc-text">相关快捷键</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-命令帮助"><span class="toc-number">4.</span> <span class="toc-text">Docker 命令帮助</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-help"><span class="toc-number">4.1.</span> <span class="toc-text">docker help</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-command"><span class="toc-number">4.1.1.</span> <span class="toc-text">docker command</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-option"><span class="toc-number">4.1.2.</span> <span class="toc-text">docker option</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-search"><span class="toc-number">4.2.</span> <span class="toc-text">docker search</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-info"><span class="toc-number">4.3.</span> <span class="toc-text">docker info</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-pull-amp-amp-docker-push"><span class="toc-number">4.4.</span> <span class="toc-text">docker pull &amp;&amp; docker push</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-images"><span class="toc-number">4.5.</span> <span class="toc-text">docker images</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#列出当前系统镜像"><span class="toc-number">4.5.1.</span> <span class="toc-text">列出当前系统镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-rmi"><span class="toc-number">4.6.</span> <span class="toc-text">docker rmi</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-run"><span class="toc-number">4.7.</span> <span class="toc-text">docker run</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于cpu优先级"><span class="toc-number">4.7.1.</span> <span class="toc-text">关于cpu优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-start-stop-kill…-…"><span class="toc-number">4.8.</span> <span class="toc-text">docker start|stop|kill… …</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-1-3-新增特性和命令"><span class="toc-number">4.9.</span> <span class="toc-text">Docker 1.3 新增特性和命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Digital-Signature-Verification"><span class="toc-number">4.9.1.</span> <span class="toc-text">Digital Signature Verification</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-1-5-新特性"><span class="toc-number">4.10.</span> <span class="toc-text">Docker 1.5 新特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-端口映射"><span class="toc-number">5.</span> <span class="toc-text">Docker 端口映射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#自动映射端口"><span class="toc-number">5.1.</span> <span class="toc-text">自动映射端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#绑定端口到指定接口"><span class="toc-number">5.2.</span> <span class="toc-text">绑定端口到指定接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本语法"><span class="toc-number">5.2.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定-TCP-端口"><span class="toc-number">5.2.2.</span> <span class="toc-text">绑定 TCP 端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定-UDP-端口"><span class="toc-number">5.2.3.</span> <span class="toc-text">绑定 UDP 端口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-网络配置"><span class="toc-number">6.</span> <span class="toc-text">Docker 网络配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-四种网络模式"><span class="toc-number">6.1.</span> <span class="toc-text">Docker 四种网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#container-模式"><span class="toc-number">6.1.1.</span> <span class="toc-text">container 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#none模式"><span class="toc-number">6.1.2.</span> <span class="toc-text">none模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bridge模式"><span class="toc-number">6.1.3.</span> <span class="toc-text">bridge模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列出当前主机网桥"><span class="toc-number">6.2.</span> <span class="toc-text">列出当前主机网桥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查看当前-docker0-ip"><span class="toc-number">6.3.</span> <span class="toc-text">查看当前 docker0 ip</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运行一个容器"><span class="toc-number">6.3.1.</span> <span class="toc-text">运行一个容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用特定范围的-IP"><span class="toc-number">6.3.2.</span> <span class="toc-text">使用特定范围的 IP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不同主机间容器通信"><span class="toc-number">6.4.</span> <span class="toc-text">不同主机间容器通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不同容器之间的通信可以借助于-pipework-这个工具："><span class="toc-number">6.4.1.</span> <span class="toc-text">不同容器之间的通信可以借助于 pipework 这个工具：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装相应依赖软件"><span class="toc-number">6.4.2.</span> <span class="toc-text">安装相应依赖软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桥接网络"><span class="toc-number">6.4.3.</span> <span class="toc-text">桥接网络</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dockerfile"><span class="toc-number">7.</span> <span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FROM"><span class="toc-number">7.1.</span> <span class="toc-text">FROM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MAINTAINER"><span class="toc-number">7.2.</span> <span class="toc-text">MAINTAINER</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RUN-有两种使用方式"><span class="toc-number">7.2.1.</span> <span class="toc-text">RUN 有两种使用方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMD"><span class="toc-number">7.3.</span> <span class="toc-text">CMD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXPOSE"><span class="toc-number">7.4.</span> <span class="toc-text">EXPOSE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ENV"><span class="toc-number">7.5.</span> <span class="toc-text">ENV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADD"><span class="toc-number">7.6.</span> <span class="toc-text">ADD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#COPY"><span class="toc-number">7.7.</span> <span class="toc-text">COPY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ENTRYPOINT"><span class="toc-number">7.8.</span> <span class="toc-text">ENTRYPOINT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell-form-ENTRYPOINT-例子"><span class="toc-number">7.8.1.</span> <span class="toc-text">Shell form ENTRYPOINT 例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VOLUME"><span class="toc-number">7.9.</span> <span class="toc-text">VOLUME</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USER"><span class="toc-number">7.10.</span> <span class="toc-text">USER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WORKDIR"><span class="toc-number">7.11.</span> <span class="toc-text">WORKDIR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ONBUILD"><span class="toc-number">7.12.</span> <span class="toc-text">ONBUILD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile-Examples"><span class="toc-number">7.13.</span> <span class="toc-text">Dockerfile Examples</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-build"><span class="toc-number">7.14.</span> <span class="toc-text">docker build</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dockerfile-最佳实践"><span class="toc-number">7.15.</span> <span class="toc-text">dockerfile 最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-dockerignore文件"><span class="toc-number">7.15.1.</span> <span class="toc-text">使用.dockerignore文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免安装不必要的软件包"><span class="toc-number">7.15.2.</span> <span class="toc-text">避免安装不必要的软件包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#每个容器都跑一个进程"><span class="toc-number">7.15.3.</span> <span class="toc-text">每个容器都跑一个进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小化层"><span class="toc-number">7.15.4.</span> <span class="toc-text">最小化层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多行参数排序"><span class="toc-number">7.15.5.</span> <span class="toc-text">多行参数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建缓存"><span class="toc-number">7.15.6.</span> <span class="toc-text">创建缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile-指令"><span class="toc-number">7.15.7.</span> <span class="toc-text">Dockerfile 指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容器数据管理"><span class="toc-number">8.</span> <span class="toc-text">容器数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据卷"><span class="toc-number">8.1.</span> <span class="toc-text">数据卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建和挂载一个数据卷容器"><span class="toc-number">8.2.</span> <span class="toc-text">创建和挂载一个数据卷容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#备份、恢复或迁移数据卷"><span class="toc-number">8.3.</span> <span class="toc-text">备份、恢复或迁移数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#备份"><span class="toc-number">8.3.1.</span> <span class="toc-text">备份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#恢复"><span class="toc-number">8.3.2.</span> <span class="toc-text">恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除-Volumes"><span class="toc-number">8.4.</span> <span class="toc-text">删除 Volumes</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#链接容器"><span class="toc-number">9.</span> <span class="toc-text">链接容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#容器命名"><span class="toc-number">9.1.</span> <span class="toc-text">容器命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链接容器-1"><span class="toc-number">9.2.</span> <span class="toc-text">链接容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#环境变量"><span class="toc-number">9.2.1.</span> <span class="toc-text">环境变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构建私有库"><span class="toc-number">10.</span> <span class="toc-text">构建私有库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#快速构建"><span class="toc-number">10.1.</span> <span class="toc-text">快速构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不使用容器构建-registry"><span class="toc-number">10.2.</span> <span class="toc-text">不使用容器构建 registry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#高级启动方式-「不推荐」"><span class="toc-number">10.2.1.</span> <span class="toc-text">高级启动方式 「不推荐」</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提交指定容器到私有库"><span class="toc-number">10.3.</span> <span class="toc-text">提交指定容器到私有库</span></a></li></ol></li></ol>
                </div>
            
        
        
            <p><img src="https://www.jifu.io/images/2/20190403181303.png" alt=""></p>
<h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><p> Docker 两个主要部件：</p>
<ul>
<li>Docker: 开源的容器虚拟化平台</li>
<li>Docker Hub: 用于分享、管理 Docker 容器的 Docker SaaS 平台 – Docker Hub</li>
</ul>
<p>Docker 使用客户端-服务器 (C/S) 架构模式。Docker 客户端会与 Docker 守护进程进行通信。Docker 守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Docker 容器。Docker 客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker 客户端去连接一个远程的 Docker 守护进程。Docker 客户端和守护进程之间通过 socket 或者 RESTful API 进行通信。</p>
<a id="more"></a>
<p><img src="https://www.jifu.io/images/2/20190402161117.png" alt=""></p>
<h2 id="Docker-守护进程"><a href="#Docker-守护进程" class="headerlink" title="Docker 守护进程"></a>Docker 守护进程</h2><p>如上图所示，Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。</p>
<h2 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h2><p>Docker 客户端，实际上是 docker 的二进制程序，是主要的用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信，如此来回往复。</p>
<h2 id="Docker-内部"><a href="#Docker-内部" class="headerlink" title="Docker 内部"></a>Docker 内部</h2><p>要理解 Docker 内部构建，需要理解以下三种部件：</p>
<ul>
<li>Docker 镜像 - Docker images</li>
<li>Docker 仓库 - Docker registeries</li>
<li>Docker 容器 - Docker containers</li>
</ul>
<h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS 来将这些层联合到单独的镜像中。UnionFS 允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。</p>
<h3 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h3><p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker 仓库是 Docker 的分发部分。</p>
<h3 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h3><p>Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。</p>
<h2 id="libcontainer"><a href="#libcontainer" class="headerlink" title="libcontainer"></a>libcontainer</h2><p>Docker 从 0.9 版本开始使用 libcontainer 替代 lxc，libcontainer 和 Linux 系统的交互图如下：</p>
<p><img src="https://www.jifu.io/images/2/20190402161347.png" alt=""></p>
<h2 id="命名空间「Namespaces」"><a href="#命名空间「Namespaces」" class="headerlink" title="命名空间「Namespaces」"></a>命名空间「Namespaces」</h2><h3 id="pid-namespace"><a href="#pid-namespace" class="headerlink" title="pid namespace"></a>pid namespace</h3><p>不同用户的进程就是通过 pid namespace 隔离开的，且不同 namespace 中可以有相同 PID。具有以下特征:</p>
<p>每个 namespace 中的 pid 是有自己的 pid=1 的进程(类似 /sbin/init 进程)<br>每个 namespace 中的进程只能影响自己的同一个 namespace 或子 namespace 中的进程<br>因为 /proc 包含正在运行的进程，因此在 container 中的 pseudo-filesystem 的 /proc 目录只能看到自己 namespace 中的进程<br>因为 namespace 允许嵌套，父 namespace 可以影响子 namespace 的进程，所以子 namespace 的进程可以在父 namespace 中看到，但是具有不同的 pid</p>
<p>参考文档：<a href="https://blog.jtlebi.fr/2014/01/05/introduction-to-linux-namespaces-part-3-pid/" target="_blank" rel="noopener">Introduction to Linux namespaces – Part 3: PID</a></p>
<h3 id="mnt-namespace"><a href="#mnt-namespace" class="headerlink" title="mnt namespace"></a>mnt namespace</h3><p>类似 chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个 namespace 中的 container 在 /proc/mounts 的信息只包含所在 namespace 的 mount point。</p>
<h3 id="net-namespace"><a href="#net-namespace" class="headerlink" title="net namespace"></a>net namespace</h3><p>网络隔离是通过 net namespace 实现的， 每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。 docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge 连接在一起。</p>
<p>参考文档：<a href="https://blog.jtlebi.fr/2014/01/19/introduction-to-linux-namespaces-part-5-net/" target="_blank" rel="noopener">Introduction to Linux namespaces – Part 5: NET</a></p>
<h3 id="uts-namespace"><a href="#uts-namespace" class="headerlink" title="uts namespace"></a>uts namespace</h3><p>UTS (“UNIX Time-sharing System”) namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。</p>
<p>参考文档：<a href="https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/" target="_blank" rel="noopener">Introduction to Linux namespaces – Part 1: UTS</a></p>
<h3 id="ipc-namespace"><a href="#ipc-namespace" class="headerlink" title="ipc namespace"></a>ipc namespace</h3><p>container 中进程交互还是采用 Linux 常见的进程间交互方法 (interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同 VM 不同，container 的进程间交互实际上还是 host 上具有相同 pid namespace 中的进程间交互，因此需要在 IPC 资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32bit ID。</p>
<p>参考文档：<a href="https://blog.jtlebi.fr/2013/12/28/introduction-to-linux-namespaces-part-2-ipc/" target="_blank" rel="noopener">Introduction to Linux namespaces – Part 2: IPC</a></p>
<h3 id="user-namespace"><a href="#user-namespace" class="headerlink" title="user namespace"></a>user namespace</h3><p>每个 container 可以有不同的 user 和 group id, 也就是说可以以 container 内部的用户在 container 内部执行程序而非 Host 上的用户。</p>
<p>有了以上 6 种 namespace 从进程、网络、IPC、文件系统、UTS 和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。 然而不同 namespace 之间资源还是相互竞争的，仍然需要类似 ulimit 来管理每个 container 所能使用的资源 - cgroup。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://tiewei.github.io/cloud/Docker-Getting-Start/" target="_blank" rel="noopener">Docker Getting Start: Related Knowledge</a></p>
<p><a href="https://ruby-china.org/topics/22004" target="_blank" rel="noopener">Docker 介绍以及其相关术语、底层原理和技术</a></p>
<h2 id="资源配额「cgroups」"><a href="#资源配额「cgroups」" class="headerlink" title="资源配额「cgroups」"></a>资源配额「cgroups」</h2><p>cgroups 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子 subsystem ，{子系统前缀}.{资源项} 是典型的配置方法， 如 memory.usage_in_bytes 就定义了该 group 在 subsystem memory 中的一个内存限制选项。 另外，cgroups 中的 subsystem 可以随意组合，一个 subsystem 可以在不同的 group 中，也可以一个 group 包含多个 subsystem - 也就是说一个 subsystem。</p>
<ul>
<li><p>memory<br>内存相关的限制</p>
</li>
<li><p>cpu<br>在 cgroup 中，并不能像硬件虚拟化方案一样能够定义 CPU 能力，但是能够定义 CPU 轮转的优先级，因此具有较高 CPU 优先级的进程会更可能得到 CPU 运算。 通过将参数写入 cpu.shares ,即可定义改 cgroup 的 CPU 优先级 - 这里是一个相对权重，而非绝对值</p>
</li>
<li><p>blkio<br>block IO 相关的统计和限制，byte/operation 统计和限制 (IOPS 等)，读写速度限制等，但是这里主要统计的都是同步 IO</p>
</li>
<li><p>devices<br>设备权限限制</p>
</li>
</ul>
<p>参考文档：<a href="http://tiewei.github.io/devops/howto-use-cgroup/" target="_blank" rel="noopener">how to use cgroup</a></p>
<h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p>docker 的相关安装方法这里不作介绍，具体安装参考<a href="https://docs.docker.com/installation/" target="_blank" rel="noopener">官档</a></p>
<h2 id="获取当前-docker-版本"><a href="#获取当前-docker-版本" class="headerlink" title="获取当前 docker 版本"></a>获取当前 docker 版本</h2><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker version
Client version: 1.3.2
Client API version: 1.15
Go version <span class="token punctuation">(</span>client<span class="token punctuation">)</span>: go1.3.3
Git commit <span class="token punctuation">(</span>client<span class="token punctuation">)</span>: 39fa2fa/1.3.2
OS/Arch <span class="token punctuation">(</span>client<span class="token punctuation">)</span>: linux/amd64
Server version: 1.3.2
Server API version: 1.15
Go version <span class="token punctuation">(</span>server<span class="token punctuation">)</span>: go1.3.3
Git commit <span class="token punctuation">(</span>server<span class="token punctuation">)</span>: 39fa2fa/1.3.2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="Docker-基础用法"><a href="#Docker-基础用法" class="headerlink" title="Docker 基础用法"></a>Docker 基础用法</h1><p><a href="https://registry.hub.docker.com/" target="_blank" rel="noopener">Docker HUB</a> : Docker镜像首页，包括官方镜像和其它公开镜像</p>
<p>因为国情的原因，国内下载 Docker HUB 官方的相关镜像比较慢，可以使用 Daocloud 镜像加速。</p>
<h2 id="Search-images"><a href="#Search-images" class="headerlink" title="Search images"></a>Search images</h2><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker search ubuntu
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="Pull-images"><a href="#Pull-images" class="headerlink" title="Pull images"></a>Pull images</h2><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker pull ubuntu <span class="token comment" spellcheck="true"># 获取 ubuntu 官方镜像</span>
$ <span class="token function">sudo</span> docker images <span class="token comment" spellcheck="true"># 查看当前镜像列表</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="Running-an-interactive-shell"><a href="#Running-an-interactive-shell" class="headerlink" title="Running an interactive shell"></a>Running an interactive shell</h2><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -i -t ubuntu:14.04 /bin/bash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>docker run - 运行一个容器</li>
<li>-t - 分配一个（伪）tty (link is external)</li>
<li>-i - 交互模式 (so we can interact with it)</li>
<li>ubuntu:14.04 - 使用 ubuntu 基础镜像 14.04</li>
<li>/bin/bash - 运行命令 bash shell</li>
</ul>
<blockquote>
<p>注: ubuntu 会有多个版本，通过指定 tag 来启动特定的版本 [image]:[tag]</p>
</blockquote>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker <span class="token function">ps</span> <span class="token comment" spellcheck="true"># 查看当前运行的容器, ps -a 列出当前系统所有的容器</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
6c9129e9df10        ubuntu:14.04        /bin/bash           6 minutes ago       Up 6 minutes                            cranky_babbage
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="相关快捷键"><a href="#相关快捷键" class="headerlink" title="相关快捷键"></a>相关快捷键</h2><ul>
<li>退出：Ctrl-D or exit</li>
<li>detach：Ctrl-P + Ctrl-Q</li>
<li>attach: docker attach CONTAINER-ID</li>
</ul>
<h1 id="Docker-命令帮助"><a href="#Docker-命令帮助" class="headerlink" title="Docker 命令帮助"></a>Docker 命令帮助</h1><h2 id="docker-help"><a href="#docker-help" class="headerlink" title="docker help"></a>docker help</h2><h3 id="docker-command"><a href="#docker-command" class="headerlink" title="docker command"></a>docker command</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker   <span class="token comment" spellcheck="true"># docker 命令帮助</span>

Commands:
    attach    Attach to a running container                 <span class="token comment" spellcheck="true"># 当前 shell 下 attach 连接指定运行镜像</span>
    build     Build an image from a Dockerfile              <span class="token comment" spellcheck="true"># 通过 Dockerfile 定制镜像</span>
    commit    Create a new image from a container<span class="token string">'s changes # 提交当前容器为新的镜像
    cp        Copy files/folders from the containers filesystem to the host path
              # 从容器中拷贝指定文件或者目录到宿主机中
    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器
    diff      Inspect changes on a container'</span>s filesystem   <span class="token comment" spellcheck="true"># 查看 docker 容器变化</span>
    events    Get real <span class="token function">time</span> events from the server          <span class="token comment" spellcheck="true"># 从 docker 服务获取容器实时事件</span>
    <span class="token function">exec</span>      Run a <span class="token function">command</span> <span class="token keyword">in</span> an existing container        <span class="token comment" spellcheck="true"># 在已存在的容器上运行命令</span>
    <span class="token function">export</span>    Stream the contents of a container as a <span class="token function">tar</span> archive
              <span class="token comment" spellcheck="true"># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span>
    <span class="token function">history</span>   Show the <span class="token function">history</span> of an image                  <span class="token comment" spellcheck="true"># 展示一个镜像形成历史</span>
    images    List images                                   <span class="token comment" spellcheck="true"># 列出系统当前镜像</span>
    <span class="token function">import</span>    Create a new filesystem image from the contents of a tarball
              <span class="token comment" spellcheck="true"># 从tar包中的内容创建一个新的文件系统映像[对应 export]</span>
    info      Display system-wide information               <span class="token comment" spellcheck="true"># 显示系统相关信息</span>
    inspect   Return low-level information on a container   <span class="token comment" spellcheck="true"># 查看容器详细信息</span>
    <span class="token function">kill</span>      Kill a running container                      <span class="token comment" spellcheck="true"># kill 指定 docker 容器</span>
    load      Load an image from a <span class="token function">tar</span> archive              <span class="token comment" spellcheck="true"># 从一个 tar 包中加载一个镜像[对应 save]</span>
    login     Register or Login to the docker registry server
              <span class="token comment" spellcheck="true"># 注册或者登陆一个 docker 源服务器</span>
    <span class="token function">logout</span>    Log out from a Docker registry server         <span class="token comment" spellcheck="true"># 从当前 Docker registry 退出</span>
    logs      Fetch the logs of a container                 <span class="token comment" spellcheck="true"># 输出当前容器日志信息</span>
    port      Lookup the public-facing port <span class="token function">which</span> is NAT-ed to PRIVATE_PORT
              <span class="token comment" spellcheck="true"># 查看映射端口对应的容器内部源端口</span>
    pause     Pause all processes within a container        <span class="token comment" spellcheck="true"># 暂停容器</span>
    <span class="token function">ps</span>        List containers                               <span class="token comment" spellcheck="true"># 列出容器列表</span>
    pull      Pull an image or a repository from the docker registry server
              <span class="token comment" spellcheck="true"># 从docker镜像源服务器拉取指定镜像或者库镜像</span>
    push      Push an image or a repository to the docker registry server
              <span class="token comment" spellcheck="true"># 推送指定镜像或者库镜像至docker源服务器</span>
    restart   Restart a running container                   <span class="token comment" spellcheck="true"># 重启运行的容器</span>
    <span class="token function">rm</span>        Remove one or <span class="token function">more</span> containers                 <span class="token comment" spellcheck="true"># 移除一个或者多个容器</span>
    rmi       Remove one or <span class="token function">more</span> images
              <span class="token comment" spellcheck="true"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span>
    run       Run a <span class="token function">command</span> <span class="token keyword">in</span> a new container
              <span class="token comment" spellcheck="true"># 创建一个新的容器并运行一个命令</span>
    save      Save an image to a <span class="token function">tar</span> archive                <span class="token comment" spellcheck="true"># 保存一个镜像为一个 tar 包[对应 load]</span>
    search    Search <span class="token keyword">for</span> an image on the Docker Hub         <span class="token comment" spellcheck="true"># 在 docker hub 中搜索镜像</span>
    start     Start a stopped containers                    <span class="token comment" spellcheck="true"># 启动容器</span>
    stop      Stop a running containers                     <span class="token comment" spellcheck="true"># 停止容器</span>
    tag       Tag an image into a repository                <span class="token comment" spellcheck="true"># 给源中镜像打标签</span>
    <span class="token function">top</span>       Lookup the running processes of a container   <span class="token comment" spellcheck="true"># 查看容器中运行的进程信息</span>
    unpause   Unpause a paused container                    <span class="token comment" spellcheck="true"># 取消暂停容器</span>
    version   Show the docker version information           <span class="token comment" spellcheck="true"># 查看 docker 版本号</span>
    <span class="token function">wait</span>      Block <span class="token keyword">until</span> a container stops, <span class="token keyword">then</span> print its <span class="token keyword">exit</span> code
              <span class="token comment" spellcheck="true"># 截取容器停止时的退出状态值</span>
Run <span class="token string">'docker COMMAND --help'</span> <span class="token keyword">for</span> <span class="token function">more</span> information on a command.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="docker-option"><a href="#docker-option" class="headerlink" title="docker option"></a>docker option</h3><pre class="line-numbers language-bash"><code class="language-bash">Usage of docker:
  --api-enable-cors<span class="token operator">=</span>false                Enable CORS headers <span class="token keyword">in</span> the remote API                      <span class="token comment" spellcheck="true"># 远程 API 中开启 CORS 头</span>
  -b, --bridge<span class="token operator">=</span><span class="token string">""</span>                        Attach containers to a pre-existing network bridge         <span class="token comment" spellcheck="true"># 桥接网络</span>
                                           use <span class="token string">'none'</span> to disable container networking
  --bip<span class="token operator">=</span><span class="token string">""</span>                               Use this CIDR notation address <span class="token keyword">for</span> the network bridge<span class="token string">'s IP, not compatible with -b
                                         # 和 -b 选项不兼容，具体没有测试过
  -d, --daemon=false                     Enable daemon mode                                         # daemon 模式
  -D, --debug=false                      Enable debug mode                                          # debug 模式
  --dns=[]                               Force docker to use specific DNS servers                   # 强制 docker 使用指定 dns 服务器
  --dns-search=[]                        Force Docker to use specific DNS search domains            # 强制 docker 使用指定 dns 搜索域
  -e, --exec-driver="native"             Force the docker runtime to use a specific exec driver     # 强制 docker 运行时使用指定执行驱动器
  --fixed-cidr=""                        IPv4 subnet for fixed IPs (ex: 10.20.0.0/16)
                                           this subnet must be nested in the bridge subnet (which is defined by -b or --bip)
  -G, --group="docker"                   Group to assign the unix socket specified by -H when running in daemon mode
                                           use '</span>' <span class="token punctuation">(</span>the empty string<span class="token punctuation">)</span> to disable setting of a group
  -g, --graph<span class="token operator">=</span><span class="token string">"/var/lib/docker"</span>          Path to use as the root of the docker runtime              <span class="token comment" spellcheck="true"># 容器运行的根目录路径</span>
  -H, --host<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                          The socket<span class="token punctuation">(</span>s<span class="token punctuation">)</span> to bind to <span class="token keyword">in</span> daemon mode                    <span class="token comment" spellcheck="true"># daemon 模式下 docker 指定绑定方式[tcp or 本地 socket]</span>
                                           specified using one or <span class="token function">more</span> tcp://host:port, unix:///path/to/socket, fd://* or fd://socketfd.
  --icc<span class="token operator">=</span>true                             Enable inter-container communication                       <span class="token comment" spellcheck="true"># 跨容器通信</span>
  --insecure-registry<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                 Enable insecure communication with specified registries <span class="token punctuation">(</span>no certificate verification <span class="token keyword">for</span> HTTPS and <span class="token function">enable</span> HTTP fallback<span class="token punctuation">)</span> <span class="token punctuation">(</span>e.g., localhost:5000 or 10.20.0.0/16<span class="token punctuation">)</span>
  --ip<span class="token operator">=</span><span class="token string">"0.0.0.0"</span>                         Default IP address to use when binding container ports     <span class="token comment" spellcheck="true"># 指定监听地址，默认所有 ip</span>
  --ip-forward<span class="token operator">=</span>true                      Enable net.ipv4.ip_forward                                 <span class="token comment" spellcheck="true"># 开启转发</span>
  --ip-masq<span class="token operator">=</span>true                         Enable IP masquerading <span class="token keyword">for</span> bridge<span class="token string">'s IP range
  --iptables=true                        Enable Docker'</span>s addition of iptables rules                 <span class="token comment" spellcheck="true"># 添加对应 iptables 规则</span>
  --mtu<span class="token operator">=</span>0                                Set the containers network MTU                             <span class="token comment" spellcheck="true"># 设置网络 mtu</span>
                                           <span class="token keyword">if</span> no value is provided: default to the default route MTU or 1500 <span class="token keyword">if</span> no default route is available
  -p, --pidfile<span class="token operator">=</span><span class="token string">"/var/run/docker.pid"</span>    Path to use <span class="token keyword">for</span> daemon PID <span class="token function">file</span>                            <span class="token comment" spellcheck="true"># 指定 pid 文件位置</span>
  --registry-mirror<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                   Specify a preferred Docker registry mirror
  -s, --storage-driver<span class="token operator">=</span><span class="token string">""</span>                Force the docker runtime to use a specific storage driver  <span class="token comment" spellcheck="true"># 强制 docker 运行时使用指定存储驱动</span>
  --selinux-enabled<span class="token operator">=</span>false                Enable selinux support                                     <span class="token comment" spellcheck="true"># 开启 selinux 支持</span>
  --storage-opt<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                       Set storage driver options                                 <span class="token comment" spellcheck="true"># 设置存储驱动选项</span>
  --tls<span class="token operator">=</span>false                            Use TLS<span class="token punctuation">;</span> implied by tls-verify flags                       <span class="token comment" spellcheck="true"># 开启 tls</span>
  --tlscacert<span class="token operator">=</span><span class="token string">"/root/.docker/ca.pem"</span>     Trust only remotes providing a certificate signed by the CA given here
  --tlscert<span class="token operator">=</span><span class="token string">"/root/.docker/cert.pem"</span>     Path to TLS certificate <span class="token function">file</span>                               <span class="token comment" spellcheck="true"># tls 证书文件位置</span>
  --tlskey<span class="token operator">=</span><span class="token string">"/root/.docker/key.pem"</span>       Path to TLS key <span class="token function">file</span>                                       <span class="token comment" spellcheck="true"># tls key 文件位置</span>
  --tlsverify<span class="token operator">=</span>false                      Use TLS and verify the remote <span class="token punctuation">(</span>daemon: verify client, client: verify daemon<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 使用 tls 并确认远程控制主机</span>
  -v, --version<span class="token operator">=</span>false                    Print version information and quit                         <span class="token comment" spellcheck="true"># 输出 docker 版本信息</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h2><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker search --help

Usage: docker search TERM

Search the Docker Hub <span class="token keyword">for</span> images     <span class="token comment" spellcheck="true"># 从 Docker Hub 搜索镜像</span>

  --automated<span class="token operator">=</span>false    Only show automated builds
  --no-trunc<span class="token operator">=</span>false     Don't truncate output
  -s, --stars<span class="token operator">=</span>0        Only displays with at least xxx stars
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker search -s 100 ubuntu
<span class="token comment" spellcheck="true"># 查找 star 数至少为 100 的镜像，找出只有官方镜像 start 数超过 100，默认不加 s 选项找出所有相关 ubuntu 镜像</span>
NAME      DESCRIPTION                  STARS     OFFICIAL   AUTOMATED
ubuntu    Official Ubuntu base image   425       <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h2><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker info
Containers: 1                       <span class="token comment" spellcheck="true"># 容器个数</span>
Images: 22                          <span class="token comment" spellcheck="true"># 镜像个数</span>
Storage Driver: devicemapper        <span class="token comment" spellcheck="true"># 存储驱动</span>
 Pool Name: docker-8:17-3221225728-pool
 Pool Blocksize: 65.54 kB
 Data file: /data/docker/devicemapper/devicemapper/data
 Metadata file: /data/docker/devicemapper/devicemapper/metadata
 Data Space Used: 1.83 GB
 Data Space Total: 107.4 GB
 Metadata Space Used: 2.191 MB
 Metadata Space Total: 2.147 GB
 Library Version: 1.02.84-RHEL7 <span class="token punctuation">(</span>2014-03-26<span class="token punctuation">)</span>
Execution Driver: native-0.2        <span class="token comment" spellcheck="true"># 存储驱动</span>
Kernel Version: 3.10.0-123.el7.x86_64
Operating System: CentOS Linux 7 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="docker-pull-amp-amp-docker-push"><a href="#docker-pull-amp-amp-docker-push" class="headerlink" title="docker pull &amp;&amp; docker push"></a>docker pull &amp;&amp; docker push</h2><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker pull --help           <span class="token comment" spellcheck="true"># pull 拉取镜像</span>

Usage: docker pull <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> NAME<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span>

Pull an image or a repository from the registry

  -a, --all-tags<span class="token operator">=</span>false    Download all tagged images <span class="token keyword">in</span> the repository

$ <span class="token function">sudo</span> docker push                  <span class="token comment" spellcheck="true"># push 推送指定镜像</span>

Usage: docker push NAME<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span>

Push an image or a repository to the registry
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker pull ubuntu           <span class="token comment" spellcheck="true"># 下载官方 ubuntu docker 镜像，默认下载所有 ubuntu 官方库镜像</span>
$ <span class="token function">sudo</span> docker pull ubuntu:14.04     <span class="token comment" spellcheck="true"># 下载指定版本 ubuntu 官方镜像</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker push 192.168.0.100:5000/ubuntu
<span class="token comment" spellcheck="true"># 推送镜像库到私有源[可注册 docker 官方账户，推送到官方自有账户]</span>
$ <span class="token function">sudo</span> docker push 192.168.0.100:5000/ubuntu:14.04
<span class="token comment" spellcheck="true"># 推送指定镜像到私有源</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><h3 id="列出当前系统镜像"><a href="#列出当前系统镜像" class="headerlink" title="列出当前系统镜像"></a>列出当前系统镜像</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker images --help

Usage: docker images <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> <span class="token punctuation">[</span>NAME<span class="token punctuation">]</span>

List images

  -a, --all<span class="token operator">=</span>false      Show all images <span class="token punctuation">(</span>by default filter out the intermediate image layers<span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true"># -a 显示当前系统的所有镜像，包括过渡层镜像，默认 docker images 显示最终镜像，不包括过渡层镜像</span>
  -f, --filter<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>      Provide filter values <span class="token punctuation">(</span>i.e. <span class="token string">'dangling=true'</span><span class="token punctuation">)</span>
  --no-trunc<span class="token operator">=</span>false     Don't truncate output
  -q, --quiet<span class="token operator">=</span>false    Only show numeric IDs
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker images            <span class="token comment" spellcheck="true"># 显示当前系统镜像，不包括过渡层镜像</span>
$ <span class="token function">sudo</span> docker images -a         <span class="token comment" spellcheck="true"># 显示当前系统所有镜像，包括过渡层镜像</span>
$ <span class="token function">sudo</span> docker images ubuntu     <span class="token comment" spellcheck="true"># 显示当前系统 docker ubuntu 库中的所有镜像</span>
REPOSITORY                 TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu                     12.04               ebe4be4dd427        4 weeks ago         210.6 MB
ubuntu                     14.04               e54ca5efa2e9        4 weeks ago         276.5 MB
ubuntu                     14.04-ssh           6334d3ac099a        7 weeks ago         383.2 MB
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h2><p>删除一个或者多个镜像</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker rmi --help

Usage: docker rmi IMAGE <span class="token punctuation">[</span>IMAGE<span class="token punctuation">..</span>.<span class="token punctuation">]</span>

Remove one or <span class="token function">more</span> images

  -f, --force<span class="token operator">=</span>false    Force removal of the image       <span class="token comment" spellcheck="true"># 强制移除镜像不管是否有容器使用该镜像</span>
  --no-prune<span class="token operator">=</span>false     Do not delete untagged parents   <span class="token comment" spellcheck="true"># 不要删除未标记的父镜像</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run --help

Usage: docker run <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> IMAGE <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> <span class="token punctuation">[</span>ARG<span class="token punctuation">..</span>.<span class="token punctuation">]</span>

Run a <span class="token function">command</span> <span class="token keyword">in</span> a new container

  -a, --attach<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            Attach to stdin, stdout or stderr.
  -c, --cpu-shares<span class="token operator">=</span>0         CPU shares <span class="token punctuation">(</span>relative weight<span class="token punctuation">)</span>                       <span class="token comment" spellcheck="true"># 设置 cpu 使用权重</span>
  --cap-add<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>               Add Linux capabilities
  --cap-drop<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>              Drop Linux capabilities
  --cidfile<span class="token operator">=</span><span class="token string">""</span>               Write the container ID to the <span class="token function">file</span>                 <span class="token comment" spellcheck="true"># 把容器 id 写入到指定文件</span>
  --cpuset<span class="token operator">=</span><span class="token string">""</span>                CPUs <span class="token keyword">in</span> <span class="token function">which</span> to allow execution <span class="token punctuation">(</span>0-3, 0,1<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># cpu 绑定</span>
  -d, --detach<span class="token operator">=</span>false         Detached mode: Run container <span class="token keyword">in</span> the background, print new container <span class="token function">id</span> <span class="token comment" spellcheck="true"># 后台运行容器</span>
  --device<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                Add a host device to the container <span class="token punctuation">(</span>e.g. --device<span class="token operator">=</span>/dev/sdc:/dev/xvdc<span class="token punctuation">)</span>
  --dns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                   Set custom dns servers                             <span class="token comment" spellcheck="true"># 设置 dns</span>
  --dns-search<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            Set custom dns search domains                      <span class="token comment" spellcheck="true"># 设置 dns 域搜索</span>
  -e, --env<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>               Set environment variables                          <span class="token comment" spellcheck="true"># 定义环境变量</span>
  --entrypoint<span class="token operator">=</span><span class="token string">""</span>            Overwrite the default entrypoint of the image      <span class="token comment" spellcheck="true"># ？</span>
  --env-file<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>              Read <span class="token keyword">in</span> a line delimited <span class="token function">file</span> of ENV variables     <span class="token comment" spellcheck="true"># 从指定文件读取变量值</span>
  --expose<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                Expose a port from the container without publishing it to your host    <span class="token comment" spellcheck="true"># 指定对外提供服务端口</span>
  -h, --hostname<span class="token operator">=</span><span class="token string">""</span>          Container host name                                <span class="token comment" spellcheck="true"># 设置容器主机名</span>
  -i, --interactive<span class="token operator">=</span>false    Keep stdin <span class="token function">open</span> even <span class="token keyword">if</span> not attached               <span class="token comment" spellcheck="true"># 保持标准输出开启即使没有 attached</span>
  --link<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                  Add <span class="token function">link</span> to another container <span class="token punctuation">(</span>name:alias<span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># 添加链接到另外一个容器</span>
  --lxc-conf<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>              <span class="token punctuation">(</span>lxc exec-driver only<span class="token punctuation">)</span> Add custom lxc options --lxc-conf<span class="token operator">=</span><span class="token string">"lxc.cgroup.cpuset.cpus = 0,1"</span>
  -m, --memory<span class="token operator">=</span><span class="token string">""</span>            Memory limit <span class="token punctuation">(</span>format: <span class="token operator">&lt;</span>number<span class="token operator">></span><span class="token operator">&lt;</span>optional unit<span class="token operator">></span>, where unit <span class="token operator">=</span> b, k, m or g<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 内存限制</span>
  --name<span class="token operator">=</span><span class="token string">""</span>                  Assign a name to the container                     <span class="token comment" spellcheck="true"># 设置容器名</span>
  --net<span class="token operator">=</span><span class="token string">"bridge"</span>             Set the Network mode <span class="token keyword">for</span> the container             <span class="token comment" spellcheck="true"># 设置容器网络模式</span>
                               <span class="token string">'bridge'</span><span class="token keyword">:</span> creates a new network stack <span class="token keyword">for</span> the container on the docker bridge
                               <span class="token string">'none'</span><span class="token keyword">:</span> no networking <span class="token keyword">for</span> this container
                               <span class="token string">'container:&lt;name|id>'</span><span class="token keyword">:</span> reuses another container network stack
                               <span class="token string">'host'</span><span class="token keyword">:</span> use the host network stack inside the container.  Note: the host mode gives the container full access to local system services such as D-bus and is therefore considered insecure.
  -P, --publish-all<span class="token operator">=</span>false    Publish all exposed ports to the host interfaces   <span class="token comment" spellcheck="true"># 自动映射容器对外提供服务的端口</span>
  -p, --publish<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>           Publish a container<span class="token string">'s port to the host             # 指定端口映射
                               format: ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort
                               (use '</span>docker port' to see the actual mapping<span class="token punctuation">)</span>
  --privileged<span class="token operator">=</span>false         Give extended privileges to this container         <span class="token comment" spellcheck="true"># 提供更多的权限给容器</span>
  --restart<span class="token operator">=</span><span class="token string">""</span>               Restart policy to apply when a container exits <span class="token punctuation">(</span>no, on-failure<span class="token punctuation">[</span>:max-retry<span class="token punctuation">]</span>, always<span class="token punctuation">)</span>
  --rm<span class="token operator">=</span>false                 Automatically remove the container when it exits <span class="token punctuation">(</span>incompatible with -d<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 如果容器退出自动移除和 -d 选项冲突</span>
  --security-opt<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>          Security Options
  --sig-proxy<span class="token operator">=</span>true           Proxify received signals to the process <span class="token punctuation">(</span>even <span class="token keyword">in</span> non-tty mode<span class="token punctuation">)</span>. SIGCHLD is not proxied.
  -t, --tty<span class="token operator">=</span>false            Allocate a pseudo-tty                              <span class="token comment" spellcheck="true"># 分配伪终端</span>
  -u, --user<span class="token operator">=</span><span class="token string">""</span>              Username or UID                                    <span class="token comment" spellcheck="true"># 指定运行容器的用户 uid 或者用户名</span>
  -v, --volume<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            Bind <span class="token function">mount</span> a volume <span class="token punctuation">(</span>e.g., from the host: -v /host:/container, from docker: -v /container<span class="token punctuation">)</span>
                             <span class="token comment" spellcheck="true"># 挂载卷</span>
  --volumes-from<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>          Mount volumes from the specified container<span class="token punctuation">(</span>s<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 从指定容器挂载卷</span>
  -w, --workdir<span class="token operator">=</span><span class="token string">""</span>           Working directory inside the container             <span class="token comment" spellcheck="true"># 指定容器工作目录</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker images ubuntu
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              14.04               e54ca5efa2e9        4 weeks ago         276.5 MB
<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.
$ <span class="token function">sudo</span> docker run -t -i -c 100 -m 512MB -h test1 -d --name<span class="token operator">=</span><span class="token string">"docker_test1"</span> ubuntu /bin/bash
<span class="token comment" spellcheck="true"># 创建一个 cpu 优先级为 100，内存限制 512MB，主机名为 test1，名为 docker_test1 后台运行 bash 的容器</span>
a424ca613c9f2247cd3ede95adfbaf8d28400cbcb1d5f9b69a7b56f97b2b52e5
$ <span class="token function">sudo</span> docker <span class="token function">ps</span>
CONTAINER ID        IMAGE           COMMAND         CREATED             STATUS              PORTS       NAMES
a424ca613c9f        ubuntu:14.04    /bin/bash       6 seconds ago       Up 5 seconds                    docker_test1
$ <span class="token function">sudo</span> docker attach docker_test1
root@test1:/<span class="token comment" spellcheck="true"># pwd</span>
/
root@test1:/<span class="token comment" spellcheck="true"># exit</span>
<span class="token keyword">exit</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="关于cpu优先级"><a href="#关于cpu优先级" class="headerlink" title="关于cpu优先级"></a>关于cpu优先级</h3><blockquote>
<p>By default all groups have 1024 shares. A group with 100 shares will get a ~10% portion of the CPU time - archlinux cgroups</p>
</blockquote>
<h2 id="docker-start-stop-kill…-…"><a href="#docker-start-stop-kill…-…" class="headerlink" title="docker start|stop|kill… …"></a>docker start|stop|kill… …</h2><pre class="line-numbers language-bash"><code class="language-bash">docker start CONTAINER <span class="token punctuation">[</span>CONTAINER…<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># 运行一个或多个停止的容器</span>
docker stop CONTAINER <span class="token punctuation">[</span>CONTAINER…<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># 停掉一个或多个运行的容器 -t 选项可指定超时时间</span>
docker <span class="token function">kill</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER <span class="token punctuation">[</span>CONTAINER…<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># 默认 kill 发送 SIGKILL 信号 -s 可以指定发送 kill 信号类型</span>
docker restart <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER <span class="token punctuation">[</span>CONTAINER…<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># 重启一个或多个运行的容器 -t 选项可指定超时时间</span>
docker pause CONTAINER
<span class="token comment" spellcheck="true"># 暂停一个容器，方便 commit</span>
docker unpause CONTAINER
<span class="token comment" spellcheck="true"># 继续暂停的容器</span>
docker <span class="token function">rm</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER <span class="token punctuation">[</span>CONTAINER…<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># 移除一个或多个容器</span>
-f, –force<span class="token operator">=</span>false Force removal of running container
-l, –link<span class="token operator">=</span>false Remove the specified <span class="token function">link</span> and not the underlying container
-v, –volumes<span class="token operator">=</span>false Remove the volumes associated with the container
docker commit <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER <span class="token punctuation">[</span>REPOSITORY<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># 提交指定容器为镜像</span>
-a, –author<span class="token operator">=</span>”” Author <span class="token punctuation">(</span>e.g., “John Hannibal Smith hannibal@a-team.com”<span class="token punctuation">)</span>
-m, –message<span class="token operator">=</span>”” Commit message
-p, –pause<span class="token operator">=</span>true Pause container during commit
<span class="token comment" spellcheck="true"># 默认 commit 是暂停状态</span>
docker inspect CONTAINER<span class="token operator">|</span>IMAGE <span class="token punctuation">[</span>CONTAINER<span class="token operator">|</span>IMAGE…<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># 查看容器或者镜像的详细信息</span>
docker logs CONTAINER
<span class="token comment" spellcheck="true"># 输出指定容器日志信息</span>
-f, –follow<span class="token operator">=</span>false Follow log output
<span class="token comment" spellcheck="true"># 类似 tail -f</span>
-t, –timestamps<span class="token operator">=</span>false Show timestamps
–tail<span class="token operator">=</span>”all” Output the specified number of lines at the end of logs <span class="token punctuation">(</span>defaults to all logs<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参考文档：<a href="https://docs.docker.com/reference/run/" target="_blank" rel="noopener">Docker Run Reference</a></p>
<h2 id="Docker-1-3-新增特性和命令"><a href="#Docker-1-3-新增特性和命令" class="headerlink" title="Docker 1.3 新增特性和命令"></a>Docker 1.3 新增特性和命令</h2><h3 id="Digital-Signature-Verification"><a href="#Digital-Signature-Verification" class="headerlink" title="Digital Signature Verification"></a>Digital Signature Verification</h3><p>Docker 1.3 版本将使用数字签名自动验证所有官方库的来源和完整性，如果一个官方镜像被篡改或者被破坏，目前 Docker 只会对这种情况发出警告而并不阻止容器的运行。</p>
<p>Inject new processes with <code>docker exec</code></p>
<pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> --help

Usage: docker <span class="token function">exec</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER COMMAND <span class="token punctuation">[</span>ARG<span class="token punctuation">..</span>.<span class="token punctuation">]</span>

Run a <span class="token function">command</span> <span class="token keyword">in</span> an existing container

  -d, --detach<span class="token operator">=</span>false         Detached mode: run <span class="token function">command</span> <span class="token keyword">in</span> the background
  -i, --interactive<span class="token operator">=</span>false    Keep STDIN <span class="token function">open</span> even <span class="token keyword">if</span> not attached
  -t, --tty<span class="token operator">=</span>false            Allocate a pseudo-TTY
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了简化调试，可以使用 docker exec 命令通过 Docker API 和 CLI 在运行的容器上运行程序。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">exec</span> -it ubuntu_bash <span class="token function">bash</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上例将在容器 ubuntu_bash 中创建一个新的 Bash 会话。</p>
<p>Tune container lifecycles with <code>docker create</code></p>
<p>我们可以通过<code>docker run &lt;image name&gt;</code>命令创建一个容器并运行其中的程序，因为有很多用户要求创建容器的时候不启动容器，所以<code>docker create</code>应运而生了。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker create -t -i fedora <span class="token function">bash</span>
6d8af538ec541dd581ebc2a24153a28329acb5268abe5ef868c1f1a261221752
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上例创建了一个可写的容器层 (并且打印出容器 ID)，但是并不运行它，可以使用以下命令运行该容器：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker start -a -i 6d8af538ec5
bash-4.2<span class="token comment" spellcheck="true">#</span>
Security Options
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>通过<code>--security-opt</code>选项，运行容器时用户可自定义 SELinux 和 AppArmor 卷标和配置。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run --security-opt label:type:svirt_apache -i -t centos \ <span class="token function">bash</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上例只允许容器监听在 Apache 端口，这个选项的好处是用户不需要运行 docker 的时候指定<code>--privileged</code>选项，降低安全风险。</p>
<p>参考文档：Docker 1.3: signed images, process injection, security options, Mac shared directories</p>
<h2 id="Docker-1-5-新特性"><a href="#Docker-1-5-新特性" class="headerlink" title="Docker 1.5 新特性"></a>Docker 1.5 新特性</h2><p>参考文档：<a href="http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/" target="_blank" rel="noopener">Docker 1.5 新特性</a></p>
<h1 id="Docker-端口映射"><a href="#Docker-端口映射" class="headerlink" title="Docker 端口映射"></a>Docker 端口映射</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Find IP address of container with ID &lt;container_id> 通过容器 id 获取 ip</span>
$ <span class="token function">sudo</span> docker inspect <span class="token operator">&lt;</span>container_id<span class="token operator">></span> <span class="token operator">|</span> <span class="token function">grep</span> IPAddress <span class="token operator">|</span> <span class="token function">cut</span> -d ’"’ -f 4
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>无论如何，这些 ip 是基于本地系统的并且容器的端口非本地主机是访问不到的。此外，除了端口只能本地访问外，对于容器的另外一个问题是这些 ip 在容器每次启动的时候都会改变。</p>
<p>Docker 解决了容器的这两个问题，并且给容器内部服务的访问提供了一个简单而可靠的方法。Docker 通过端口绑定主机系统的接口，允许非本地客户端访问容器内部运行的服务。为了简便的使得容器间通信，Docker 提供了这种连接机制。</p>
<h2 id="自动映射端口"><a href="#自动映射端口" class="headerlink" title="自动映射端口"></a>自动映射端口</h2><p><code>-P</code>使用时需要指定<code>--expose</code>选项，指定需要对外提供服务的端口</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -t -P --expose 22 --name server  ubuntu:14.04
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用<code>docker run -P</code>自动绑定所有对外提供服务的容器端口，映射的端口将会从没有使用的端口池中 (49000..49900) 自动选择，你可以通过<code>docker ps</code>、<code>docker inspect &lt;container_id&gt;</code>或者<code>docker port &lt;container_id&gt; &lt;port&gt;</code>确定具体的绑定信息。</p>
<h2 id="绑定端口到指定接口"><a href="#绑定端口到指定接口" class="headerlink" title="绑定端口到指定接口"></a>绑定端口到指定接口</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -p <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>host_interface<span class="token operator">></span>:<span class="token punctuation">[</span>host_port<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>host_port<span class="token operator">></span><span class="token punctuation">)</span>:<span class="token punctuation">]</span><span class="token operator">&lt;</span>container_port<span class="token operator">></span><span class="token punctuation">[</span>/udp<span class="token punctuation">]</span> <span class="token operator">&lt;</span>image<span class="token operator">></span> <span class="token operator">&lt;</span>cmd<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>默认不指定绑定 ip 则监听所有网络接口。</p>
<h3 id="绑定-TCP-端口"><a href="#绑定-TCP-端口" class="headerlink" title="绑定 TCP 端口"></a>绑定 TCP 端口</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Bind TCP port 8080 of the container to TCP port 80 on 127.0.0.1 of the host machine.</span>
$ <span class="token function">sudo</span> docker run -p 127.0.0.1:80:8080 <span class="token operator">&lt;</span>image<span class="token operator">></span> <span class="token operator">&lt;</span>cmd<span class="token operator">></span>
<span class="token comment" spellcheck="true"># Bind TCP port 8080 of the container to a dynamically allocated TCP port on 127.0.0.1 of the host machine.</span>
$ <span class="token function">sudo</span> docker run -p 127.0.0.1::8080 <span class="token operator">&lt;</span>image<span class="token operator">></span> <span class="token operator">&lt;</span>cmd<span class="token operator">></span>
<span class="token comment" spellcheck="true"># Bind TCP port 8080 of the container to TCP port 80 on all available interfaces of the host machine.</span>
$ <span class="token function">sudo</span> docker run -p 80:8080 <span class="token operator">&lt;</span>image<span class="token operator">></span> <span class="token operator">&lt;</span>cmd<span class="token operator">></span>
<span class="token comment" spellcheck="true"># Bind TCP port 8080 of the container to a dynamically allocated TCP port on all available interfaces</span>
$ <span class="token function">sudo</span> docker run -p 8080 <span class="token operator">&lt;</span>image<span class="token operator">></span> <span class="token operator">&lt;</span>cmd<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="绑定-UDP-端口"><a href="#绑定-UDP-端口" class="headerlink" title="绑定 UDP 端口"></a>绑定 UDP 端口</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Bind UDP port 5353 of the container to UDP port 53 on 127.0.0.1 of the host machine.</span>
$ <span class="token function">sudo</span> docker run -p 127.0.0.1:53:5353/udp <span class="token operator">&lt;</span>image<span class="token operator">></span> <span class="token operator">&lt;</span>cmd<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="Docker-网络配置"><a href="#Docker-网络配置" class="headerlink" title="Docker 网络配置"></a>Docker 网络配置</h1><p><img src="https://www.jifu.io/images/2/20190402163717.png" alt=""></p>
<p>Dokcer 通过使用 Linux 桥接提供容器之间的通信，docker0 桥接接口的目的就是方便 Docker 管理。当 Docker daemon 启动时需要做以下操作：</p>
<ul>
<li><p>creates the docker0 bridge if not present # 如果 docker0 不存在则创建</p>
</li>
<li><p>searches for an IP address range which doesn’t overlap with an existing route # 搜索一个与当前路由不冲突的 ip 段</p>
</li>
<li><p>picks an IP in the selected range # 在确定的范围中选择 ip</p>
</li>
<li><p>assigns this IP to the docker0 bridge # 绑定 ip 到 docker0</p>
</li>
</ul>
<h2 id="Docker-四种网络模式"><a href="#Docker-四种网络模式" class="headerlink" title="Docker 四种网络模式"></a>Docker 四种网络模式</h2><p>四种网络模式摘自<a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice" target="_blank" rel="noopener">Docker 网络详解及 pipework 源码解读与实践</a></p>
<p>docker run 创建 Docker 容器时，可以用 –net 选项指定容器的网络模式，Docker 有以下 4 种网络模式：</p>
<ul>
<li>host 模式，使用 –net=host 指定。</li>
<li>container 模式，使用 –net=container:NAME_or_ID 指定。</li>
<li>none 模式，使用 –net=none 指定。</li>
<li>bridge 模式，使用 –net=bridge 指定，默认设置。</li>
<li>host 模式</li>
</ul>
<p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</p>
<p>例如，我们在 10.10.101.105/24 的机器上用 host 模式启动一个含有 web 应用的 Docker 容器，监听 tcp 80 端口。当我们在容器中执行任何类似 ifconfig 命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用 10.10.101.105:80 即可，不用任何 NAT 转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<h3 id="container-模式"><a href="#container-模式" class="headerlink" title="container 模式"></a>container 模式</h3><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<h3 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h3><p>这个模式和前两个不同。在这种模式下，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p>
<h3 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h3><p><img src="https://www.jifu.io/images/2/20190402163954.png" alt=""></p>
<p>bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network Namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。当 Docker server 启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配 IP 了，Docker 会从 RFC1918 所定义的私有 IP 网段中，选择一个和宿主机不同的IP地址和子网分配给 docker0，连接到 docker0 的容器就从这个子网中选择一个未占用的 IP 使用。如一般 Docker 会使用 172.17.0.0/16 这个网段，并将 172.17.42.1/16 分配给 docker0 网桥（在主机上使用 ifconfig 命令是可以看到 docker0 的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）</p>
<h2 id="列出当前主机网桥"><a href="#列出当前主机网桥" class="headerlink" title="列出当前主机网桥"></a>列出当前主机网桥</h2><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> brctl show  <span class="token comment" spellcheck="true"># brctl 工具依赖 bridge-utils 软件包</span>
bridge name bridge <span class="token function">id</span> STP enabled interfaces
docker0 8000.000000000000 no
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="查看当前-docker0-ip"><a href="#查看当前-docker0-ip" class="headerlink" title="查看当前 docker0 ip"></a>查看当前 docker0 ip</h2><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">ifconfig</span> docker0
docker0 Link encap:Ethernet HWaddr xx:xx:xx:xx:xx:xx
inet addr:172.17.42.1 Bcast:0.0.0.0 Mask:255.255.0.0
在容器运行时，每个容器都会分配一个特定的虚拟机口并桥接到 docker0。每个容器都会配置同 docker0 ip 相同网段的专用 ip 地址，docker0 的 IP 地址被用于所有容器的默认网关。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="运行一个容器"><a href="#运行一个容器" class="headerlink" title="运行一个容器"></a>运行一个容器</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -t -i -d ubuntu /bin/bash
52f811c5d3d69edddefc75aff5a4525fc8ba8bcfa1818132f9dc7d4f7c7e78b4
$ <span class="token function">sudo</span> brctl show
bridge name bridge <span class="token function">id</span> STP enabled interfaces
docker0 8000.fef213db5a66 no vethQCDY1N
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上, docker0 扮演着 52f811c5d3d6 container 这个容器的虚拟接口 vethQCDY1N interface 桥接的角色。</p>
<h3 id="使用特定范围的-IP"><a href="#使用特定范围的-IP" class="headerlink" title="使用特定范围的 IP"></a>使用特定范围的 IP</h3><p>Docker 会尝试寻找没有被主机使用的 ip 段，尽管它适用于大多数情况下，但是它不是万能的，有时候我们还是需要对 ip 进一步规划。Docker 允许你管理 docker0 桥接或者通过 -b 选项自定义桥接网卡，需要安装 bridge-utils 软件包。</p>
<p>基本步骤如下：</p>
<ul>
<li>ensure Docker is stopped # 确保 docker 的进程是停止的</li>
<li>create your own bridge (bridge0 for example) # 创建自定义网桥</li>
<li>assign a specific IP to this bridge # 给网桥分配特定的 ip</li>
<li>start Docker with the -b=bridge0 parameter # 以 -b 的方式指定网桥</li>
</ul>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Stopping Docker and removing docker0</span>

$ <span class="token function">sudo</span> <span class="token function">service</span> docker stop
$ <span class="token function">sudo</span> ip <span class="token function">link</span> <span class="token keyword">set</span> dev docker0 down
$ <span class="token function">sudo</span> brctl delbr docker0

<span class="token comment" spellcheck="true"># Create our own bridge</span>

$ <span class="token function">sudo</span> brctl addbr bridge0
$ <span class="token function">sudo</span> ip addr add 192.168.5.1/24 dev bridge0
$ <span class="token function">sudo</span> ip <span class="token function">link</span> <span class="token keyword">set</span> dev bridge0 up

<span class="token comment" spellcheck="true"># Confirming that our bridge is up and running</span>

$ ip addr show bridge0
4: bridge0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST<span class="token operator">></span> mtu 1500 qdisc noop state UP group default
    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff
    inet 192.168.5.1/24 scope global bridge0
       valid_lft forever preferred_lft forever

<span class="token comment" spellcheck="true"># Tell Docker about it and restart (on Ubuntu)</span>

$ <span class="token keyword">echo</span> <span class="token string">'DOCKER_OPTS="-b=bridge0"'</span> <span class="token operator">>></span> /etc/default/docker
$ <span class="token function">sudo</span> <span class="token function">service</span> docker start
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参考文档: <a href="https://docs.docker.com/articles/networking/" target="_blank" rel="noopener">Network Configuration</a></p>
<h2 id="不同主机间容器通信"><a href="#不同主机间容器通信" class="headerlink" title="不同主机间容器通信"></a>不同主机间容器通信</h2><h3 id="不同容器之间的通信可以借助于-pipework-这个工具："><a href="#不同容器之间的通信可以借助于-pipework-这个工具：" class="headerlink" title="不同容器之间的通信可以借助于 pipework 这个工具："></a>不同容器之间的通信可以借助于 pipework 这个工具：</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/jpetazzo/pipework.git
$ <span class="token function">sudo</span> <span class="token function">cp</span> -rp pipework/pipework /usr/local/bin/
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="安装相应依赖软件"><a href="#安装相应依赖软件" class="headerlink" title="安装相应依赖软件"></a>安装相应依赖软件</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> iputils-arping bridge-utils -y
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="桥接网络"><a href="#桥接网络" class="headerlink" title="桥接网络"></a>桥接网络</h3><p>桥接网络可以参考<a href="https://github.com/opskumu/Day/blob/master/tips/tips.md" target="_blank" rel="noopener">日常问题处理 Tips</a>关于桥接的配置说明，这里不再赘述。</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># brctl show</span>
bridge name     bridge <span class="token function">id</span>               STP enabled     interfaces
br0             8000.000c291412cd       no              eth0
docker0         8000.56847afe9799       no              vetheb48029
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以删除 docker0，直接把 docker 的桥接指定为 br0。也可以保留使用默认的配置，这样单主机容器之间的通信可以通过 docker0，而跨主机不同容器之间通过 pipework 新建 docker 容器的网卡桥接到 br0，这样跨主机容器之间就可以通信了。</p>
<ul>
<li>ubuntu</li>
</ul>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">service</span> docker stop
$ <span class="token function">sudo</span> ip <span class="token function">link</span> <span class="token keyword">set</span> dev docker0 down
$ <span class="token function">sudo</span> brctl delbr docker0
$ <span class="token keyword">echo</span> <span class="token string">'DOCKER_OPTS="-b=br0"'</span> <span class="token operator">>></span> /etc/default/docker
$ <span class="token function">sudo</span> <span class="token function">service</span> docker start
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>CentOS 7/RHEL 7</li>
</ul>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl stop docker
$ <span class="token function">sudo</span> ip <span class="token function">link</span> <span class="token keyword">set</span> dev docker0 down
$ <span class="token function">sudo</span> brctl delbr docker0
$ <span class="token function">cat</span> /etc/sysconfig/docker <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'OPTIONS='</span>
OPTIONS<span class="token operator">=</span>--selinux-enabled -b<span class="token operator">=</span>br0 -H fd://
$ <span class="token function">sudo</span> systemctl start docker
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>pipework</p>
<p><img src="https://www.jifu.io/images/2/20190402164344.png" alt=""></p>
<p>不同容器之间的通信可以借助于 pipework 这个工具给 docker 容器新建虚拟网卡并绑定 IP 桥接到 br0</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/jpetazzo/pipework.git
$ <span class="token function">sudo</span> <span class="token function">cp</span> -rp pipework/pipework /usr/local/bin/
$ pipework
Syntax:
pipework <span class="token operator">&lt;</span>hostinterface<span class="token operator">></span> <span class="token punctuation">[</span>-i containerinterface<span class="token punctuation">]</span> <span class="token operator">&lt;</span>guest<span class="token operator">></span> <span class="token operator">&lt;</span>ipaddr<span class="token operator">></span>/<span class="token operator">&lt;</span>subnet<span class="token operator">></span><span class="token punctuation">[</span>@default_gateway<span class="token punctuation">]</span> <span class="token punctuation">[</span>macaddr<span class="token punctuation">]</span><span class="token punctuation">[</span>@vlan<span class="token punctuation">]</span>
pipework <span class="token operator">&lt;</span>hostinterface<span class="token operator">></span> <span class="token punctuation">[</span>-i containerinterface<span class="token punctuation">]</span> <span class="token operator">&lt;</span>guest<span class="token operator">></span> dhcp <span class="token punctuation">[</span>macaddr<span class="token punctuation">]</span><span class="token punctuation">[</span>@vlan<span class="token punctuation">]</span>
pipework --wait <span class="token punctuation">[</span>-i containerinterface<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果删除了默认的 docker0 桥接，把 docker 默认桥接指定到了 br0，则最好在创建容器的时候加上 <code>--net=none</code>，防止自动分配的 IP 在局域网中有冲突。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run --rm -ti --net<span class="token operator">=</span>none ubuntu:14.04 /bin/bash
root@a46657528059:/<span class="token comment" spellcheck="true">#</span>
$                  <span class="token comment" spellcheck="true"># Ctrl-P + Ctrl-Q 回到宿主机 shell，容器 detach 状态</span>
$ <span class="token function">sudo</span> docker  <span class="token function">ps</span>
CONTAINER ID    IMAGE          COMMAND       CREATED         STATUS          PORTS      NAMES
a46657528059    ubuntu:14.04   <span class="token string">"/bin/bash"</span>   4 minutes ago   Up 4 minutes               hungry_lalande
$ <span class="token function">sudo</span> pipework br0 -i eth0 a46657528059 192.168.115.10/24@192.168.115.2
<span class="token comment" spellcheck="true"># 默认不指定网卡设备名，则默认添加为 eth1</span>
<span class="token comment" spellcheck="true"># 另外 pipework 不能添加静态路由，如果有需求则可以在 run 的时候加上 --privileged=true 权限在容器中手动添加，</span>
<span class="token comment" spellcheck="true"># 但这种安全性有缺陷，可以通过 ip netns 操作</span>
$ <span class="token function">sudo</span> docker attach a46657528059
root@a46657528059:/<span class="token comment" spellcheck="true"># ifconfig eth0</span>
eth0      Link encap:Ethernet  HWaddr 86:b6:6b:e8:2e:4d
          inet addr:192.168.115.10  Bcast:0.0.0.0  Mask:255.255.255.0
          inet6 addr: fe80::84b6:6bff:fee8:2e4d/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:9 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:648 <span class="token punctuation">(</span>648.0 B<span class="token punctuation">)</span>  TX bytes:690 <span class="token punctuation">(</span>690.0 B<span class="token punctuation">)</span>

root@a46657528059:/<span class="token comment" spellcheck="true"># route -n</span>
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.115.2   0.0.0.0         UG    0      0        0 eth0
192.168.115.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用<code>ip netns</code>添加静态路由，避免创建容器使用<code>--privileged=true</code>选项造成一些不必要的安全问题：</p>
<pre><code>$ docker inspect --format=&quot;{{ .State.Pid }}&quot; a46657528059 # 获取指定容器 pid
6350
$ sudo ln -s /proc/6350/ns/net /var/run/netns/6350
$ sudo ip netns exec 6350 ip route add 192.168.0.0/16 dev eth0 via 192.168.115.2
$ sudo ip netns exec 6350 ip route    # 添加成功
192.168.0.0/16 via 192.168.115.2 dev eth0
... ...
</code></pre><p>在其它宿主机进行相应的配置，新建容器并使用 pipework 添加虚拟网卡桥接到 br0，测试通信情况即可。</p>
<p>另外，pipework 可以创建容器的 vlan 网络，这里不作过多的介绍了，官方文档已经写的很清楚了，可以查看以下两篇文章：</p>
<p><a href="https://github.com/jpetazzo/pipework" target="_blank" rel="noopener">Pipework 官方文档</a><br><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice" target="_blank" rel="noopener">Docker 网络详解及 pipework 源码解读与实践</a></p>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>Docker 可以通过 Dockerfile 的内容来自动构建镜像。Dockerfile 是一个包含创建镜像所有命令的文本文件，通过<code>docker build</code>命令可以根据 Dockerfile 的内容构建镜像，在介绍如何构建之前先介绍下 Dockerfile 的基本语法结构。</p>
<p>Dockerfile 有以下指令选项:</p>
<ul>
<li>FROM</li>
<li>MAINTAINER</li>
<li>RUN</li>
<li>CMD</li>
<li>EXPOSE</li>
<li>ENV</li>
<li>ADD</li>
<li>COPY</li>
<li>ENTRYPOINT</li>
<li>VOLUME</li>
<li>USER</li>
<li>WORKDIR</li>
<li>ONBUILD</li>
</ul>
<h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p>用法:</p>
<pre class="line-numbers language-bash"><code class="language-bash">FROM <span class="token operator">&lt;</span>image<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者</p>
<pre class="line-numbers language-bash"><code class="language-bash">FROM <span class="token operator">&lt;</span>image<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>FROM</code> 指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来。</li>
<li><code>FROM</code> 必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从 FROM 语句开始。</li>
<li><code>FROM 可以在一个 Dockerfile 中出现多次，如果有需求在一个 Dockerfile 中创建多个镜像。
如果 FROM 语句没有指定镜像标签，则默认使用</code>latest`标签。</li>
</ul>
<h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><p>用法:</p>
<pre class="line-numbers language-bash"><code class="language-bash">MAINTAINER <span class="token operator">&lt;</span>name<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>指定创建镜像的用户</p>
<h3 id="RUN-有两种使用方式"><a href="#RUN-有两种使用方式" class="headerlink" title="RUN 有两种使用方式"></a>RUN 有两种使用方式</h3><ul>
<li>RUN (the command is run in a shell - /bin/sh -c - shell form)</li>
<li>RUN [“executable”, “param1”, “param2”] (exec form)</li>
</ul>
<p>每条<code>RUN</code>指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的<code>RUN</code>都在之前 RUN 提交后的镜像为基础，镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的版本控制。</p>
<p><code>exec</code>方式会被解析为一个 JSON 数组，所以必须使用双引号而不是单引号。exec 方式不会调用一个命令 shell，所以也就不会继承相应的变量，如：</p>
<pre class="line-numbers language-bash"><code class="language-bash">RUN <span class="token punctuation">[</span> <span class="token string">"echo"</span>, <span class="token string">"<span class="token variable">$HOME</span>"</span> <span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这种方式是不会达到输出 HOME 变量的，正确的方式应该是这样的</p>
<pre class="line-numbers language-bash"><code class="language-bash">RUN <span class="token punctuation">[</span> <span class="token string">"sh"</span>, <span class="token string">"-c"</span>, <span class="token string">"echo"</span>, <span class="token string">"<span class="token variable">$HOME</span>"</span> <span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>RUN</code>产生的缓存在下一次构建的时候是不会失效的，会被重用，可以使用<code>--no-cache</code>选项，即 <code>docker build --no-cache</code>，如此便不会缓存。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD 有三种使用方式:</p>
<ul>
<li>CMD [“executable”,”param1”,”param2”] (exec form, this is the preferred form, 优先选择)</li>
<li>CMD [“param1”,”param2”] (as default parameters to ENTRYPOINT)</li>
<li>CMD command param1 param2 (shell form)</li>
</ul>
<p>CMD 指定在 Dockerfile 中只能使用一次，如果有多个，则只有最后一个会生效。</p>
<p>CMD 的目的是为了在启动容器时提供一个默认的命令执行选项。如果用户启动容器时指定了运行的命令，则会覆盖掉 CMD 指定的命令。</p>
<blockquote>
<p>CMD 会在启动容器的时候执行，build 时不执行，而 RUN 只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与 RUN 无关了，这个初学者容易弄混这个概念，这里简单注解一下。</p>
</blockquote>
<h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>EXPOSE <port> [<port>…]<br>告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用 -p 或者 -P 选项生效。</port></port></p>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><pre class="line-numbers language-bash"><code class="language-bash">ENV <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span>       <span class="token comment" spellcheck="true"># 只能设置一个变量</span>
ENV <span class="token operator">&lt;</span>key<span class="token operator">>=</span><span class="token operator">&lt;</span>value<span class="token operator">></span> <span class="token punctuation">..</span>.   <span class="token comment" spellcheck="true"># 允许一次设置多个变量</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>指定一个环节变量，会被后续 RUN 指令使用，并在容器运行时保留。</p>
<p>例子:</p>
<pre class="line-numbers language-bash"><code class="language-bash">ENV myName<span class="token operator">=</span><span class="token string">"John Doe"</span> myDog<span class="token operator">=</span>Rex\ The\ Dog \
    myCat<span class="token operator">=</span>fluffy
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>等同于</p>
<pre class="line-numbers language-bash"><code class="language-bash">ENV myName John Doe
ENV myDog Rex The Dog
ENV myCat fluffy
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><pre class="line-numbers language-bash"><code class="language-bash">ADD <span class="token operator">&lt;</span>src<span class="token operator">></span><span class="token punctuation">..</span>. <span class="token operator">&lt;</span>dest<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>ADD</code>复制本地主机文件、目录或者远程文件 URLS 从 <src> 并且添加到容器指定路径中 <dest>。</dest></src></p>
<p><src> 支持通过 GO 的正则模糊匹配，具体规则可参见 Go filepath.Match</src></p>
<pre class="line-numbers language-bash"><code class="language-bash">ADD hom* /mydir/        <span class="token comment" spellcheck="true"># adds all files starting with "hom"</span>
ADD hom?.txt /mydir/    <span class="token comment" spellcheck="true"># ? is replaced with any single character</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><dest> 路径必须是绝对路径，如果 <dest> 不存在，会自动创建对应目录</dest></dest></li>
<li><src> 路径必须是 Dockerfile 所在路径的相对路径</src></li>
<li><src> 如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制</src></li>
</ul>
<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><pre class="line-numbers language-bash"><code class="language-bash">COPY <span class="token operator">&lt;</span>src<span class="token operator">></span><span class="token punctuation">..</span>. <span class="token operator">&lt;</span>dest<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>COPY</code>复制新文件或者目录从 <src> 添加到容器指定路径中 <dest>。用法同<code>ADD</code>，唯一的不同是不能指定远程文件 URLS。</dest></src></p>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><ul>
<li>ENTRYPOINT [“executable”, “param1”, “param2”] (the preferred exec form，优先选择)</li>
<li>ENTRYPOINT command param1 param2 (shell form)</li>
</ul>
<p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而<code>CMD</code>是可以被覆盖的。如果需要覆盖，则可以使用<code>docker run --entrypoint</code>选项。</p>
<p>每个 Dockerfile 中只能有一个<code>ENTRYPOINT</code>，当指定多个时，只有最后一个生效。</p>
<p>Exec form ENTRYPOINT 例子</p>
<p>通过<code>ENTRYPOINT</code>使用 exec form 方式设置稳定的默认命令和选项，而使用 CMD 添加默认之外经常被改动的选项。</p>
<pre class="line-numbers language-bash"><code class="language-bash">FROM ubuntu
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"top"</span>, <span class="token string">"-b"</span><span class="token punctuation">]</span>
CMD <span class="token punctuation">[</span><span class="token string">"-c"</span><span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>通过 Dockerfile 使用<code>ENTRYPOINT</code>展示前台运行 Apache 服务</p>
<pre class="line-numbers language-bash"><code class="language-bash">FROM debian:stable
RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y --force-yes apache2
EXPOSE 80 443
VOLUME <span class="token punctuation">[</span><span class="token string">"/var/www"</span>, <span class="token string">"/var/log/apache2"</span>, <span class="token string">"/etc/apache2"</span><span class="token punctuation">]</span>
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"/usr/sbin/apache2ctl"</span>, <span class="token string">"-D"</span>, <span class="token string">"FOREGROUND"</span><span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Shell-form-ENTRYPOINT-例子"><a href="#Shell-form-ENTRYPOINT-例子" class="headerlink" title="Shell form ENTRYPOINT 例子"></a>Shell form ENTRYPOINT 例子</h3><p>这种方式会在<code>/bin/sh -c</code>中执行，会忽略任何<code>CMD</code>或者<code>docker run</code>命令行选项，为了确保<code>docker stop</code>能够停止长时间运行<code>ENTRYPOINT</code>的容器，确保执行的时候使用<code>exec</code>选项。</p>
<pre class="line-numbers language-bash"><code class="language-bash">FROM ubuntu
ENTRYPOINT <span class="token function">exec</span> <span class="token function">top</span> -b
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果在<code>ENTRYPOINT</code>忘记使用<code>exec</code>选项，则可以使用<code>CMD</code>补上:</p>
<pre class="line-numbers language-bash"><code class="language-bash">FROM ubuntu
ENTRYPOINT <span class="token function">top</span> -b
CMD --ignored-param1 <span class="token comment" spellcheck="true"># --ignored-param2 ... --ignored-param3 ... 依此类推</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><pre class="line-numbers language-bash"><code class="language-bash">VOLUME <span class="token punctuation">[</span><span class="token string">"/data"</span><span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>创建一个可以从本地主机或其他容器挂载的挂载点，后续具体介绍。</p>
<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><pre class="line-numbers language-bash"><code class="language-bash">USER daemon
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>指定运行容器时的用户名或UID，后续的<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>也会使用指定用户。</p>
<h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><pre class="line-numbers language-bash"><code class="language-bash">WORKDIR /path/to/workdir
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>为后续的<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>指令配置工作目录。可以使用多个<code>WORKDIR</code>指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p>
<pre class="line-numbers language-bash"><code class="language-bash">WORKDIR /a
WORKDIR b
WORKDIR c
RUN <span class="token function">pwd</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终路径是<code>/a/b/c</code>。</p>
<p><code>WORKDIR</code>指令可以在<code>ENV</code>设置变量之后调用环境变量:</p>
<pre class="line-numbers language-bash"><code class="language-bash">ENV DIRPATH /path
WORKDIR <span class="token variable">$DIRPATH</span>/<span class="token variable">$DIRNAME</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>最终路径则为 /path/$DIRNAME。</p>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><pre class="line-numbers language-bash"><code class="language-bash">ONBUILD <span class="token punctuation">[</span>INSTRUCTION<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p>
<p>例如，Dockerfile 使用如下的内容创建了镜像 image-A：</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
ONBUILD ADD <span class="token keyword">.</span> /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src
<span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果基于 image-A 创建新的镜像时，新的 Dockerfile 中使用 FROM image-A 指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Automatically run the following</span>
ADD <span class="token keyword">.</span> /app/src
RUN /usr/local/bin/python-build --dir /app/src
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>使用<code>ONBUILD</code>指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild。</p>
<h2 id="Dockerfile-Examples"><a href="#Dockerfile-Examples" class="headerlink" title="Dockerfile Examples"></a>Dockerfile Examples</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Nginx</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true"># VERSION               0.0.1</span>

FROM      ubuntu
MAINTAINER Victor Vieux <span class="token operator">&lt;</span>victor@docker.com<span class="token operator">></span>

RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y inotify-tools nginx apache2 openssh-server

<span class="token comment" spellcheck="true"># Firefox over VNC</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true"># VERSION               0.3</span>

FROM ubuntu

<span class="token comment" spellcheck="true"># Install vnc, xvfb in order to create a 'fake' display and firefox</span>
RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y x11vnc xvfb firefox
RUN <span class="token function">mkdir</span> ~/.vnc
<span class="token comment" spellcheck="true"># Setup a password</span>
RUN x11vnc -storepasswd 1234 ~/.vnc/passwd
<span class="token comment" spellcheck="true"># Autostart firefox (might not be the best way, but it does the trick)</span>
RUN <span class="token function">bash</span> -c <span class="token string">'echo "firefox" >> /.bashrc'</span>

EXPOSE 5900
CMD    <span class="token punctuation">[</span><span class="token string">"x11vnc"</span>, <span class="token string">"-forever"</span>, <span class="token string">"-usepw"</span>, <span class="token string">"-create"</span><span class="token punctuation">]</span>

<span class="token comment" spellcheck="true"># Multiple images example</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true"># VERSION               0.1</span>

FROM ubuntu
RUN <span class="token keyword">echo</span> foo <span class="token operator">></span> bar
<span class="token comment" spellcheck="true"># Will output something like ===> 907ad6c2736f</span>

FROM ubuntu
RUN <span class="token keyword">echo</span> moo <span class="token operator">></span> oink
<span class="token comment" spellcheck="true"># Will output something like ===> 695d7793cbe4</span>

<span class="token comment" spellcheck="true"># You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span>
<span class="token comment" spellcheck="true"># /oink.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><pre class="line-numbers language-bash"><code class="language-bash">$ docker build --help

Usage: docker build <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> PATH <span class="token operator">|</span> URL <span class="token operator">|</span> -

Build a new image from the <span class="token function">source</span> code at PATH

  --force-rm<span class="token operator">=</span>false     Always remove intermediate containers, even after unsuccessful builds <span class="token comment" spellcheck="true"># 移除过渡容器，即使构建失败</span>
  --no-cache<span class="token operator">=</span>false     Do not use cache when building the image                              <span class="token comment" spellcheck="true"># 不实用 cache</span>
  -q, --quiet<span class="token operator">=</span>false    Suppress the verbose output generated by the containers
  --rm<span class="token operator">=</span>true            Remove intermediate containers after a successful build               <span class="token comment" spellcheck="true"># 构建成功后移除过渡层容器</span>
  -t, --tag<span class="token operator">=</span><span class="token string">""</span>         Repository name <span class="token punctuation">(</span>and optionally a tag<span class="token punctuation">)</span> to be applied to the resulting image <span class="token keyword">in</span> <span class="token keyword">case</span> of success
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参考文档:<a href="https://docs.docker.com/reference/builder/" target="_blank" rel="noopener">Dockerfile Reference</a></p>
<h2 id="dockerfile-最佳实践"><a href="#dockerfile-最佳实践" class="headerlink" title="dockerfile 最佳实践"></a>dockerfile 最佳实践</h2><h3 id="使用-dockerignore文件"><a href="#使用-dockerignore文件" class="headerlink" title="使用.dockerignore文件"></a>使用<code>.dockerignore</code>文件</h3><p>为了在<code>docker build</code>过程中更快上传和更加高效，应该使用一个<code>.dockerignore</code>文件用来排除构建镜像时不需要的文件或目录。例如,除非<code>.git</code>在构建过程中需要用到，否则你应该将它添加到<code>.dockerignore</code>文件中，这样可以节省很多时间。</p>
<h3 id="避免安装不必要的软件包"><a href="#避免安装不必要的软件包" class="headerlink" title="避免安装不必要的软件包"></a>避免安装不必要的软件包</h3><p>为了降低复杂性、依赖性、文件大小以及构建时间，应该避免安装额外的或不必要的包。例如，不需要在一个数据库镜像中安装一个文本编辑器。</p>
<h3 id="每个容器都跑一个进程"><a href="#每个容器都跑一个进程" class="headerlink" title="每个容器都跑一个进程"></a>每个容器都跑一个进程</h3><p>在大多数情况下，一个容器应该只单独跑一个程序。解耦应用到多个容器使其更容易横向扩展和重用。如果一个服务依赖另外一个服务，可以参考 Linking Containers Together。</p>
<h3 id="最小化层"><a href="#最小化层" class="headerlink" title="最小化层"></a>最小化层</h3><p>我们知道每执行一个指令，都会有一次镜像的提交，镜像是分层的结构，对于<code>Dockerfile</code>，应该找到可读性和最小化层之间的平衡。</p>
<h3 id="多行参数排序"><a href="#多行参数排序" class="headerlink" title="多行参数排序"></a>多行参数排序</h3><p>如果可能，通过字母顺序来排序，这样可以避免安装包的重复并且更容易更新列表，另外可读性也会更强，添加一个空行使用 \ 换行:</p>
<pre class="line-numbers language-bash"><code class="language-bash">RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y \
  bzr \
  cvs \
  <span class="token function">git</span> \
  mercurial \
  subversion
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="创建缓存"><a href="#创建缓存" class="headerlink" title="创建缓存"></a>创建缓存</h3><p>镜像构建过程中会按照<code>Dockerfile</code>的顺序依次执行，每执行一次指令 Docker 会寻找是否有存在的镜像缓存可复用，如果没有则创建新的镜像。如果不想使用缓存，则可以在<code>docker build</code>时添加<code>--no-cache=true</code>选项。</p>
<p>从基础镜像开始就已经在缓存中了，下一个指令会对比所有的子镜像寻找是否执行相同的指令，如果没有则缓存失效。在大多数情况下只对比<code>Dockerfile</code>指令和子镜像就足够了。<code>ADD</code>和<code>COPY</code>指令除外，执行<code>ADD</code>和<code>COPY</code>时存放到镜像的文件也是需要检查的，完成一个文件的校验之后再利用这个校验在缓存中查找，如果检测的文件改变则缓存失效。<code>RUN apt-get -y update</code>命令只检查命令是否匹配，如果匹配就不会再执行更新了。</p>
<blockquote>
<p>为了有效地利用缓存，你需要保持你的 Dockerfile 一致，并且尽量在末尾修改。</p>
</blockquote>
<h3 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h3><ul>
<li><code>FROM</code>: 只要可能就使用官方镜像库作为基础镜像</li>
<li><code>RUN</code>: 为保持可读性、方便理解、可维护性，把长或者复杂的 RUN 语句使用 \ 分隔符分成多行<ul>
<li>不建议<code>RUN apt-get update</code>独立成行，否则如果后续包有更新，那么也不会再执行更新</li>
<li>避免使用<code>RUN apt-get upgrade</code>或者<code>dist-upgrade</code>，很多必要的包在一个非 privileged 权限的容器里是无法升级的。如果知道某个包更新，使用<code>apt-get install -y xxx</code></li>
<li>标准写法<ul>
<li><code>RUN apt-get update &amp;&amp; apt-get install -y package-bar package-foo</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例子:</p>
<pre><code>RUN apt-get update &amp;&amp; apt-get install -y \
    aufs-tools \
    automake \
    btrfs-tools \
    build-essential \
    curl \
    dpkg-sig \
    git \
    iptables \
    libapparmor-dev \
    libcap-dev \
    libsqlite3-dev \
    lxc=1.0* \
    mercurial \
    parallel \
    reprepro \
    ruby1.9.1 \
    ruby1.9.1-dev \
    s3cmd=1.1.0*
</code></pre><p>CMD: 推荐使用<code>CMD [“executable”, “param1”, “param2”…]</code>这种格式，<code>CMD [“param”, “param”]</code>则配合<code>ENTRYPOINT</code>使用<br><code>EXPOSE</code>: Dockerfile 指定要公开的端口，使用 docker run 时指定映射到宿主机的端口即可<br>ENV: 为了使新的软件更容易运行，可以使用 ENV 更新 PATH 变量。如<code>ENV PATH /usr/local/nginx/bin:$PATH</code>确保<code>CMD [&quot;nginx&quot;]</code>即可运行<br>ENV 也可以这样定义变量：</p>
<pre class="line-numbers language-bash"><code class="language-bash">ENV PG_MAJOR 9.3
ENV PG_VERSION 9.3.4
RUN curl -SL http://example.com/postgres-<span class="token variable">$PG_VERSION</span>.tar.xz <span class="token operator">|</span> <span class="token function">tar</span> -xJC /usr/src/postgress <span class="token operator">&amp;&amp;</span> …
ENV PATH /usr/local/postgres-<span class="token variable">$PG_MAJOR</span>/bin:<span class="token variable">$PATH</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>ADD</code> or <code>COPY</code>: <code>ADD</code>比<code>COPY</code>多一些特性「tar 文件自动解包和支持远程 URL」，不推荐添加远程 URL</p>
</blockquote>
<p>如不推荐这种方式:</p>
<pre><code>ADD http://example.com/big.tar.xz /usr/src/things/
RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things
RUN make -C /usr/src/things all
</code></pre><p>推荐使用 curl 或者 wget 替换，使用如下方式:</p>
<pre class="line-numbers language-bash"><code class="language-bash">RUN <span class="token function">mkdir</span> -p /usr/src/things \
    <span class="token operator">&amp;&amp;</span> curl -SL http://example.com/big.tar.gz \
    <span class="token operator">|</span> <span class="token function">tar</span> -xJC /usr/src/things \
    <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> -C /usr/src/things all
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果不需要添加 tar 文件，推荐使用<code>COPY</code>。</p>
<p>参考文档:</p>
<ul>
<li><a href="https://docs.docker.com/articles/dockerfile_best-practices/" target="_blank" rel="noopener">Best practices for writing Dockerfiles</a></li>
<li><a href="http://dockerone.com/article/131" target="_blank" rel="noopener">Dockerfile最佳实践（一）</a></li>
<li><a href="http://dockerone.com/article/131" target="_blank" rel="noopener">Dockerfile最佳实践（二）</a></li>
</ul>
<h1 id="容器数据管理"><a href="#容器数据管理" class="headerlink" title="容器数据管理"></a>容器数据管理</h1><p>docker管理数据的方式有两种：</p>
<ul>
<li>数据卷</li>
<li>数据卷容器</li>
</ul>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个或多个容器专门指定绕过<code>Union File System</code>的目录，为持续性或共享数据提供一些有用的功能：</p>
<ul>
<li>数据卷可以在容器间共享和重用</li>
<li>数据卷数据改变是直接修改的</li>
<li>数据卷数据改变不会被包括在容器中</li>
<li>数据卷是持续性的，直到没有容器使用它们</li>
</ul>
<p>添加一个数据卷</p>
<p>你可以使用 -v 选项添加一个数据卷，或者可以使用多次 -v 选项为一个 docker 容器运行挂载多个数据卷。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run --name data -v /data -t -i ubuntu:14.04 /bin/bash
<span class="token comment" spellcheck="true"># 创建数据卷绑定到到新建容器，新建容器中会创建 /data 数据卷</span>
bash-4.1<span class="token comment" spellcheck="true"># ls -ld /data/</span>
drwxr-xr-x 2 root root 4096 Jul 23 06:59 /data/
bash-4.1<span class="token comment" spellcheck="true"># df -Th</span>
Filesystem    Type    Size  Used Avail Use% Mounted on
<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.
              ext4     91G  4.6G   82G   6% /data
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建的数据卷可以通过<code>docker inspect</code>获取宿主机对应路径</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker inspect data
<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.
    <span class="token string">"Volumes"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
        <span class="token string">"/data"</span><span class="token keyword">:</span> <span class="token string">"/var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9"</span>
    <span class="token punctuation">}</span>, <span class="token comment" spellcheck="true"># 可以看到创建的数据卷宿主机路径</span>
<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者直接指定获取</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker inspect --format<span class="token operator">=</span><span class="token string">"{{ .Volumes }}"</span> data
map<span class="token punctuation">[</span>/data: /var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>挂载宿主机目录为一个数据卷</p>
<p><code>-v</code>选项除了可以创建卷，也可以挂载当前主机的一个目录到容器中。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run --name web -v /source/:/web -t -i ubuntu:14.04 /bin/bash
bash-4.1<span class="token comment" spellcheck="true"># ls -ld /web/</span>
drwxr-xr-x 2 root root 4096 Jul 23 06:59 /web/
bash-4.1<span class="token comment" spellcheck="true"># df -Th</span>
<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.
              ext4     91G  4.6G   82G   6% /web
bash-4.1<span class="token comment" spellcheck="true"># exit</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认挂载卷是可读写的，可以在挂载时指定只读</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run --rm --name <span class="token function">test</span> -v /source/:/test:ro -t -i ubuntu:14.04 /bin/bash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="创建和挂载一个数据卷容器"><a href="#创建和挂载一个数据卷容器" class="headerlink" title="创建和挂载一个数据卷容器"></a>创建和挂载一个数据卷容器</h2><p>如果你有一些持久性的数据并且想在容器间共享，或者想用在非持久性的容器上，最好的方法是创建一个数据卷容器，然后从此容器上挂载数据。</p>
<p>创建数据卷容器</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -t -i -d -v /test --name <span class="token function">test</span> ubuntu:14.04 <span class="token keyword">echo</span> hello
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用<code>--volumes-from</code>选项在另一个容器中挂载 /test 卷。不管 test 容器是否运行，其它容器都可以挂载该容器数据卷，当然如果只是单独的数据卷是没必要运行容器的。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -t -i -d --volumes-from <span class="token function">test</span> --name test1 ubuntu:14.04 /bin/bash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>添加另一个容器</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -t -i -d --volumes-from <span class="token function">test</span> --name test2 ubuntu:14.04 /bin/bash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以继承其它挂载有 /test 卷的容器</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -t -i -d --volumes-from test1 --name test3 ubuntu:14.04 /bin/bash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://www.jifu.io/images/2/20190402170223.png" alt=""></p>
<h2 id="备份、恢复或迁移数据卷"><a href="#备份、恢复或迁移数据卷" class="headerlink" title="备份、恢复或迁移数据卷"></a>备份、恢复或迁移数据卷</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run --rm --volumes-from <span class="token function">test</span> -v <span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/backup ubuntu:14.04 <span class="token function">tar</span> cvf /backup/test.tar /test
tar: Removing leading `/' from member names
/test/
/test/b
/test/d
/test/c
/test/a
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动一个新的容器并且从<code>test</code>容器中挂载卷，然后挂载当前目录到容器中为 backup，并备份<code>test</code>卷中所有的数据为test.tar，执行完成之后删除容器<code>--rm</code>，此时备份就在当前的目录下，名为 test.tar。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span>        <span class="token comment" spellcheck="true"># 宿主机当前目录下产生了 test 卷的备份文件 test.tar</span>
test.tar
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>你可以恢复给同一个容器或者另外的容器，新建容器并解压备份文件到新的容器数据卷</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -t -i -d -v /test --name test4 ubuntu:14.04  /bin/bash
$ <span class="token function">sudo</span> docker run --rm --volumes-from test4 -v <span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/backup ubuntu:14.04 <span class="token function">tar</span> xvf /backup/test.tar -C /
<span class="token comment" spellcheck="true"># 恢复之前的文件到新建卷中，执行完后自动删除容器</span>
test/
test/b
test/d
test/c
test/a
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="删除-Volumes"><a href="#删除-Volumes" class="headerlink" title="删除 Volumes"></a>删除 Volumes</h2><p>Volume 只有在下列情况下才能被删除：</p>
<ul>
<li><code>docker rm -v</code>删除容器时添加了<code>-v</code>选项</li>
<li><code>docker run --rm</code>运行容器时添加了<code>--rm</code>选项<br>否则，会在<code>/var/lib/docker/vfs/dir</code>目录中遗留很多不明目录。</li>
</ul>
<p>参考文档：</p>
<p><a href="http://docs.docker.com/userguide/dockervolumes/#data-volumes" target="_blank" rel="noopener">Managing Data in Containers</a><br><a href="http://dockerone.com/article/128" target="_blank" rel="noopener">深入理解Docker Volume（一）</a><br><a href="http://dockerone.com/article/129" target="_blank" rel="noopener">深入理解Docker Volume（二）</a></p>
<h1 id="链接容器"><a href="#链接容器" class="headerlink" title="链接容器"></a>链接容器</h1><p>docker 允许把多个容器连接在一起，相互交互信息。docker 链接会创建一种容器父子级别的关系，其中父容器可以看到其子容器提供的信息。</p>
<h2 id="容器命名"><a href="#容器命名" class="headerlink" title="容器命名"></a>容器命名</h2><p>在创建容器时，如果不指定容器的名字，则默认会自动创建一个名字，这里推荐给容器命名：</p>
<ul>
<li>1、给容器命名方便记忆，如命名运行 web 应用的容器为 web</li>
<li>2、为 docker 容器提供一个参考，允许方便其他容器调用，如把容器 web 链接到容器 db</li>
</ul>
<p>可以通过<code>--name</code>选项给容器自定义命名：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -d -t -i --name <span class="token function">test</span> ubuntu:14.04 <span class="token function">bash</span>
$ <span class="token function">sudo</span> docker  inspect --format<span class="token operator">=</span><span class="token string">"{{ .Nmae }}"</span> <span class="token function">test</span>
/test
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注：容器名称必须唯一，即你只能命名一个叫<code>test</code>的容器。如果你想复用容器名，则必须在创建新的容器前通过<code>docker rm</code>删除旧的容器或者创建容器时添加<code>--rm</code>选项。</p>
</blockquote>
<h2 id="链接容器-1"><a href="#链接容器-1" class="headerlink" title="链接容器"></a>链接容器</h2><p>链接允许容器间安全通信，使用 –link 选项创建链接。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -d --name db training/postgres
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>基于 training/postgres 镜像创建一个名为 db 的容器，然后下面创建一个叫做 web 的容器，并且将它与 db 相互连接在一起</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -d -P --name web --link db:db training/webapp python app.py
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>--link &lt;name or id&gt;:alias</code>选项指定链接到的容器。</p>
<p>查看 web 容器的链接关系:</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker inspect -f <span class="token string">"{{ .HostConfig.Links }}"</span> web
<span class="token punctuation">[</span>/db:/web/db<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以看到 web 容器被链接到 db 容器为<code>/web/db</code>，这允许 web 容器访问 db 容器的信息。</p>
<p>容器之间的链接实际做了什么？一个链接允许一个源容器提供信息访问给一个接收容器。在本例中，web 容器作为一个接收者，允许访问源容器 db 的相关服务信息。Docker 创建了一个安全隧道而不需要对外公开任何端口给外部容器，因此不需要在创建容器的时候添加<code>-p</code>或<code>-P</code>指定对外公开的端口，这也是链接容器的最大好处，本例为 PostgreSQL 数据库。</p>
<p>Docker 主要通过以下两个方式提供连接信息给接收容器：</p>
<ul>
<li>环境变量</li>
<li>更新<code>/etc/hosts</code>文件</li>
</ul>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>当两个容器链接，Docker 会在目标容器上设置一些环境变量，以获取源容器的相关信息。</p>
<p>首先，Docker 会在每个通过<code>--link</code>选项指定别名的目标容器上设置一个<code>&lt;alias&gt;_NAME</code>环境变量。如果一个名为 web 的容器通过<code>--link db:webdb</code>被链接到一个名为 db 的数据库容器，那么 web 容器上会设置一个环境变量为<code>WEBDB_NAME=/web/webdb</code>.</p>
<p>以之前的为例，Docker 还会设置端口变量:</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run --rm --name web2 --link db:db training/webapp <span class="token function">env</span>
<span class="token keyword">.</span> <span class="token keyword">.</span> <span class="token keyword">.</span>
DB_NAME<span class="token operator">=</span>/web2/db
DB_PORT<span class="token operator">=</span>tcp://172.17.0.5:5432
DB_PORT_5432_TCP<span class="token operator">=</span>tcp://172.17.0.5:5432  <span class="token comment" spellcheck="true"># &lt;name>_PORT_&lt;port>_&lt;protocol> 协议可以是 TCP 或 UDP</span>
DB_PORT_5432_TCP_PROTO<span class="token operator">=</span>tcp
DB_PORT_5432_TCP_PORT<span class="token operator">=</span>5432
DB_PORT_5432_TCP_ADDR<span class="token operator">=</span>172.17.0.5
<span class="token keyword">.</span> <span class="token keyword">.</span> <span class="token keyword">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注：这些环境变量只设置给容器中的第一个进程，类似一些守护进程 (如 sshd ) 当他们派生 shells 时会清除这些变量</p>
</blockquote>
<p>更新<code>/etc/hosts</code>文件</p>
<p>除了环境变量，Docker 会在目标容器上添加相关主机条目到<code>/etc/hosts</code>中，上例中就是 web 容器。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run -t -i --rm --link db:db training/webapp /bin/bash
root@aed84ee21bde:/opt/webapp<span class="token comment" spellcheck="true"># cat /etc/hosts</span>
172.17.0.7  aed84ee21bde
<span class="token keyword">.</span> <span class="token keyword">.</span> <span class="token keyword">.</span>
172.17.0.5  db
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>/etc/host</code>文件在源容器被重启之后会自动更新 IP 地址，而环境变量中的 IP 地址则不会自动更新的。</p>
</blockquote>
<h1 id="构建私有库"><a href="#构建私有库" class="headerlink" title="构建私有库"></a>构建私有库</h1><p>Docker 官方提供了 docker registry 的构建方法<a href="https://github.com/docker/docker-registry" target="_blank" rel="noopener">docker-registry</a></p>
<h2 id="快速构建"><a href="#快速构建" class="headerlink" title="快速构建"></a>快速构建</h2><p>快速构建 docker registry 通过以下两步:</p>
<ul>
<li>安装 docker</li>
<li>运行 registry: docker run -p 5000:5000 registry</li>
</ul>
<p>这种方法通过 Docker hub 使用官方镜像 <a href="https://registry.hub.docker.com/_/registry/" target="_blank" rel="noopener">official image from the Docker hub</a></p>
<h2 id="不使用容器构建-registry"><a href="#不使用容器构建-registry" class="headerlink" title="不使用容器构建 registry"></a>不使用容器构建 registry</h2><p>安装必要的软件</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> build-essential python-dev libevent-dev python-pip liblzma-dev
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>配置 docker-registry</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> pip <span class="token function">install</span> docker-registry
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者 使用 github clone 手动安装</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/dotcloud/docker-registry.git
$ <span class="token function">cd</span> docker-registry/
$ <span class="token function">cp</span> config/config_sample.yml config/config.yml
$ <span class="token function">mkdir</span> /data/registry -p
$ pip <span class="token function">install</span> <span class="token keyword">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker-registry
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="高级启动方式-「不推荐」"><a href="#高级启动方式-「不推荐」" class="headerlink" title="高级启动方式 「不推荐」"></a>高级启动方式 「不推荐」</h3><p>使用<code>gunicorn</code>控制:</p>
<pre class="line-numbers language-bash"><code class="language-bash">gunicorn -c contrib/gunicorn_config.py docker_registry.wsgi:application
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者对外监听开放</p>
<pre class="line-numbers language-bash"><code class="language-bash">gunicorn --access-logfile - --error-logfile - -k gevent -b 0.0.0.0:5000 -w 4 --max-requests 100 docker_registry.wsgi:application
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="提交指定容器到私有库"><a href="#提交指定容器到私有库" class="headerlink" title="提交指定容器到私有库"></a>提交指定容器到私有库</h2><pre class="line-numbers language-bash"><code class="language-bash">$ docker tag ubuntu:12.04 私有库IP:5000/ubuntu:12.04
$ docker push 私有库IP:5000/ubuntu
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>更多的配置选项推荐阅读官方文档:</p>
<ul>
<li><a href="https://github.com/docker/docker-registry/blob/master/README.md" target="_blank" rel="noopener">Docker-Registry README</a></li>
<li><a href="https://github.com/docker/docker-registry/blob/master/ADVANCED.md" target="_blank" rel="noopener">Docker-Registry advanced use</a></li>
</ul>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="/posts/3142539384/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    HR常用的招聘邮件模板
                
            </div>
        </a>
    
    
        <a href="/posts/1098789015/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">Xcode开发中Build与version区别/build自增设置/build随时间变化？</div>
        </a>
    
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     

<head><meta name="generator" content="Hexo 3.9.0">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<link rel="stylesheet" href="/css/prism-duotone-light.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
<body>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: '8kLhebBkVygl1MhVcQx9dnBP-gzGzoHsz',
            appKey: 'hrctlOb6RQBWjjwTJ9fVjb91'
        })
    </script>
</body>


</section>
        </div>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            <a href="https://www.jifu.io">
            Ji Fu &copy; 2021
            </a>
            <br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a>
            <br> 您是  jifu'wiki 的第<span id="busuanzi_value_site_uv"></span>个小伙伴
            <br>
                本站总访问量<span id="busuanzi_value_site_pv"></span>次
                本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </div>
    </div>
</footer>



        

    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>