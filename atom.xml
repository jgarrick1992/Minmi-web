<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JiFu&#39;s Wiki</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.jifu.io/"/>
  <updated>2021-03-28T00:33:21.208Z</updated>
  <id>http://www.jifu.io/</id>
  
  <author>
    <name>Ji Fu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个惊人快速的终端录像工具，也能录制 VSCode 和 Chrome 窗口</title>
    <link href="http://www.jifu.io/posts/4263562837/"/>
    <id>http://www.jifu.io/posts/4263562837/</id>
    <published>2021-03-28T00:02:47.000Z</published>
    <updated>2021-03-28T00:33:21.208Z</updated>
    
    <content type="html"><![CDATA[<p>【导语】：t-rec 是一款惊人的快速终端记录器，可以生成 gif 图像。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>t-rec 是使用 Rust 实现的一款快速终端记录器，结果可生成动图或视频，有以下特点：</p><ul><li>以每秒 4 帧的速度录制终端</li><li>生成高质量的小尺寸动画 gif 图像或 mp4 视频</li><li>内置空闲帧检测和优化 (用于超级流体演示)</li><li>应用 (可以禁用) 边框装饰效果，如投影</li><li>在 MacOS 和 Linux 上运行</li><li>使用本地高效的 api</li><li>在没有任何云服务的情况下运行，完全脱机</li><li>支持终端尺寸大于 80x24</li><li>字体和颜色均可正常显示</li><li>支持基于 curses 的程序</li><li>支持转义序列</li><li>没有记录和重放 - 只是一个简单的命令来管理</li><li>隐藏功能: 记录任意窗口<br><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210328133124.gif" alt=""></li></ul><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/sassman/t-rec-rs" target="_blank" rel="noopener">github</a></p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>t-rec 仅支持在 MacOS 和 Linux 安装使用，方法如下：</p><h2 id="在-MacOS-下安装使用"><a href="#在-MacOS-下安装使用" class="headerlink" title="在 MacOS 下安装使用"></a>在 MacOS 下安装使用</h2><ul><li>使用 homebrew 安装：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">brew <span class="token function">install</span> t-rec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用 cargo 安装：</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#先安装依赖imagemagick</span>brew <span class="token function">install</span> imagemagickcargo <span class="token function">install</span> -f t-rec <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="在-Linux-下安装使用"><a href="#在-Linux-下安装使用" class="headerlink" title="在 Linux 下安装使用"></a>在 Linux 下安装使用</h2><ul><li>下载 deb 安装包安装：</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> imagemagick<span class="token function">wget</span> https://github.com/sassman/t-rec-rs/releases/download/v0.5.0/t-rec_0.5.0_amd64.deb<span class="token function">sudo</span> dpkg -i t-rec_0.5.0_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>使用 snap 安装：</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> snap <span class="token function">install</span> t-rec --classic/snap/bin/t-rec --versiont-rec 0.4.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>从 AUR 下载</li></ul><pre class="line-numbers language-bash"><code class="language-bash">paru -S t-rec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用 cargo 安装：</li></ul><pre class="line-numbers language-absh"><code class="language-absh"># 先安装依赖imagemagicksudo apt-get install libx11-dev imagemagickcargo install -f t-rec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ubuntu 20.10 GNOME 下使用效果：</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210328133159.gif" alt=""></p><p>ubuntu 20.10 i3wm 下使用效果：</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210328133215.gif" alt=""></p><p>linux mint 20 cinnamon 下使用效果：</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210328133228.md" alt=""></p><p>ArcoLinux 5.4 Xfwm4 下使用效果：</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210328133238.md" alt=""></p><h2 id="使用命令详解"><a href="#使用命令详解" class="headerlink" title="使用命令详解"></a>使用命令详解</h2><pre class="line-numbers language-bash"><code class="language-bash">t-rec <span class="token punctuation">[</span>FLAGS<span class="token punctuation">]</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> <span class="token punctuation">[</span>shell or program to launch<span class="token punctuation">]</span>FLAGS:    -h, --help       打印帮助信息    -l, --ls-win     显示窗口ID，设置环境变量<span class="token string">'WINDOWID'</span>去录制指定的窗口    -n, --natural    自然的打字体验并禁用空闲检测和采样优化    -q, --quiet      静音模式，不提示:“Press Ctrl+D to end recording”    -V, --version    显示版本信息    -v, --verbose    详细信息OPTIONS:    -b, --bg <span class="token operator">&lt;</span>bg<span class="token operator">></span>          背景颜色<span class="token punctuation">[</span>默认: transparent<span class="token punctuation">]</span>，<span class="token punctuation">[</span>可选: white, black,transparent<span class="token punctuation">]</span>    -d, --decor <span class="token operator">&lt;</span>decor<span class="token operator">></span>    装饰效果 <span class="token punctuation">[</span>默认: shadow<span class="token punctuation">]</span>  <span class="token punctuation">[</span>可选: shadow, none<span class="token punctuation">]</span>    -m, --video <span class="token operator">&lt;</span>video<span class="token operator">></span>    对gif生成一个mp4视频<span class="token punctuation">[</span>默认: mp4<span class="token punctuation">]</span>  <span class="token punctuation">[</span>可选: mp4<span class="token punctuation">]</span>ARGS:    <span class="token operator">&lt;</span>shell or program to launch<span class="token operator">></span>    启动指定的程序，例如 <span class="token string">'/bin/sh'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="录制指定的窗口"><a href="#录制指定的窗口" class="headerlink" title="录制指定的窗口"></a>录制指定的窗口</h2><ul><li>通过环境变量 TERM_PROGRAM 指定录制 Google Chrome 窗口</li></ul><pre class="line-numbers language-bash"><code class="language-bash">TERM_PROGRAM<span class="token operator">=</span><span class="token string">"google chrome"</span> t-recFrame cache dir: <span class="token string">"/var/folders/m8/084p1v0x4770rpwpkrgl5b6h0000gn/T/trec-74728.rUxBx3ohGiQ2"</span>Recording window: <span class="token string">"Google Chrome 2"</span>Press Ctrl+D to end recording<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210328133306.gif" alt=""></p><ul><li>通过环境变量 WINDOWID 指定录制 VSCode 窗口</li></ul><pre class="line-numbers language-bash"><code class="language-bash">t-rec --ls-win <span class="token operator">|</span> <span class="token function">grep</span> -i codeCode <span class="token operator">|</span> 27600<span class="token comment" spellcheck="true"># set the WINDOWID variable and run t-rec</span>WINDOWID<span class="token operator">=</span>27600 t-recFrame cache dir: <span class="token string">"/var/folders/m8/084p1v0x4770rpwpkrgl5b6h0000gn/T/trec-77862.BMYiHNRWqv9Y"</span>Press Ctrl+D to end recording<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【导语】：t-rec 是一款惊人的快速终端记录器，可以生成 gif 图像。&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;t-rec 是使用 Rust 实现的一款快速终端记
      
    
    </summary>
    
      <category term="OPS" scheme="http://www.jifu.io/categories/OPS/"/>
    
      <category term="MacOS" scheme="http://www.jifu.io/categories/OPS/MacOS/"/>
    
    
      <category term="终端" scheme="http://www.jifu.io/tags/%E7%BB%88%E7%AB%AF/"/>
    
      <category term="录像" scheme="http://www.jifu.io/tags/%E5%BD%95%E5%83%8F/"/>
    
      <category term="VSCode" scheme="http://www.jifu.io/tags/VSCode/"/>
    
      <category term="Chrome" scheme="http://www.jifu.io/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>我用 Python 的 Seaborn 库，绘制了 17 个超好看图表!</title>
    <link href="http://www.jifu.io/posts/3634498847/"/>
    <id>http://www.jifu.io/posts/3634498847/</id>
    <published>2021-03-08T22:18:11.000Z</published>
    <updated>2021-03-27T14:40:11.993Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111745.png" alt=""></p><h1 id="Seaborn简介"><a href="#Seaborn简介" class="headerlink" title="Seaborn简介"></a>Seaborn简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Seaborn是一个基于matplotlib且数据结构与pandas统一的统计图制作库。Seaborn框架旨在以数据可视化为中心来挖掘与理解数据。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p>代码较少</p></li><li><p>图形美观</p></li><li><p>功能齐全</p></li><li><p>主流模块安装</p></li></ol><h2 id="pip命令安装"><a href="#pip命令安装" class="headerlink" title="pip命令安装"></a>pip命令安装</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span>pip <span class="token function">install</span> matplotlib  pip <span class="token function">install</span> seaborn<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="从github安装"><a href="#从github安装" class="headerlink" title="从github安装"></a>从github安装</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span>pip <span class="token function">install</span> git+https://github.com/mwaskom/seaborn.git<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="导入绘图模块"><a href="#导入绘图模块" class="headerlink" title="导入绘图模块"></a>导入绘图模块</h2><a id="more"></a><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span>mport matplotlib.pyplot as plt  <span class="token function">import</span> seaborn as sns<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="提供显示条件"><a href="#提供显示条件" class="headerlink" title="提供显示条件"></a>提供显示条件</h2><pre class="line-numbers language-bash"><code class="language-bash">`%matplotlib inline  <span class="token comment" spellcheck="true">#在Jupyter中正常显示图形`</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#Seaborn内置数据集导入  </span>dataset <span class="token operator">=</span> sns<span class="token punctuation">.</span>load_dataset<span class="token punctuation">(</span><span class="token string">'dataset'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#外置数据集导入（以csv格式为例）  </span>dataset <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'dataset.csv'</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="设置画布"><a href="#设置画布" class="headerlink" title="设置画布"></a>设置画布</h2><pre class="line-numbers language-bash"><code class="language-bash">`<span class="token comment" spellcheck="true">#设置一块大小为(12,6)的画布  </span>plt.figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span>12, 6<span class="token punctuation">))</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="输出图形"><a href="#输出图形" class="headerlink" title="输出图形"></a>输出图形</h2><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#整体图形背景样式，共5种:"white", "dark", "whitegrid", "darkgrid", "ticks"  </span>sns<span class="token punctuation">.</span>set_style<span class="token punctuation">(</span><span class="token string">'white'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#以条形图为例输出图形  </span>sns<span class="token punctuation">.</span>barplot<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">,</span>y<span class="token operator">=</span>y<span class="token punctuation">,</span>data<span class="token operator">=</span>dataset<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>  <span class="token triple-quoted-string string">'''  barplot()括号里的是需要设置的具体参数，  涉及到数据、颜色、坐标轴、以及具体图形的一些控制变量，  基本的一些参数包括'x'、'y'、'data'，分别表示x轴，y轴，  以及选择的数据集。  '''</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="保存图形"><a href="#保存图形" class="headerlink" title="保存图形"></a>保存图形</h2><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#将画布保存为png、jpg、svg等格式图片  </span>plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'jg.png'</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#数据准备  </span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'./cook.csv'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#读取数据集(「菜J学Python」公众号后台回复cook获取)  </span>df<span class="token punctuation">[</span><span class="token string">'难度'</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token string">'用料数'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span><span class="token string">'简单'</span> <span class="token keyword">if</span> x<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token keyword">else</span><span class="token punctuation">(</span><span class="token string">'一般'</span> <span class="token keyword">if</span> x<span class="token operator">&lt;</span><span class="token number">15</span>  <span class="token keyword">else</span> <span class="token string">'较难'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#增加难度字段  </span>df <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'菜谱'</span><span class="token punctuation">,</span><span class="token string">'用料'</span><span class="token punctuation">,</span><span class="token string">'用料数'</span><span class="token punctuation">,</span><span class="token string">'难度'</span><span class="token punctuation">,</span><span class="token string">'菜系'</span><span class="token punctuation">,</span><span class="token string">'评分'</span><span class="token punctuation">,</span><span class="token string">'用户'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#选择需要的列  </span>df<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#查看数据集的随机5行数据`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309110528.png" alt=""></p><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#导入相关包  </span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np  <span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd  <span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt  <span class="token keyword">import</span> matplotlib <span class="token keyword">as</span> mpl  <span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns  <span class="token operator">%</span>matplotlib inline  plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.sans-serif'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'SimHei'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 设置加载的字体名  </span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'axes.unicode_minus'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token comment" spellcheck="true"># 解决保存图像是负号'-'显示为方块的问题  </span>sns<span class="token punctuation">.</span>set_style<span class="token punctuation">(</span><span class="token string">'white'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#设置图形背景样式为white`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#语法  </span><span class="token triple-quoted-string string">'''  seaborn.distplot(a, bins=None, hist=True, kde=True, rug=False, fit=None,  hist_kws=None, kde_kws=None, rug_kws=None, fit_kws=None, color=None,  vertical=False, norm_hist=False, axlabel=None, label=None, ax=None)  '''</span>  <span class="token comment" spellcheck="true">#distplot()输出直方图，默认拟合出密度曲线  </span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#设置画布大小  </span>rate <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token string">'评分'</span><span class="token punctuation">]</span>  sns<span class="token punctuation">.</span>distplot<span class="token punctuation">(</span>rate<span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"salmon"</span><span class="token punctuation">,</span>bins<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#参数color样式为salmon，bins参数设定数据片段的数量`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309110833.png" alt=""></p><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#kde参数设为False,可去掉拟合的密度曲线  </span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>distplot<span class="token punctuation">(</span>rate<span class="token punctuation">,</span>kde<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"salmon"</span><span class="token punctuation">,</span>bins<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309110614.png" alt="图片"></p><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#设置rug参数，可添加观测数值的边际毛毯  </span>fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#为方便对比，创建一个1行2列的画布,figsize设置画布大小  </span>sns<span class="token punctuation">.</span>distplot<span class="token punctuation">(</span>rate<span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"salmon"</span><span class="token punctuation">,</span>bins<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#axes[0]表示第一张图(左图)  </span>sns<span class="token punctuation">.</span>distplot<span class="token punctuation">(</span>rate<span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"green"</span><span class="token punctuation">,</span>bins<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>rug<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#axes[1]表示第一张图(右图)`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309110634.png" alt="图片"></p><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#多个参数可通过字典传递 </span>fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>distplot<span class="token punctuation">(</span>rate<span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"salmon"</span><span class="token punctuation">,</span>bins<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span>rug<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>distplot<span class="token punctuation">(</span>rate<span class="token punctuation">,</span>rug<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                       hist_kws<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'color'</span><span class="token punctuation">:</span><span class="token string">'g'</span><span class="token punctuation">,</span><span class="token string">'label'</span><span class="token punctuation">:</span><span class="token string">'直方图'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                       kde_kws<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'color'</span><span class="token punctuation">:</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'label'</span><span class="token punctuation">:</span><span class="token string">'密度曲线'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                       bins<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span>                       ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309110722.png" alt="图片"></p><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><h3 id="常规散点图-scatterplot"><a href="#常规散点图-scatterplot" class="headerlink" title="常规散点图:scatterplot"></a>常规散点图:scatterplot</h3><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#语法  </span><span class="token triple-quoted-string string">'''  seaborn.scatterplot(x=None, y=None, hue=None, style=None, size=None,  data=None, palette=None, hue_order=None, hue_norm=None, sizes=None,  size_order=None, size_norm=None, markers=True, style_order=None, x_bins=None,  y_bins=None, units=None, estimator=None, ci=95, n_boot=1000, alpha='auto',  x_jitter=None, y_jitter=None, legend='brief', ax=None, **kwargs)  '''</span>  fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#hue参数，对数据进行细分  </span>sns<span class="token punctuation">.</span>scatterplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"用料数"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"评分"</span><span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">"难度"</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#style参数通过不同的颜色和标记显示分组变量  </span>sns<span class="token punctuation">.</span>scatterplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"用料数"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"评分"</span><span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">"难度"</span><span class="token punctuation">,</span>style<span class="token operator">=</span><span class="token string">'难度'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309110833.png" alt="图片"></p><h3 id="分簇散点图-stripplot"><a href="#分簇散点图-stripplot" class="headerlink" title="分簇散点图:stripplot"></a>分簇散点图:stripplot</h3><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#语法  </span><span class="token triple-quoted-string string">'''  seaborn.stripplot(x=None, y=None, hue=None, data=None, order=None,  hue_order=None, jitter=True, dodge=False, orient=None, color=None,  palette=None, size=5, edgecolor='gray', linewidth=0, ax=None, **kwargs)  '''</span>  <span class="token comment" spellcheck="true">#设置jitter参数控制抖动的大小  </span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>stripplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"菜系"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"评分"</span><span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">"难度"</span><span class="token punctuation">,</span>jitter<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309110954.png" alt="图片"></p><h3 id="分类散点图-swarmplot"><a href="#分类散点图-swarmplot" class="headerlink" title="分类散点图:swarmplot"></a>分类散点图:swarmplot</h3><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#绘制分类散点图(带分布属性)  </span><span class="token comment" spellcheck="true">#语法  </span><span class="token triple-quoted-string string">'''  seaborn.swarmplot(x=None, y=None, hue=None, data=None, order=None,  hue_order=None, dodge=False, orient=None, color=None, palette=None,  size=5, edgecolor='gray', linewidth=0, ax=None, **kwargs)  '''</span>  plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>swarmplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"菜系"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"评分"</span><span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">"难度"</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111018.png" alt="图片"></p><h2 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h2><h3 id="常规条形图-barplot"><a href="#常规条形图-barplot" class="headerlink" title="常规条形图:barplot"></a>常规条形图:barplot</h3><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#语法  </span><span class="token triple-quoted-string string">'''  seaborn.barplot(x=None, y=None, hue=None, data=None, order=None,  hue_order=None,ci=95, n_boot=1000, units=None, orient=None, color=None,  palette=None, saturation=0.75, errcolor='.26', errwidth=None, capsize=None,  ax=None, estimator=&lt;function mean>，**kwargs)  '''</span>  <span class="token comment" spellcheck="true">#barplot()默认展示的是某种变量分布的平均值（可通过修改estimator参数为max、min、median等）  </span><span class="token comment" spellcheck="true"># from numpy import median  </span>fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>barplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'菜系'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"r"</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>barplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'菜系'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"salmon"</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>estimator<span class="token operator">=</span>min<span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111049.png" alt="图片"></p><pre class="line-numbers language-python"><code class="language-python">`fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#设置hue参数，对x轴的数据进行细分  </span>sns<span class="token punctuation">.</span>barplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'菜系'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"salmon"</span><span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">'难度'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#调换x和y的顺序，可将纵向条形图转为水平条形图  </span>sns<span class="token punctuation">.</span>barplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'菜系'</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"salmon"</span><span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">'难度'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111135.png" alt="图片"></p><h3 id="计数条形图-countplot"><a href="#计数条形图-countplot" class="headerlink" title="计数条形图:countplot"></a>计数条形图:countplot</h3><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#语法</span><span class="token triple-quoted-string string">'''seaborn.countplot(x=None, y=None, hue=None, data=None, order=None,hue_order=None, orient=None, color=None, palette=None, saturation=0.75, dodge=True, ax=None, **kwargs)'''</span>fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#选定某个字段，countplot()会自动统计该字段下各类别的数目sns.countplot(x='菜系',color="salmon",data=df,ax=axes[0])</span><span class="token comment" spellcheck="true">#同样可以加入hue参数sns.countplot(x='菜系',color="salmon",hue='难度',data=df,ax=axes[1])</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111254.png" alt="图片"></p><h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#语法  </span><span class="token triple-quoted-string string">'''  seaborn.lineplot(x=None, y=None, hue=None, size=None, style=None,  data=None, palette=None, hue_order=None, hue_norm=None, sizes=None, size_order=None,  size_norm=None, dashes=True, markers=None, style_order=None, units=None, estimator='mean',  ci=95, n_boot=1000, sort=True, err_style='band', err_kws=None, legend='brief', ax=None, **kwargs)  '''</span>  fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#默认折线图有聚合  </span>sns<span class="token punctuation">.</span>lineplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"用料数"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"评分"</span><span class="token punctuation">,</span> hue<span class="token operator">=</span><span class="token string">"菜系"</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#estimator参数设置为None可取消聚合  </span>sns<span class="token punctuation">.</span>lineplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"用料数"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"评分"</span><span class="token punctuation">,</span> hue<span class="token operator">=</span><span class="token string">"菜系"</span><span class="token punctuation">,</span>estimator<span class="token operator">=</span>None<span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111327.png" alt="图片"></p><h2 id="箱图"><a href="#箱图" class="headerlink" title="箱图"></a>箱图</h2><h3 id="箱线图-boxplot"><a href="#箱线图-boxplot" class="headerlink" title="箱线图:boxplot"></a>箱线图:boxplot</h3><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#语法  </span><span class="token triple-quoted-string string">'''  seaborn.boxplot(x=None, y=None, hue=None, data=None, order=None,  hue_order=None, orient=None, color=None, palette=None, saturation=0.75,  width=0.8, dodge=True, fliersize=5, linewidth=None, whis=1.5, notch=False, ax=None, **kwargs)  '''</span>  fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>boxplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'菜系'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">'难度'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#调节order和hue_order参数，可以控制x轴展示的顺序,linewidth调节线宽  </span>sns<span class="token punctuation">.</span>boxplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'菜系'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">'难度'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"salmon"</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>                      order<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'清真菜'</span><span class="token punctuation">,</span><span class="token string">'粤菜'</span><span class="token punctuation">,</span><span class="token string">'东北菜'</span><span class="token punctuation">,</span><span class="token string">'鲁菜'</span><span class="token punctuation">,</span><span class="token string">'浙菜'</span><span class="token punctuation">,</span><span class="token string">'湖北菜'</span><span class="token punctuation">,</span><span class="token string">'川菜'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                      hue_order<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'简单'</span><span class="token punctuation">,</span><span class="token string">'一般'</span><span class="token punctuation">,</span><span class="token string">'较难'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111400.png" alt="图片"></p><h3 id="箱型图-boxenplot"><a href="#箱型图-boxenplot" class="headerlink" title="箱型图:boxenplot"></a>箱型图:boxenplot</h3><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#语法  </span><span class="token triple-quoted-string string">'''  seaborn.boxenplot(x=None, y=None, hue=None, data=None, order=None,  hue_order=None, orient=None, color=None, palette=None, saturation=0.75,  width=0.8, dodge=True, k_depth='proportion', linewidth=None, scale='exponential',  outlier_prop=None, ax=None, **kwargs)  '''</span>  fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>boxenplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'菜系'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">'难度'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">"salmon"</span><span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#palette参数可设置调色板  </span>sns<span class="token punctuation">.</span>boxenplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'菜系'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">'难度'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span> palette<span class="token operator">=</span><span class="token string">"Set2"</span><span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111433.png" alt="图片"></p><h2 id="小提琴图"><a href="#小提琴图" class="headerlink" title="小提琴图"></a>小提琴图</h2><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#语法  </span><span class="token triple-quoted-string string">'''  seaborn.violinplot(x=None, y=None, hue=None, data=None, order=None,  hue_order=None, bw='scott', cut=2, scale='area', scale_hue=True,  gridsize=100, width=0.8, inner='box', split=False, dodge=True, orient=None,  linewidth=None, color=None, palette=None, saturation=0.75, ax=None, **kwargs)  '''</span>  fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>violinplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'菜系'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"salmon"</span><span class="token punctuation">,</span>linewidth<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#inner参数可在小提琴内部添加图形,palette设置颜色渐变  </span>sns<span class="token punctuation">.</span>violinplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'菜系'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>palette<span class="token operator">=</span>sns<span class="token punctuation">.</span>color_palette<span class="token punctuation">(</span><span class="token string">'Greens'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>inner<span class="token operator">=</span><span class="token string">'stick'</span><span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111451.png" alt="图片"></p><h2 id="回归图"><a href="#回归图" class="headerlink" title="回归图"></a>回归图</h2><h3 id="regplot"><a href="#regplot" class="headerlink" title="regplot"></a>regplot</h3><pre class="line-numbers language-python"><code class="language-python">`<span class="token triple-quoted-string string">'''  seaborn.regplot(x, y, data=None, x_estimator=None, x_bins=None, x_ci='ci',                  scatter=True, fit_reg=True, ci=95, n_boot=1000, units=None,                  order=1, logistic=False, lowess=False, robust=False, logx=False,                  x_partial=None, y_partial=None, truncate=False, dropna=True,                  x_jitter=None, y_jitter=None, label=None, color=None, marker='o',                  scatter_kws=None, line_kws=None, ax=None)  '''</span>  fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#marker参数可设置数据点的形状  </span>sns<span class="token punctuation">.</span>regplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'用料数'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">,</span>marker<span class="token operator">=</span><span class="token string">'+'</span><span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#ci参数设置为None可去除直线附近阴影(置信区间)  </span>sns<span class="token punctuation">.</span>regplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'用料数'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>ci<span class="token operator">=</span>None<span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'g'</span><span class="token punctuation">,</span>marker<span class="token operator">=</span><span class="token string">'*'</span><span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111521.png" alt="图片"></p><h3 id="lmplot"><a href="#lmplot" class="headerlink" title="lmplot"></a>lmplot</h3><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#语法  </span><span class="token triple-quoted-string string">'''  seaborn.lmplot(x, y, data, hue=None, col=None, row=None, palette=None,                 col_wrap=None, height=5, aspect=1, markers='o', sharex=True,                 sharey=True, hue_order=None, col_order=None, row_order=None,                 legend=True, legend_out=True, x_estimator=None, x_bins=None,                 x_ci='ci', scatter=True, fit_reg=True, ci=95, n_boot=1000,                 units=None, order=1, logistic=False, lowess=False, robust=False,                 logx=False, x_partial=None, y_partial=None, truncate=False,                 x_jitter=None, y_jitter=None, scatter_kws=None, line_kws=None, size=None)  '''</span>  <span class="token comment" spellcheck="true">#lmplot()可以设置hue,进行多个类别的显示,而regplot()是不支持的  </span>sns<span class="token punctuation">.</span>lmplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'用料数'</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token string">'评分'</span><span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">'难度'</span><span class="token punctuation">,</span>data<span class="token operator">=</span>df<span class="token punctuation">,</span>             palette<span class="token operator">=</span>sns<span class="token punctuation">.</span>color_palette<span class="token punctuation">(</span><span class="token string">'Reds'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ci<span class="token operator">=</span>None<span class="token punctuation">,</span>markers<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'*'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111521.png" alt="图片"></p><h2 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h2><pre class="line-numbers language-python"><code class="language-python">`<span class="token comment" spellcheck="true">#语法  </span><span class="token triple-quoted-string string">'''  seaborn.heatmap(data, vmin=None, vmax=None, cmap=None, center=None,                  robust=False, annot=None, fmt='.2g', annot_kws=None,                  linewidths=0, linecolor='white', cbar=True, cbar_kws=None,                  cbar_ax=None, square=False, xticklabels='auto',                  yticklabels='auto', mask=None, ax=None, **kwargs)  '''</span>  fig<span class="token punctuation">,</span>axes<span class="token operator">=</span>plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  h<span class="token operator">=</span>pd<span class="token punctuation">.</span>pivot_table<span class="token punctuation">(</span>df<span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'菜系'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'难度'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>values<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'评分'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>aggfunc<span class="token operator">=</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>heatmap<span class="token punctuation">(</span>h<span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#annot参数设置为True可显示数字,cmap参数可设置热力图调色板  </span>cmap <span class="token operator">=</span> sns<span class="token punctuation">.</span>diverging_palette<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>sep<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span>as_cmap<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  sns<span class="token punctuation">.</span>heatmap<span class="token punctuation">(</span>h<span class="token punctuation">,</span>annot<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>cmap<span class="token operator">=</span>cmap<span class="token punctuation">,</span>ax<span class="token operator">=</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#保存图形  </span>plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'jg.png'</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111625.png" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210309111745.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Seaborn简介&quot;&gt;&lt;a href=&quot;#Seaborn简介&quot; class=&quot;headerlink&quot; title=&quot;Seaborn简介&quot;&gt;&lt;/a&gt;Seaborn简介&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;Seaborn是一个基于matplotlib且数据结构与pandas统一的统计图制作库。Seaborn框架旨在以数据可视化为中心来挖掘与理解数据。&lt;/p&gt;
&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;代码较少&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图形美观&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;功能齐全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主流模块安装&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;pip命令安装&quot;&gt;&lt;a href=&quot;#pip命令安装&quot; class=&quot;headerlink&quot; title=&quot;pip命令安装&quot;&gt;&lt;/a&gt;pip命令安装&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;`pip install matplotlib  
pip install seaborn`
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;从github安装&quot;&gt;&lt;a href=&quot;#从github安装&quot; class=&quot;headerlink&quot; title=&quot;从github安装&quot;&gt;&lt;/a&gt;从github安装&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;`pip install git+https://github.com/mwaskom/seaborn.git`
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;流程&quot;&gt;&lt;a href=&quot;#流程&quot; class=&quot;headerlink&quot; title=&quot;流程&quot;&gt;&lt;/a&gt;流程&lt;/h1&gt;&lt;h2 id=&quot;导入绘图模块&quot;&gt;&lt;a href=&quot;#导入绘图模块&quot; class=&quot;headerlink&quot; title=&quot;导入绘图模块&quot;&gt;&lt;/a&gt;导入绘图模块&lt;/h2&gt;
    
    </summary>
    
      <category term="back-end" scheme="http://www.jifu.io/categories/back-end/"/>
    
      <category term="Python" scheme="http://www.jifu.io/categories/back-end/Python/"/>
    
      <category term="Library" scheme="http://www.jifu.io/categories/back-end/Python/Library/"/>
    
    
      <category term="Python" scheme="http://www.jifu.io/tags/Python/"/>
    
      <category term="Seaborn" scheme="http://www.jifu.io/tags/Seaborn/"/>
    
      <category term="图表" scheme="http://www.jifu.io/tags/%E5%9B%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>工作两三年了，整不明白架构图都画啥？</title>
    <link href="http://www.jifu.io/posts/2097636152/"/>
    <id>http://www.jifu.io/posts/2097636152/</id>
    <published>2021-03-03T08:09:53.000Z</published>
    <updated>2021-03-27T14:40:11.993Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210303212435.jpg" alt=""></p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p><code>很多程序员画架构图头疼，不知道画什么、怎么画！</code></p><p><code>分享</code>、<code>评审</code>、<code>述职</code>、<code>答辩</code>，只要你在程序员这个行业，就几乎离不开要画图。</p><p>一提到画图很多人就想站会起来喊，”内卷“、”内卷啦“、”PPT工程师“，但程序代码本身就是一种数学逻辑的具体实现，如果没有一些图表配合文字的阐述，讲真很难让所有人都能在共同的共识下进行交流。</p><p>这不像是文科，”八表流云澄夜色，九霄华月动春城“ 上来就能联想到它是在描述啥。但是偏理科代码逻辑或架构设计，只能把抽象的内容用图表的形式展现出来，让大家在同一的共识下共同协同工作。</p><p>而我们画的架构图、流程图、结构图、功能图、逻辑图等，都需要好看、好懂、好用、好搞，因为：</p><ul><li><strong>好看</strong>是为了提升沟通效率，</li><li><strong>好懂</strong>是为了提升交流共识，</li><li><strong>好用</strong>是为了提升交付质量，</li><li><strong>好搞</strong>是为了提升实施速度。</li></ul><p>这就像君子在追求漂亮姑娘一样，好看就想主动撩一下、有品行和共同的三观很快让你开口说<code>我懂你</code>、接下来就是交付质量和实施速度了，那也是水到渠成的事。</p><p>好，别激动，接下来我们就开始专心研究研究架构图，都有哪些，该怎么画，有什么手法。</p><h1 id="2-架构图有哪几种？"><a href="#2-架构图有哪几种？" class="headerlink" title="2. 架构图有哪几种？"></a>2. 架构图有哪几种？</h1><p>仅说技术架构图的话，通常我们☞指的是选型各项技术组件来支撑整个服务建设的系统架构。但用于不同人群范围和不同场景下会有其他分类，如图 26-1 架构图分类</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210303211206.png" alt=""></p><ul><li><strong>业务架构</strong>：需求初期业务的结果和过程描述一般比较模糊，可能来自于某个老板、运营或用户的反馈。<em>客户说海尔洗衣机洗土豆会堵，海尔立马设计专门的土豆洗衣机</em> 业务方向往往是定方向和结果的叫<code>战略</code>，主要包括业务规划、业务模块和流程以及问题域的列表等。</li><li><strong>应用架构</strong>：服务复用、跨组协同，简单、灵活、整合是应用架构必须考虑的点，就像你要上线一个聊天功能，那么聊天内容的输入法、文字识别、舆情监控以及视频服务、支付服务等，它们都是在应用架构分层下沉淀到平台的产物，在供各个方使用。</li><li><strong>产品架构</strong>：业务提需求，产品定方案，相对于业务的粗放流程，产品架构会更加细腻以及考虑各个模块的分层和边界。</li><li><strong>数据架构</strong>：数据的获取、数据的存放和数据的使用是数据架构要解决的三个问题，数据库存放、大数据汇总、数据分析等。</li><li><strong>技术架构</strong>：是离程序员最近的架构设计，它不仅是系统搭建的架构图设计，还包括了结构、功能、流程、逻辑等内容。它的具体描述就是整个系统如何落地的具体实现方案。</li></ul><h1 id="3-Zachman框架是什么？"><a href="#3-Zachman框架是什么？" class="headerlink" title="3. Zachman框架是什么？"></a>3. Zachman框架是什么？</h1><blockquote><p>Zachman框架，由约翰 扎科曼（John Zachman ）在1987年创立的全球第一个企业架构理论，其论文《信息系统架构框架》至今仍被业界认为是企业架构设计方面最权威的理论。</p></blockquote><p>Zachman框架（Zachman framework）是一种逻辑结构，它可以对企业信息按照不同分类和不同角度进行表示。</p><p>Zachman框架，从横向六个角度看待企业，这个六个观点可以分为；什么内容、如何工作、什么地点、谁负责、为什么这么做（称为W5H）。</p><p>框架的列由一组工件组成，分为规划者、拥有者、设计者（架构师）、建造者、分包者、产品，或者有时表示为视点：范围上下文，业务概念，系统逻辑，技术，物理，组件组装和操作类。整体如图 26-2 TOGAF Zachman框架</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210303211252.png" alt=""></p><p><strong>表格横向六项</strong> 代表了用于描述信息系统的某一个方面，对于任何一个事物只要在这几个基本方面对其进行清洗的解释就足够可以描述清楚。</p><ul><li><strong>数据</strong>（What，即什么内容）：什么是业务数据，信息或对象？</li><li><strong>功能</strong>（How，即如何工作）：业务如何运作，即什么是业务流程？</li><li><strong>网络</strong>（Where，即何处）：企业运营、部署在哪里？</li><li><strong>人</strong>（Who，即何人负责）：什么人？什么是业务部门及其等级制度？</li><li><strong>时间</strong>（When，即什么时间）：业务计划和工作流程是什么？什么时候执行？</li><li><strong>原因</strong>（Why，即为什么做）：为什么选择的解决方案？这是怎么产生的？</li></ul><p><strong>表格纵向六项</strong> 代表了在信息系统构造过程中所涉及到的人在描述信息系统时所采用的视角，包括：</p><ul><li><strong>范围/规划者（Planner）</strong>：此视图描述了业务目的和策略，充当其他视图将被派生和管理的上下文。</li><li><strong>业务模型/拥有者（Owner）</strong>：这是对信息系统必须在其中运作的组织的描述。</li><li><strong>系统模型/设计师（Designer）</strong>：该视图概述了系统如何满足组织的信息需求。</li><li><strong>技术模型/建造者（Builder）</strong>：这是系统如何实施的表示，它使特定的解决方案和技术显而易见。</li><li><strong>详细表述/分包者（Sub-Contractor）</strong>：这些表示说明了某些系统元素的特定于实现的细节：在生产开始之前需要进一步说明的部分。</li><li><strong>功能系统/产品（Functioning Enterprise）</strong>：在1987年的论文（《A framework for information systems architecture》）中并没有这一行的内容，实际上此行的内容也并不在架构描述的范畴的之内，不过为了使得架构Zachman框架对于架构的表述更加完备，这一行最终还是被加了进去。</li></ul><p>根据 <strong>TOGAF</strong> 的定义，企业是具有一系列共同目标组织的集合，而架构则是为了有效地实现这一系列目标。</p><p>在实现的过程中 定义了企业的结构和运作模式的概念蓝图（SearchCIO），以及构成企业的所有关键元素和其关系的综合描述（Zachman）。通过创建、沟通和优化用以描述企业未来状态和发展的关键原则和模型以将业务愿景和战略转化成有效的企业变更的过程（Gartner）。</p><p><em>可以这一部分内容会比较绕，但可以作为架构设计的知识扩展进行学习理解以及运用。</em></p><h1 id="4-陪你画个架构图"><a href="#4-陪你画个架构图" class="headerlink" title="4. 陪你画个架构图"></a>4. 陪你画个架构图</h1><p>简单来说，架构图就是为了达成交流共识的实现方案演示，并不一定非得拘泥于某种形式，只要你能画的清楚，讲的明白就最合适不过了。</p><h2 id="4-1-架构选型图"><a href="#4-1-架构选型图" class="headerlink" title="4.1. 架构选型图"></a>4.1. 架构选型图</h2><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210303211353.png" alt="架构选型图"></p><ul><li>难度：⭐⭐⭐</li><li>作用：通常在新项目开发初期，都要做一些技术选型工作。在负载、网关、架构、治理、框架、服务、数据以及环境和支撑服务上，要选择适合当前开发的技术。</li></ul><h2 id="4-2-微服务架构"><a href="#4-2-微服务架构" class="headerlink" title="4.2. 微服务架构"></a>4.2. 微服务架构</h2><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210303211405.png" alt="微服务架构，简化版"></p><ul><li>难度：⭐⭐⭐⭐</li><li>作用：技术选型完毕后，接下来就是对于这些技术的运用。这个过程有点像搭积木一样，把每一个区域用适合此位置的积木填充进去。如果是团队初建或者是技术升级，那么这个过程还是比较复杂的，需要大量的验证。不过其实互联网的技术分层和使用已经相对稳定，搭建一个这样的微服务并不会耗费太长的时间。</li></ul><h2 id="4-3-技术架构图"><a href="#4-3-技术架构图" class="headerlink" title="4.3. 技术架构图"></a>4.3. 技术架构图</h2><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210303211414.png" alt="技术架构图"></p><ul><li>难度：⭐⭐⭐⭐</li><li>作用：技术架构图主要是对于研发层面做技术实现指导的，它可以把系统分层和实现结构划分清楚。另外一般也会把案例工程的结构拿出来一起讲解，这样可以让团队伙伴快速的进入开发。</li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><ul><li>本章节向大家讲解了什么是架构图，架构图的分类和怎么画架构图，通过这样的内容可以让大家对架构图有一个全貌的认知。在以后自己画架构图了也可以非常明确的知道面对的什么用户群体，要画的内容是什么。</li><li><strong>TOGAF</strong>有一套非常完善的企业架构理论，它描述了一种开发和管理企业体系结构生命周期的方法，并构成了TOGAF的核心。所涉及到的知识非常丰富，值得认真看一下。</li><li><code>好看</code>，能把一件事做的好看非常重要，好看能让人提起兴趣、好看可以使沟通成本降低。也鼓励大家尽可能把经过自己手里的东西，做的好看一些。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210303212435.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Soft engineering" scheme="http://www.jifu.io/categories/Soft-engineering/"/>
    
      <category term="Architecture" scheme="http://www.jifu.io/categories/Soft-engineering/Architecture/"/>
    
    
      <category term="架构" scheme="http://www.jifu.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 集群高可用原理及实战部署介绍</title>
    <link href="http://www.jifu.io/posts/2846671594/"/>
    <id>http://www.jifu.io/posts/2846671594/</id>
    <published>2021-02-28T01:06:06.000Z</published>
    <updated>2021-02-28T13:25:18.352Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228142136.jpg" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>在项目中想要 RabbitMQ 变得更加健壮，就要使得其变成高可用，今天我们一起来聊聊关于 RabbitMQ 集群原理和部署流程</p></blockquote><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>在前几篇文章中，我们详细的介绍了 RabbitMQ 的内部结构和使用，以及 SpringBoot 和 RabbitMQ 整合，都是基于单台 RabbitMQ 进行使用的。</p><p>我们知道在微服务流行的当下，一旦单台服务器挂了，基本上就无法提供高可用的服务了，因此为了保证服务高可用，在生产环境上我们通常的做法是搭建一个 RabbitMQ 集群，即使某台 RabbitMQ 故障了，其他正常的 RabbitMQ 服务器依然可以使用，应用程序的持续运行不会受到影响。</p><h1 id="2-集群架构原理"><a href="#2-集群架构原理" class="headerlink" title="2. 集群架构原理"></a>2. 集群架构原理</h1><p>在前几篇文章中，我们有介绍到 RabbitMQ 内部有各种基础构件，包括队列、交换器、绑定、虚拟主机等，他们组成了 AMQP 协议消息通信的基础，而这些构件以<strong>元数据</strong>的形式存在，它始终记录在 RabbitMQ 内部，它们分别是：</p><ul><li><p><strong>队列元数据</strong>：队列名称和它们的属性</p></li><li><p><strong>交换器元数据</strong>：交换器名称、类型和属性</p></li><li><p><strong>绑定元数据</strong>：一张简单的表格展示了如何将消息路由到队列</p></li><li><p><strong>vhost 元数据</strong>：为 vhost 内的队列、交换器和绑定提供命名空间和安全属性</p></li></ul><p>这些元数据，其实本质是一张查询表，里面包括了交换器名称和一个队列的绑定列表，当你将消息发布到交换器中，实际上是将你所在的信道将消息上的路由键与交换器的绑定列表进行匹配，然后将消息路由出去。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228140741.jpg" alt=""> 消息路由表</p><a id="more"></a><p>有了这个机制，那么在所有节点上传递交换器消息将简单很多，而 RabbitMQ 所做的事情就是把交换器元数据拷贝到所有节点上，因此每个节点上的每条信道都可以访问完整的交换器。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228140803.jpg" alt=""></p><p>如果消息生产者所连接的是节点 2 或者节点 3，此时队列1的完整数据不在该两个节点上，那么在发送消息过程中这两个节点主要起了一个路由转发作用，根据这两个节点上的元数据转发至节点1上，最终发送的消息还是会存储至节点1的队列1上。</p><p>同样，如果消息消费者所连接的节点2或者节点3，那这两个节点也会作为路由节点起到转发作用，将会从节点1的队列1中拉取消息进行消费。</p><p><strong>与常见的集群主从架构模式不同的地方在于</strong>：<strong>RabbitMQ 集群模式下，仅仅只是同步元数据，每个队列内容还是在自己的服务器节点上</strong>。</p><p>这么设计主要还是基于集群本身的<strong>性能和存储空间</strong>上来考虑：</p><ul><li><p><strong>存储空间</strong>：真正存放数据的地方是在队列里面，如果每个集群节点都拥有所有队列的完全数据拷贝，那么每个节点的存储空间会非常大，集群的消息积压能力会非常弱。例如你现在存储了 3G 队列内容，那么在另外一个只有 1G 存储空间的节点上，就会造成内存空间不足的情况，也就是无法通过集群节点的扩容提高消息积压能力。</p></li><li><p><strong>性能</strong>：消息的发布者需要将消息复制到每一个集群节点，每一条消息都会触发磁盘活动，这会导致整个集群内性能负载急剧拉升。</p></li></ul><p>既然每个队列内容还是在自己的服务器节点上，同样也会带来新的问题，<strong>那就是如果队列所在服务器挂了，那存在服务器上的队列数据是不是全部都丢失了</strong>？</p><p>在单个节点上，RabbitMQ 存储数据有两种方案：</p><ul><li><p><strong>内存模式</strong>：这种模式会将数据存储在内存当中，如果服务器突然宕机重启之后，那么附加在该节点上的队列和其关联的绑定都会丢失，并且消费者可以重新连接集群并重新创建队列；</p></li><li><p><strong>磁盘模式</strong>：这种模式会将数据存储磁盘当中，如果服务器突然宕机重启，数据会自动恢复，该队列又可以进行传输数据了，并且在恢复故障磁盘节点之前，不能在其它节点上让消费者重新连到集群并重新创建队列，如果消费者继续在其它节点上声明该队列，会得到一个 404 NOT_FOUND 错误，这样确保了当故障节点恢复后加入集群，该节点上的队列消息不会丢失，也避免了队列会在一个节点以上出现冗余的问题。</p></li></ul><p>在集群中的每个节点，要么是内存节点，要么是磁盘节点，如果是内存节点，会将所有的元数据信息仅存储到内存中，<strong>而磁盘节点则不仅会将所有元数据存储到内存上， 还会将其持久化到磁盘</strong>。</p><p>在单节点 RabbitMQ 上，仅允许该节点是磁盘节点，这样确保了节点发生故障或重启节点之后，所有关于系统的配置与元数据信息都会从磁盘上恢复。</p><p>而在 RabbitMQ 集群上，至少有一个磁盘节点，也就是在集群环境中需要添加 2 台及以上的磁盘节点，这样其中一台发生故障了，集群仍然可以保持运行。其它节点均设置为内存节点，这样会让队列和交换器声明之类的操作会更加快速，元数据同步也会更加高效。</p><h1 id="3-集群部署"><a href="#3-集群部署" class="headerlink" title="3. 集群部署"></a>3. 集群部署</h1><p>为了和生产环境保持一致，我们选用<code>CentOS7</code>操作系统进行环境部署，分别创建 3 台虚拟机。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 3台服务器的IP</span>197.168.24.206197.168.24.233197.168.24.234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>放开防火墙限制，保证 3 台服务器网络都可以互通！</p><h2 id="3-1、重新设置主机名"><a href="#3-1、重新设置主机名" class="headerlink" title="3.1、重新设置主机名"></a>3.1、重新设置主机名</h2><p>由于 RabbitMQ 集群连接是通过主机名来连接服务的，必须保证各个主机名之间可以 ping 通，重新设置 3 台服务器主机名，所以需要做以下操作：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 修改节点1的主机名</span><span class="token function">hostname</span> node1<span class="token comment" spellcheck="true"># 修改节点2的主机名</span><span class="token function">hostname</span> node2<span class="token comment" spellcheck="true"># 修改节点3的主机名</span><span class="token function">hostname</span> node3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编辑<code>/etc/hosts</code>文件，添加到在三台机器的<code>/etc/hosts</code>中以下内容：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> vim /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash">197.168.24.206 node1197.168.24.233 node2197.168.24.234 node3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-2、rabbitMQ安装"><a href="#3-2、rabbitMQ安装" class="headerlink" title="3.2、rabbitMQ安装"></a>3.2、rabbitMQ安装</h2><p>RabbitMQ 基于 erlang 进行通信，相比其它的软件，安装有些麻烦，不过本例采用<code>rpm</code>方式安装，任何新手都可以完成安装，过程如下！</p><h3 id="3-2-1、安装前命令准备"><a href="#3-2-1、安装前命令准备" class="headerlink" title="3.2.1、安装前命令准备"></a>3.2.1、安装前命令准备</h3><p>输入如下命令，完成安装前的环境准备。</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token function">lsof</span>  build-essential openssl openssl-devel unixODBC unixODBC-devel <span class="token function">make</span> gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz <span class="token function">wget</span> vim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-2、下载-RabbitMQ、erlang、socat-的安装包"><a href="#3-2-2、下载-RabbitMQ、erlang、socat-的安装包" class="headerlink" title="3.2.2、下载 RabbitMQ、erlang、socat 的安装包"></a>3.2.2、下载 RabbitMQ、erlang、socat 的安装包</h3><p>本次下载的是<code>RabbitMQ-3.6.5</code>版本，采用<code>rpm</code>一键安装，适合新手直接上手。</p><p>先创建一个<code>rabbitmq</code>目录，本例的目录路径为<code>/usr/app/rabbitmq</code>，然后在目录下执行如下命令，下载安装包！</p><ul><li>下载erlang</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>下载socat</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>下载rabbitMQ</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最终目录文件如下：</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228140937.jpg" alt=""></p><h2 id="3-2-3、安装软件包"><a href="#3-2-3、安装软件包" class="headerlink" title="3.2.3、安装软件包"></a>3.2.3、安装软件包</h2><p>下载完之后，按顺序依次安装软件包，这个很重要哦～</p><ul><li>安装erlang</li></ul><pre class="line-numbers language-bash"><code class="language-bash">rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装socat</li></ul><pre class="line-numbers language-bash"><code class="language-bash">rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装rabbitmq</li></ul><pre class="line-numbers language-bash"><code class="language-bash">rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成之后，修改<code>rabbitmq</code>的配置，默认配置文件在<code>/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin</code>目录下。</p><pre class="line-numbers language-bash"><code class="language-bash">vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改<code>loopback_users</code>节点的值！</p><p><img src="https://oscimg.oschina.net/oscnet/66858cc0-ddd7-4bf0-8d43-7821764db6e7.jpg" alt=""></p><p>分别重新命令<code>rabbit</code>节点名称</p><pre class="line-numbers language-bash"><code class="language-bash">vim /etc/rabbitmq/rabbitmq-env.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在文件里添加一行，如下配置！</p><pre class="line-numbers language-bash"><code class="language-bash">NODENAME<span class="token operator">=</span>rabbit@node1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其它两个节点命令也类似，然后，再保存！通过如下命令，启动服务即可！</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动服务</span>rabbitmq-server start <span class="token operator">&amp;</span><span class="token comment" spellcheck="true"># 停止服务</span>rabbitmqctl stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过如下命令，查询服务是否启动成功！</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">lsof</span> -i:5672<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果出现<code>5672</code>已经被监听，说明已经启动成功！</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228141112.jpg" alt=""></p><h3 id="3-2-4、启动可视化的管控台"><a href="#3-2-4、启动可视化的管控台" class="headerlink" title="3.2.4、启动可视化的管控台"></a>3.2.4、启动可视化的管控台</h3><p>输入如下命令，启动控制台！</p><pre class="line-numbers language-bash"><code class="language-bash">rabbitmq-plugins <span class="token function">enable</span> rabbitmq_management<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用浏览器打开<code>http://ip:15672</code>，这里的<code>ip</code>就是 CentOS 系统的 ip，结果如下：</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228141136.jpg" alt=""></p><p>账号、密码，默认为<code>guest</code>，如果出现无法访问，检测防火墙是否开启，如果开启将其关闭即可！</p><p>登录之后的监控平台，界面如下：</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228141144.jpg" alt=""></p><h2 id="3-3、复制-Erlang-cookie"><a href="#3-3、复制-Erlang-cookie" class="headerlink" title="3.3、复制 Erlang cookie"></a>3.3、复制 Erlang cookie</h2><p>RabbitMQ 集群环境下，元数据同步基于 cookie 共享方案实现。</p><p>在这里将 node1 的 cookie 文件复制到 node2，由于这个文件权限是 400 为方便传输，先修改权限，非必须操作，所以需要先修改 node1 中的该文件权限为 777</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chmod</span> 777 /var/lib/rabbitmq/.erlang.cookie<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用 scp 拷贝到节点 2，节点 3 的操作也类似。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">scp</span> /var/lib/rabbitmq/.erlang.cookie node2:/var/lib/rabbitmq/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后，将权限改回来</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chmod</span> 400 /var/lib/rabbitmq/.erlang.cookie<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-4、组成集群"><a href="#3-4、组成集群" class="headerlink" title="3.4、组成集群"></a>3.4、组成集群</h2><p>在节点 2 执行如下命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 停止rabbitmq服务</span>rabbitmqctl stop_app<span class="token comment" spellcheck="true"># 清空节点状态</span>rabbitmqctl reset<span class="token comment" spellcheck="true"># node2和node1构成集群,node2必须能通过node1的主机名ping通</span>rabbitmqctl join_cluster rabbit@node1<span class="token comment" spellcheck="true"># 开启rabbitmq服务</span>rabbitmqctl start_app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>节点 3 的操作也类似！</p><p>在任意一台机上面查看集群状态：</p><pre class="line-numbers language-bash"><code class="language-bash">rabbitmqctl cluster_status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228141324.jpg" alt=""></p><ul><li><p>第一行：表示当前节点信息</p></li><li><p>第二行：表示集群中的节点成员，disc 表示这些都是磁盘节点</p></li><li><p>第三行：表示正在运行的节点成员</p></li></ul><p>登录可视化管控台，可以很清晰的看到，三个服务节点已经互相关联起来了！</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228141350.jpg" alt=""></p><p>如果你想将某个节点移除集群，以移除节点3为例，可以按照如下方式进行操作！</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 首先停止要移除的节点服务</span>rabbitmqctl stop<span class="token comment" spellcheck="true"># 移除节点3</span>rabbitmqctl -n rabbit@node1 forget_cluster_node rabbit@node3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果移除之后，无法启动 rabbitMQ，删除已有 mnesia 信息！</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">rm</span> -rf /var/lib/rabbitmq/mnesia<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再次重启服务即可！</p><h2 id="3-5、设置内存节点"><a href="#3-5、设置内存节点" class="headerlink" title="3.5、设置内存节点"></a>3.5、设置内存节点</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#加入时候设置节点为内存节点（默认加入的为磁盘节点）</span>rabbitmqctl join_cluster rabbit@node1 --ram<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中<code>--ram</code>指的是作为内存节点，如果不加，那就默认为磁盘节点。</p><p>如果节点在集群中已经是磁盘节点了，通过以下命令可以将节点改成内存节点：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 停止rabbitmq服务</span>rabbitmqctl stop_app<span class="token comment" spellcheck="true"># 更改节点为内存节点</span>rabbitmqctl change_cluster_node_type <span class="token function">ram</span><span class="token comment" spellcheck="true"># 开启rabbitmq服务</span>rabbitmqctl start_app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://oscimg.oschina.net/oscnet/d488d00f-02ed-4dd2-8c19-f41ca114a3b4.jpg" alt=""></p><h3 id="3-6、镜像队列"><a href="#3-6、镜像队列" class="headerlink" title="3.6、镜像队列"></a>3.6、镜像队列</h3><p>上面我们提到，在默认情况下，队列只会保存在其中一个节点上，当节点发生故障时，尽管所有元数据信息都可以从磁盘节点上将元数据恢复到本节点上，<strong>但是内存节点的队列消息内容就不行了</strong>，这样就会导致消息的丢失。</p><p>RabbitMQ 很早就意识到这个问题，在 2.6 以后的版本中增加了队列冗余选项：<strong>镜像队列</strong>。</p><p>所谓镜像队列，其实就是主队列（master）依然是仅存在于一个节点上，通过关联的 rabbitMQ 服务器，从主队列同步消息到各个节点，也就是所谓的主从模式，将主队列的消息进行备份处理。</p><p>如果主队列没有发生故障，那么其工作流程跟普通队列一样，生产者和消费者不会感知其变化，当发布消息时，依然是路由到主队列中，而主队列通过类似广播的机制，将消息扩散同步至其余从队列中，这就有点像 fanout 交换器一样。而消费者依然是从主队列中读取消息。</p><p>一旦主队列发生故障，集群就会从最老的一个从队列选举为新的主队列，这也就实现了队列的高可用了，但我们切记不要滥用这个机制，在上面也说了，队列的冗余操作会导致不能通过扩展节点增加存储空间，而且会造成性能瓶颈。</p><p>命令格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash">rabbitmqctl set_policy <span class="token punctuation">[</span>-p Vhost<span class="token punctuation">]</span> Name Pattern Definition <span class="token punctuation">[</span>Priority<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数介绍：</p><pre class="line-numbers language-bash"><code class="language-bash">-p Vhost: 可选参数，针对指定vhost下的queue进行设置Name: policy的名称Pattern: queue的匹配模式<span class="token punctuation">(</span>正则表达式<span class="token punctuation">)</span>Definition: 镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode    ha-mode: 指明镜像队列的模式，有效值为 all/exactly/nodes        all: 表示在集群中所有的节点上进行镜像        exactly: 表示在指定个数的节点上进行镜像，节点的个数由ha-params指定        nodes: 表示在指定的节点上进行镜像，节点名称通过ha-params指定    ha-params: ha-mode模式需要用到的参数    ha-sync-mode: 进行队列中消息的同步方式，有效值为automatic和manualpriority: 可选参数，policy的优先级<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举个例子，声明名为<code>ha-all</code>的策略，它与名称以<code>ha</code>开头的队列相匹配，并将镜像配置到集群中的所有节点：</p><pre class="line-numbers language-bash"><code class="language-bash">rabbitmqctl set_policy ha-all <span class="token string">"^"</span> <span class="token string">'{"ha-mode":"all"}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类似操作很多，具体使用可以参考官方 api。</p><h1 id="4-集群的负载均衡"><a href="#4-集群的负载均衡" class="headerlink" title="4. 集群的负载均衡"></a>4. 集群的负载均衡</h1><p>HAProxy 提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。根据官方数据，其最高极限支持10G的并发。HAProxy支持从4层至7层的网络交换，即覆盖所有的 TCP 协议。就是说，Haproxy 甚至还支持 Mysql 的均衡负载。为了实现 RabbitMQ 集群的软负载均衡，这里可以选择HAProxy。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228141455.jpg" alt=""></p><h2 id="4-1、HAProxy-安装"><a href="#4-1、HAProxy-安装" class="headerlink" title="4.1、HAProxy 安装"></a>4.1、HAProxy 安装</h2><p>HAProxy 的安装也很简单，单独部署在一台服务器上，通过如下命令即可安装完成！</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> haproxy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑 HAProxy 配置文件：</p><pre class="line-numbers language-bash"><code class="language-bash">vim /etc/haproxy/haproxy.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们只需要在文件末尾加上如下配置即可！</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#绑定配置</span>listen rabbitmq_cluster        bind 0.0.0.0:5672        <span class="token comment" spellcheck="true">#配置TCP模式</span>        mode tcp        <span class="token comment" spellcheck="true">#加权轮询</span>        balance roundrobin        <span class="token comment" spellcheck="true">#RabbitMQ集群节点配置</span>        server rmq_node1 197.168.24.206:5672 check inter 5000 rise 2 fall 3 weight 1        server rmq_node2 197.168.24.233:5672 check inter 5000 rise 2 fall 3 weight 1        server rmq_node3 197.168.24.234:5672 check inter 5000 rise 2 fall 3 weight 1<span class="token comment" spellcheck="true">#haproxy监控页面地址</span>listen monitor        bind 0.0.0.0:8100        mode http        option httplog        stats <span class="token function">enable</span>        stats uri /stats        stats refresh 5s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>绑定配置参数说明：</p><ul><li><p><code>bind</code>：这里定义了客户端连接连接 IP 地址和端口号，用于客户端连接</p></li><li><p><code>balance roundrobin</code>：表示加权轮询负载均衡算法</p></li></ul><p>RabbitMQ 集群节点配置说明：</p><ul><li><p><code>server rmq_node1</code>：定义HAProxy内RabbitMQ服务的标识</p></li><li><p><code>197.168.24.206:5672</code>：标识了后端RabbitMQ的服务地址</p></li><li><p><code>check inter 5000</code>：表示每隔多少毫秒检查RabbitMQ服务是否可用，示例参数值为 5000</p></li><li><p><code>rise 2</code>：表示 RabbitMQ 服务在发生故障之后，需要多少次健康检查才能被再次确认可用，示例参数值为 2</p></li><li><p><code>fall 2</code>：表示需要经历多少次失败的健康检查之后，HAProxy 才会停止使用此RabbitMQ服务，示例参数值为 2</p></li><li><p><code>weight 1</code>：表示权重比例，值越低，会优先进行数据分配，示例参数值为 1</p></li></ul><p>启动 HAProxy：</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/sbin/haproxy -f /etc/haproxy/haproxy.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>登录<code>http://ip:8100/stats</code>web 管理界面，即可进行监控查看！</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228141542.jpg" alt=""></p><h1 id="5-Java-客户端使用"><a href="#5-Java-客户端使用" class="headerlink" title="5. Java 客户端使用"></a>5. Java 客户端使用</h1><p>如果是配置了 HAProxy 代理服务器，可以直接使用 HAProxy 代理服务器地址即可！</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//ConnectionFactory创建MQ的物理连接</span>connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>connectionFactory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"197.168.24.207"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//代理服务器地址</span>connectionFactory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//代理服务器端口</span>connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//guest只能在本机进行访问,通过代理服务器发送消息时需要重新建立用户</span>connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//guest</span>connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//虚拟主机</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有代理服务器，使用<code>Spring</code>的<code>CachingConnectionFactory</code>类进行配置。</p><p>以<code>SpringBoot</code>项目为例，配置文件如下：</p><pre class="line-numbers language-java"><code class="language-java">spring<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>addresses<span class="token operator">=</span><span class="token number">197.168</span><span class="token punctuation">.</span><span class="token number">24.206</span><span class="token operator">:</span><span class="token number">5672</span><span class="token punctuation">,</span><span class="token number">197.168</span><span class="token punctuation">.</span><span class="token number">24.233</span><span class="token operator">:</span><span class="token number">5672</span><span class="token punctuation">,</span><span class="token number">197.168</span><span class="token punctuation">.</span><span class="token number">24.234</span><span class="token operator">:</span><span class="token number">5672</span>spring<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>username<span class="token operator">=</span>guestspring<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>password<span class="token operator">=</span>guestspring<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>virtual<span class="token operator">-</span>host<span class="token operator">=</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>RabbitConfig</code>配置类如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 初始化连接工厂     * @param addresses     * @param userName     * @param password     * @param vhost     * @return     */</span>    <span class="token annotation punctuation">@Bean</span>    ConnectionFactory <span class="token function">connectionFactory</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.addresses}"</span><span class="token punctuation">)</span> String addresses<span class="token punctuation">,</span>                                        <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.username}"</span><span class="token punctuation">)</span> String userName<span class="token punctuation">,</span>                                        <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.password}"</span><span class="token punctuation">)</span> String password<span class="token punctuation">,</span>                                        <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.virtual-host}"</span><span class="token punctuation">)</span> String vhost<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CachingConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CachingConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setAddresses</span><span class="token punctuation">(</span>addresses<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>userName<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span>vhost<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> connectionFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重新实例化 RabbitAdmin 操作类     * @param connectionFactory     * @return     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> RabbitAdmin <span class="token function">rabbitAdmin</span><span class="token punctuation">(</span>ConnectionFactory connectionFactory<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RabbitAdmin</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重新实例化 RabbitTemplate 操作类     * @param connectionFactory     * @return     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> RabbitTemplate <span class="token function">rabbitTemplate</span><span class="token punctuation">(</span>ConnectionFactory connectionFactory<span class="token punctuation">)</span><span class="token punctuation">{</span>        RabbitTemplate rabbitTemplate<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">RabbitTemplate</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//数据转换为json存入消息队列</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setMessageConverter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Jackson2JsonMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>本文主要详细介绍了 RabbitMQ 集群的工作原理和如何搭建一个具备负载均衡能力的 RabbitMQ 集群的方法。</p><p>限于笔者的才疏学浅，对本文内容可能还有理解不到位的地方，如有阐述不合理之处还望留言一起探讨。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228142136.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在项目中想要 RabbitMQ 变得更加健壮，就要使得其变成高可用，今天我们一起来聊聊关于 RabbitMQ 集群原理和部署流程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h1&gt;&lt;p&gt;在前几篇文章中，我们详细的介绍了 RabbitMQ 的内部结构和使用，以及 SpringBoot 和 RabbitMQ 整合，都是基于单台 RabbitMQ 进行使用的。&lt;/p&gt;
&lt;p&gt;我们知道在微服务流行的当下，一旦单台服务器挂了，基本上就无法提供高可用的服务了，因此为了保证服务高可用，在生产环境上我们通常的做法是搭建一个 RabbitMQ 集群，即使某台 RabbitMQ 故障了，其他正常的 RabbitMQ 服务器依然可以使用，应用程序的持续运行不会受到影响。&lt;/p&gt;
&lt;h1 id=&quot;2-集群架构原理&quot;&gt;&lt;a href=&quot;#2-集群架构原理&quot; class=&quot;headerlink&quot; title=&quot;2. 集群架构原理&quot;&gt;&lt;/a&gt;2. 集群架构原理&lt;/h1&gt;&lt;p&gt;在前几篇文章中，我们有介绍到 RabbitMQ 内部有各种基础构件，包括队列、交换器、绑定、虚拟主机等，他们组成了 AMQP 协议消息通信的基础，而这些构件以&lt;strong&gt;元数据&lt;/strong&gt;的形式存在，它始终记录在 RabbitMQ 内部，它们分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;队列元数据&lt;/strong&gt;：队列名称和它们的属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;交换器元数据&lt;/strong&gt;：交换器名称、类型和属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;绑定元数据&lt;/strong&gt;：一张简单的表格展示了如何将消息路由到队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vhost 元数据&lt;/strong&gt;：为 vhost 内的队列、交换器和绑定提供命名空间和安全属性&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些元数据，其实本质是一张查询表，里面包括了交换器名称和一个队列的绑定列表，当你将消息发布到交换器中，实际上是将你所在的信道将消息上的路由键与交换器的绑定列表进行匹配，然后将消息路由出去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210228140741.jpg&quot; alt=&quot;&quot;&gt; 消息路由表&lt;/p&gt;
    
    </summary>
    
      <category term="back-end" scheme="http://www.jifu.io/categories/back-end/"/>
    
      <category term="Middle-ware" scheme="http://www.jifu.io/categories/back-end/Middle-ware/"/>
    
      <category term="RabbitMQ" scheme="http://www.jifu.io/categories/back-end/Middle-ware/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://www.jifu.io/tags/RabbitMQ/"/>
    
      <category term="集群" scheme="http://www.jifu.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="高可用性" scheme="http://www.jifu.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Swift：解包的正确姿势</title>
    <link href="http://www.jifu.io/posts/3772598043/"/>
    <id>http://www.jifu.io/posts/3772598043/</id>
    <published>2021-02-26T03:32:25.000Z</published>
    <updated>2021-02-28T13:25:18.354Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210226162513.png" alt=""></p><h1 id="嗯，先来一段感慨"><a href="#嗯，先来一段感慨" class="headerlink" title="嗯，先来一段感慨"></a>嗯，先来一段感慨</h1><p><strong>对于Swift学习而言，可选类型Optional是永远绕不过的坎，特别是从OC刚刚转Swift的时候，可能就会被代码行间的?与!，有的时候甚至是??搞得稀里糊涂的。</strong></p><p>这篇文章会给各位带来我对于可选类型的一些认识以及如何进行解包，其中会涉及到Swift中<em><strong>if let</strong></em>以及<strong><em>guard let</em></strong>的使用以及思考，还有涉及OC部分的<em><strong>nullable</strong></em>和<em><strong>nonnull</strong></em>两个关键字，以及一点点对两种语言的思考。</p><h1 id="var-num-Int-它是什么类型"><a href="#var-num-Int-它是什么类型" class="headerlink" title="var num: Int? 它是什么类型?"></a>var num: Int? 它是什么类型?</h1><p>在进行解包前，我们先来理解一个概念，这样可能更有利于对于解包。</p><p>首先我们来看看这样一段代码:</p><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token keyword">var</span> num<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token operator">?</span>  num <span class="token operator">=</span> <span class="token number">10</span>  <span class="token keyword">if</span> num <span class="token keyword">is</span> <span class="token builtin">Optional</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"它是Optional类型"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"它是Int类型"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请先暂时不要把这段代码复制到Xcode中，先自问自答，num是什么类型，是Int类型吗?</p><p>好了，你可以将这段代码复制到Xcode里去了，然后在Xcode中的if上一定会出现这样一段话：</p><a id="more"></a><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token string">'is'</span> test <span class="token keyword">is</span> always <span class="token boolean">true</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>num不是<em><strong>Int类</strong></em>，它是<em><strong>Optional类型</strong></em>。</p><p>那么Optional类型是啥呢–可选类型，具体Optional是啥，Optional类型的本质实际上就是一个带有泛型参数的enum类型，各位去源码中仔细看看就能了解到，这个类型和Swift中的Result类有异曲同工之妙。</p><p>var num: Int?这是一个人Optional的声明，意思不是“我声明了一个Optional的Int值”，而是“我声明了一个Optional类型，它可能包含一个Int值，也可能什么都不包含”，也就是说实际上我们声明的是Optional类型，而不是声明了一个Int类型！</p><p><em><strong>至于像Int!或者Int?这种写法，只是一种Optional类型的糖语法写法。</strong></em></p><p>以此类推String?是什么类型，泛型T?是什么类型，答案各位心中已经明了吧。</p><p>正是因为num是一个可选类型。所以它才能赋值为nil， <code>var num: Int = nil。</code>这样是不可能赋值成功的。因为Int类型中没有nil这个概念！</p><p>这就是Swift与OC一个很大区别，<em><strong>在OC中我们的对象都可以赋值为nil，而在Swift中，能赋值为nil只有Optional类型！</strong></em></p><h1 id="解包的基本思路，使用if-let或者guard-let，而非强制解包"><a href="#解包的基本思路，使用if-let或者guard-let，而非强制解包" class="headerlink" title="解包的基本思路，使用if let或者guard let，而非强制解包"></a>解包的基本思路，使用if let或者guard let，而非强制解包</h1><p>我们先来看一个简单的需求，虽然这个需求在实际开发中意义不太大：</p><p>我们需要从网络请求获取到的一个人的身高(cm为单位)以除以100倍，以获取m为单位的结果然后将其结果进行返回。</p><p>设计思路：</p><p>由于实际网络请求中，后台可能会返回我们的身高为空(即nil)，所以在转模型的时候我们不能定义Float类型，而是定义Float?便于接受数据。</p><p>如果身高为nil，那么nil除以100是没有意义的，在编译器中Float?除以100会直接报错，那么其返回值也应该为nil，所以函数的返回值也是Float?类型</p><p>那么函数应该设计成为这个样子是这样的:</p><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token keyword">func</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token number">_</span> height<span class="token punctuation">:</span> <span class="token builtin">Float</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Float</span><span class="token operator">?</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果一般解包的话，我们的函数实现大概会写成这样:</p><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token keyword">func</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token number">_</span> height<span class="token punctuation">:</span> <span class="token builtin">Float</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Float</span><span class="token operator">?</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> height <span class="token operator">!=</span> <span class="token constant">nil</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> height<span class="token operator">!</span> <span class="token operator">/</span> <span class="token number">100</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token constant">nil</span>  <span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用!进行强制解包，然后进行运算。</p><p>我想说的是使用强制解包固然没有错，不过如果在实际开发中这个height参数可能还要其他用途，那么是不是每使用一次都要进行强制解包？</p><p>强制解包是一种很危险的行为，一旦解包失败,就有崩溃的可能，也许你会说这不是有if判断,然而实际开发中，情况往往比想的复杂的多。<em><strong>所以安全的解包行为应该是通过if let 或者guard let来进行。</strong></em></p><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token keyword">func</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token number">_</span> height<span class="token punctuation">:</span> <span class="token builtin">Float</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Float</span><span class="token operator">?</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token keyword">let</span> unwrapedHeight <span class="token operator">=</span> height <span class="token punctuation">{</span>     <span class="token keyword">return</span> unwrapedHeight <span class="token operator">/</span> <span class="token number">100</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token constant">nil</span>  <span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者：</p><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token keyword">func</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token number">_</span> height<span class="token punctuation">:</span> <span class="token builtin">Float</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Float</span><span class="token operator">?</span> <span class="token punctuation">{</span>     <span class="token keyword">guard</span> <span class="token keyword">let</span> unwrapedHeight <span class="token operator">=</span> height <span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token constant">nil</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> unwrapedHeight <span class="token operator">/</span> <span class="token number">100</span>  <span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么if let和guard let 你更倾向使用哪个呢？</p><p>在本例子中，其实感觉二者的差别不大，不过我个人更倾向于使用guard let。</p><hr><p>原因如下：</p><p>在使用if let的时候其大括号类中的情况才是正常情况，而外部主体是非正常情况的返回的nil；</p><p>而在使用guard let的时候，guard let else中的大括号是异常情况，而外部主体返回的是正常情况。</p><p><em><strong>对于一个以返回结果为目的的函数，函数主体展示正常返回值，而将异常抛出在判断中，这样不仅逻辑更清晰，而且更加易于代码阅读。</strong></em></p><hr><h1 id="解包深入"><a href="#解包深入" class="headerlink" title="解包深入"></a>解包深入</h1><p>有这么一个需求，从本地路径获取一个json文件，最终将其转为字典，准备进行转模型操作。</p><p>在这个过程中我们大概有这么几个步骤：</p><h2 id="1-获取本地路径"><a href="#1-获取本地路径" class="headerlink" title="1. 获取本地路径"></a>1. 获取本地路径</h2><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">func</span> <span class="token function">path</span><span class="token punctuation">(</span>forResource name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">,</span> ofType ext<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span><span class="token operator">?</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-将本地路径读取转为Data"><a href="#2-将本地路径读取转为Data" class="headerlink" title="2. 将本地路径读取转为Data"></a>2. 将本地路径读取转为Data</h2><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">init</span><span class="token punctuation">(</span>contentsOf url<span class="token punctuation">:</span> <span class="token constant">URL</span><span class="token punctuation">,</span> options<span class="token punctuation">:</span> <span class="token builtin">Data</span><span class="token punctuation">.</span><span class="token builtin">ReadingOptions</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-JSON序列化"><a href="#3-JSON序列化" class="headerlink" title="3. JSON序列化"></a>3. JSON序列化</h2><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">class</span> <span class="token class-name">func</span> <span class="token function">jsonObject</span><span class="token punctuation">(</span>with data<span class="token punctuation">:</span> <span class="token builtin">Data</span><span class="token punctuation">,</span> options opt<span class="token punctuation">:</span> <span class="token builtin">JSONSerialization</span><span class="token punctuation">.</span><span class="token builtin">ReadingOptions</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Any</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-是否可以转为字典类型"><a href="#4-是否可以转为字典类型" class="headerlink" title="4. 是否可以转为字典类型"></a>4. 是否可以转为字典类型</h2><p>我们可以看到以上几个函数中，获取路径获取返回的路径结果是一个可选类型而转Data的方法是抛出异常，JSON序列化也是抛出异常，至于最后一步的类型转换是使用as？[Sting: Any]这样的操作</p><h3 id="这个函数我是这来进行设计与步骤分解的"><a href="#这个函数我是这来进行设计与步骤分解的" class="headerlink" title="这个函数我是这来进行设计与步骤分解的"></a>这个函数我是这来进行设计与步骤分解的</h3><p>函数的返回类型为可选类型，因为下面的4步中都有可能失败进而返回nil。</p><p>虽然有人会说第一步获取本地路径，一定是本地有的才会进行读取操作，但是作为一个严谨操作，凡事和字符串打交道的书写都是有隐患的，所以我这里还是用了guard let进行守护。</p><p>这个函数看起来很不简洁，每一个guard let 后面都跟着一个异常返回，甚至不如使用if let看着简洁</p><p>但是这么写的好处是：<em><strong>在调试过程中你可以明确的知道自己哪一步出错</strong></em></p><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token keyword">func</span> <span class="token function">getDictFromLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">]</span><span class="token operator">?</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/// 1 获取路径</span>     <span class="token keyword">guard</span> <span class="token keyword">let</span> path <span class="token operator">=</span> <span class="token builtin">Bundle</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span>forResource<span class="token punctuation">:</span> <span class="token string">"test"</span><span class="token punctuation">,</span> ofType<span class="token punctuation">:</span><span class="token string">"json"</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token constant">nil</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">/// 2 获取json文件里面的内容</span>     <span class="token keyword">guard</span> <span class="token keyword">let</span> jsonData <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> <span class="token builtin">Data</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>contentsOf<span class="token punctuation">:</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>fileURLWithPath<span class="token punctuation">:</span> path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token constant">nil</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">/// 3 解析json内容</span>     <span class="token keyword">guard</span> <span class="token keyword">let</span> json <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> <span class="token builtin">JSONSerialization</span><span class="token punctuation">.</span><span class="token function">jsonObject</span><span class="token punctuation">(</span>with<span class="token punctuation">:</span> jsonData<span class="token punctuation">,</span> options<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token constant">nil</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">/// 4 将Any转为Dict</span>     <span class="token keyword">guard</span> <span class="token keyword">let</span> dict <span class="token operator">=</span> json <span class="token keyword">as</span><span class="token operator">?</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token constant">nil</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> dict  <span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然,如果你要追求简洁,这么写也未尝不可,一波流带走</p><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token keyword">func</span> <span class="token function">getDictFromLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">]</span><span class="token operator">?</span> <span class="token punctuation">{</span>     <span class="token keyword">guard</span> <span class="token keyword">let</span> path <span class="token operator">=</span> <span class="token builtin">Bundle</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span>forResource<span class="token punctuation">:</span> <span class="token string">"test"</span><span class="token punctuation">,</span> ofType<span class="token punctuation">:</span><span class="token string">"json"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token keyword">let</span> jsonData <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> <span class="token builtin">Data</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>contentsOf<span class="token punctuation">:</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>fileURLWithPath<span class="token punctuation">:</span> path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token keyword">let</span> json <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> <span class="token builtin">JSONSerialization</span><span class="token punctuation">.</span><span class="token function">jsonObject</span><span class="token punctuation">(</span>with<span class="token punctuation">:</span> jsonData<span class="token punctuation">,</span> options<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token keyword">let</span> dict <span class="token operator">=</span> json <span class="token keyword">as</span><span class="token operator">?</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token constant">nil</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> dict  <span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>guard let与if let不仅可以判断一个值的解包,而且可以进行连续操作</strong></em></p><p>像下面这种写法，更加追求的是结果，对于一般的调试与学习，多几个guard let进行拆分，未尝不是好事。</p><p>至于哪种用法更适合，因人而异。</p><h1 id="可选链的解包"><a href="#可选链的解包" class="headerlink" title="可选链的解包"></a>可选链的解包</h1><p>至于可选链的解包是完全可以一步到位，假设我们有以下这个模型。</p><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>     <span class="token keyword">var</span> phone<span class="token punctuation">:</span> <span class="token builtin">Phone</span><span class="token operator">?</span>  <span class="token punctuation">}</span>  <span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>     <span class="token keyword">var</span> number<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span>  <span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Person类中有一个手机对象属性，手机类中有个手机号属性，现在我们有位小明同学，我们想知道他的手机号。</p><p>小明他不一定有手机，可能有手机而手机并没有上手机号码。</p><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token keyword">let</span> xiaoming <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">guard</span> <span class="token keyword">let</span> number <span class="token operator">=</span> xiaoming<span class="token punctuation">.</span>phone<span class="token operator">?</span><span class="token punctuation">.</span>number <span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span>  <span class="token punctuation">}</span>  <span class="token function">print</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只是抛砖引玉，更长的可选链也可以一步到位，而不必一层层进行判断，因为可选链中一旦有某个链为nil，那么就会返回nil。</p><h1 id="nullable和nonnull"><a href="#nullable和nonnull" class="headerlink" title="nullable和nonnull"></a>nullable和nonnull</h1><p>我们先来看这两个函数,PHImageManager在OC与Swift中通过PHAsset实例获取图片的例子</p><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">PHImageManager</span> defaultManager<span class="token punctuation">]</span> requestImageForAsset<span class="token punctuation">:</span>asset targetSize<span class="token punctuation">:</span>size contentMode<span class="token punctuation">:</span><span class="token builtin">PHImageContentModeDefault</span> options<span class="token punctuation">:</span>options resultHandler<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token builtin">UIImage</span> <span class="token operator">*</span> _Nullable result<span class="token punctuation">,</span> <span class="token builtin">NSDictionary</span> <span class="token operator">*</span> _Nullable info<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//、 非空才进行操作 注意_Nullable,Swift中即为nil,注意判断</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token builtin">PHImageManager</span><span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">requestImage</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> asset<span class="token punctuation">,</span> targetSize<span class="token punctuation">:</span> size<span class="token punctuation">,</span> contentMode<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">,</span> options<span class="token punctuation">:</span> options<span class="token punctuation">,</span> resultHandler<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>result<span class="token punctuation">:</span> <span class="token builtin">UIImage</span><span class="token operator">?</span><span class="token punctuation">,</span> info<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">AnyHashable</span> <span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token keyword">in</span>   <span class="token keyword">guard</span> <span class="token keyword">let</span> image <span class="token operator">=</span> result <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Swift中闭包返回的是两个可选类型，result: UIImage?与info: [AnyHashable : Any]?</p><p>而在OC中返回的类型是 UIImage <em>_Nullable result, NSDictionary </em> _Nullable info</p><p>注意观察OC中返回的类型UIImage * 后面使用了<em>Nullable来修饰,至于Nullable这个单词是什么意思，我想稍微有点英文基础的应该一看就懂–”可以为空”，</em><strong>这不恰恰和Swift的可选类型呼应吗？</strong>_</p><p>另外还有PHFetchResult遍历这个函数,我们再来看看在OC与Swift中的表达</p><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token builtin">PHFetchResult</span> <span class="token operator">*</span>fetchResult<span class="token punctuation">;</span>  <span class="token punctuation">[</span>fetchResult enumerateObjectsUsingBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">(</span>id _Nonnull obj<span class="token punctuation">,</span> <span class="token builtin">NSUInteger</span> idx<span class="token punctuation">,</span> <span class="token constant">BOOL</span> <span class="token operator">*</span> _Nonnull stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-swift"><code class="language-swift"> `<span class="token keyword">let</span> fetchResult<span class="token punctuation">:</span> <span class="token builtin">PHFetchResult</span>  fetchResult<span class="token punctuation">.</span><span class="token function">enumerateObjects</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token punctuation">(</span>obj<span class="token punctuation">,</span> index<span class="token punctuation">,</span> stop<span class="token punctuation">)</span> <span class="token keyword">in</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看见OC中Block中的回调使用了Nonnull来修饰，即不可能为空，不可能为nil，一定有值，对于使用这样的字符修饰的对象，我们就不必为其做健壮性判断了。</p><p>这也就是nullable与nonnull两个关键字出现的原因吧–与Swift做桥接使用以及显式的提醒对象的状态</p><h1 id="一点点Swift与OC的语言思考"><a href="#一点点Swift与OC的语言思考" class="headerlink" title="一点点Swift与OC的语言思考"></a>一点点Swift与OC的语言思考</h1><p>我之前写过一篇文章,是说有关于一个字符串拼接函数的</p><p>从Swift来反思OC的语法</p><p>OC函数是这样的：</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token builtin">NSString</span> <span class="token operator">*</span><span class="token punctuation">)</span>stringByAppendingString<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token builtin">NSString</span> <span class="token operator">*</span><span class="token punctuation">)</span>aString<span class="token punctuation">;</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Swift中函数是这样的：</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">public</span> <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token number">_</span> other<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>仅从API来看，OC的入参是很危险的,因为类型是NSString *</p><p>那么nil也可以传入其中，而传入nil的后果就是崩掉，我觉得对于这种传入参数为nil会崩掉的函数需要特别提醒一下，应该写成这样:</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token builtin">NSString</span> <span class="token operator">*</span><span class="token punctuation">)</span>stringByAppendingString<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token builtin">NSString</span> <span class="token operator">*</span> _Nonnull<span class="token punctuation">)</span>aString<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/// 或者下面这样</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token builtin">NSString</span> <span class="token operator">*</span><span class="token punctuation">)</span>stringByAppendingString<span class="token punctuation">:</span><span class="token punctuation">(</span>nonnull <span class="token builtin">NSString</span> <span class="token operator">*</span><span class="token punctuation">)</span>aString<span class="token punctuation">;</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以便告诉程序员，入参不能为空，不能为空，不能为空，重要的事情说三遍！！！</p><p>反观Swift就不会出现这种情况，other后面的类型为String，而不是String?，说明入参是一个非可选类型。</p><p>基于以上对于代码的严谨性，所以我才更喜欢使用Swift进行编程。</p><p>当然，Swift的严谨使得它失去部分的灵活性，OC在灵活性上比Swift卓越。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210226162513.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;嗯，先来一段感慨&quot;&gt;&lt;a href=&quot;#嗯，先来一段感慨&quot; class=&quot;headerlink&quot; title=&quot;嗯，先来一段感慨&quot;&gt;&lt;/a&gt;嗯，先来一段感慨&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;对于Swift学习而言，可选类型Optional是永远绕不过的坎，特别是从OC刚刚转Swift的时候，可能就会被代码行间的?与!，有的时候甚至是??搞得稀里糊涂的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇文章会给各位带来我对于可选类型的一些认识以及如何进行解包，其中会涉及到Swift中&lt;em&gt;&lt;strong&gt;if let&lt;/strong&gt;&lt;/em&gt;以及&lt;strong&gt;&lt;em&gt;guard let&lt;/em&gt;&lt;/strong&gt;的使用以及思考，还有涉及OC部分的&lt;em&gt;&lt;strong&gt;nullable&lt;/strong&gt;&lt;/em&gt;和&lt;em&gt;&lt;strong&gt;nonnull&lt;/strong&gt;&lt;/em&gt;两个关键字，以及一点点对两种语言的思考。&lt;/p&gt;
&lt;h1 id=&quot;var-num-Int-它是什么类型&quot;&gt;&lt;a href=&quot;#var-num-Int-它是什么类型&quot; class=&quot;headerlink&quot; title=&quot;var num: Int? 它是什么类型?&quot;&gt;&lt;/a&gt;var num: Int? 它是什么类型?&lt;/h1&gt;&lt;p&gt;在进行解包前，我们先来理解一个概念，这样可能更有利于对于解包。&lt;/p&gt;
&lt;p&gt;首先我们来看看这样一段代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt; `var num: Int?

  num = 10

  if num is Optional&amp;lt;Int&amp;gt; {

   print(&amp;quot;它是Optional类型&amp;quot;)

  }else {

    print(&amp;quot;它是Int类型&amp;quot;)

  }`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请先暂时不要把这段代码复制到Xcode中，先自问自答，num是什么类型，是Int类型吗?&lt;/p&gt;
&lt;p&gt;好了，你可以将这段代码复制到Xcode里去了，然后在Xcode中的if上一定会出现这样一段话：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS Development" scheme="http://www.jifu.io/categories/iOS-Development/"/>
    
    
      <category term="Swift" scheme="http://www.jifu.io/tags/Swift/"/>
    
      <category term="解包" scheme="http://www.jifu.io/tags/%E8%A7%A3%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>macOS 下 FFmpeg 视频转码入门及进阶使用心得</title>
    <link href="http://www.jifu.io/posts/2652542772/"/>
    <id>http://www.jifu.io/posts/2652542772/</id>
    <published>2021-02-23T07:38:50.000Z</published>
    <updated>2021-02-28T13:25:18.351Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223204447.png" alt=""></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>如今较为常见的视频封装格式有 <code>mp4</code> 和 <code>mkv</code> 等， 内部的视频编码格式从前几年盛行的 <code>H.264</code>/<code>x264</code> 逐渐开始向新一代的 <code>HEVC/x265</code>（ High Efficiency Video Coding 高效视频编码）过渡，而常见的音频编码格式无非 AC3、DTS 或者 AAC 等。无论是借助带有 GUI 的编码软件，还是使用命令行，FFmpeg 是最为广泛使用的工具，理论上 FFmpeg 支持各个平台，包括 Windows、macOS、iOS 以及 Android 等，这里只介绍在 macOS 下的使用。通过简单的命令，你可以大致了解 FFmpeg 在视频转换上的强大之处，视频编码部分也集中在 x264、x265，以及如何压制 macOS High Sierra 和 iOS 11 可以正确识别并生成缩略图的 HEVC 10bit 视频。最后会用一个较为复杂的例子，应用 -filter_complex 进行视频帧率的插值运算、嵌入 pgs 图形字幕，以及最后输出 HEVC 编码进行说明。</p><h1 id="FFmpeg安装"><a href="#FFmpeg安装" class="headerlink" title="FFmpeg安装"></a>FFmpeg安装</h1><p>如果有看过我以前文章的朋友，可能会注意到使用 Homebrew 编译 mpv 的一个重要依赖就是 FFmpeg。不过，如果将其用作视频转码，默认编译的 FFmpeg 会缺少一部分组件，因此这里可能需要重新安装 FFmpeg。以我个人编译版本为例，使用 –HEAD 来配合最新的 mpv，在 Terminal 中输入如下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">brew <span class="token function">install</span> ffmpeg --HEAD --with-fdk-aac --with-sdl2 --with-freetype --with-libass --with-libbluray --with-libvorbis --with-libvpx --with-opus --with-webp --with-x265<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待安装结束即可。</p><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="压制-x264-编码视频文件"><a href="#压制-x264-编码视频文件" class="headerlink" title="压制 x264 编码视频文件"></a>压制 x264 编码视频文件</h2><pre class="line-numbers language-bash"><code class="language-bash">ffmpeg -i input.mp4 -c:a libfdk_aac -c:v libx264 -crf 20 -preset slow output.mp4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 FFmpeg 编码的基本规则， -i 之后的文件为输入的视频文件，即 input.mp4 ，支持的格式众多，例如 mkv、flv、vob 等等，文件可以包含目录，使用 macOS 的文件拖拽功能很方便。output.mp4 即为输出文件，文件名可自定义，视频封装格式建议对应编码格式，不应将 mpeg-2 或者 vp8 编码的视频也封装为 mp4。-c:a 之后表示输出文件的音频编码器，一般 mp4 常用的音频编码为 AAC-LC，按照官方 Wiki 指南，建议使用编码器 <code>libfdk_aac</code> 而不是 aac，libfdk_aac 音质更好，这也是为什么在前文中编译 FFmpeg 增加 –with-fdk-aac 的原因。<code>-c:v</code> 之后代表输出文件的视频编码器，使用 <code>libx264</code> 即可压制 x264 编码的视频流。<code>-crf 20</code> 代表视频编码的码率系数，数字越大，压制的效果越差，建议选择范围在 16 - 28，压制高质量的视频建议取值 20 以下。<code>-preset slow</code> 代表一组控制压缩时间和文件大小的参数选择，一般常选 fast、medium 和 slow。</p><p>以上都是基于 <code>one-pass</code> 压制，如果需要严格控制码率则需要使用 <code>two-pass</code>，更详细的介绍，可以参考 Encode / H.264。</p><h2 id="压制-HEVC-10bit-编码视频文件"><a href="#压制-HEVC-10bit-编码视频文件" class="headerlink" title="压制 HEVC 10bit 编码视频文件"></a>压制 HEVC 10bit 编码视频文件</h2><a id="more"></a><p>其实 FFmpeg 很早就开始支持 HEVC (x265) 的视频转码，只是一直改动较大，而最近的版本也终于支持编码 macOS High Sierra 下 Quicktime 可以播放，并且在系统中能够正确预览并生成缩略图的视频文件。编码命令的改动很小，添加一个 format tag 参数即可，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">ffmpeg -i input.mp4 \       -c:v libx265 -preset medium -crf 18 -pix_fmt yuv420p10le \       -c:a libfdk_aac -b:a 256k \       -tag:v hvc1 \       output_10bit.mp4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和压制 x264 视频非常类似，主要的不同点在于 -c:v 视频编码器需换为 libx265，并且压制 10bit 需要指定色彩空间，添加 -pix_fmt yuv420p10le。在音频编码参数中，如何增加的 -b:a，可以控制音频文件的码率，按需使用。最后，非常重要的一点，必须添加参数 tag:v hvc1，这样输出的 Video Stream 会被标记为 hvc1，可以被 macOS 以及 iOS 11 原生支持播放，否则默认会被标记为 hev1，不被原生支持，第三方播放器播放倒没什么问题。</p><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="修改视频分辨率"><a href="#修改视频分辨率" class="headerlink" title="修改视频分辨率"></a>修改视频分辨率</h2><p>假如原视频的分辨率为 1920x1080，为了降低文件大小，最简单的办法是将其转压成一个分辨率较低的版本，例如 720p，即 1280x720，那么我们可以使用 scale 视频滤镜来缩放视频：</p><pre class="line-numbers language-bash"><code class="language-bash">ffmpeg -i input.mp4 -vf scale<span class="token operator">=</span>-2:720 -c:v libx264 -crf 20 -preset slow -c:a copy output.mp4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-vf scale=-2:720</code> 会自动计算对应的横向分辨率（需为 2 的倍数，因此为 -2 ），源文件音频编码保持不变，因此设为 copy 即可。特殊情况下，遇到源文件视频比例错误，除了修改分辨率数值，还需要设置 dar 参数，例如：</p><pre class="line-numbers language-bash"><code class="language-bash">ffmpeg -i input.avi -vf scale<span class="token operator">=</span>722x406,setdar<span class="token operator">=</span>16/9 -c:v libx264 -c:a libfdk_aac -preset slow -crf 20 output.mp4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外，绝对不建议增大分辨率，因为毫无意义，受限于原视频的视频质量，增大分辨率除了体积增大，画质只会更差。</p><h2 id="反交错（-Deinterlace-）"><a href="#反交错（-Deinterlace-）" class="headerlink" title="反交错（ Deinterlace ）"></a>反交错（ Deinterlace ）</h2><p>偶尔我会遇到一些早期使用 VCD/DVD 时代编码的视频，其中一个重要的特点就是隔行扫描，而直接转码的结果就是视频中快速运动的物体都能看到非常明显的扫描线。解决办法同样需要应用 vf 视频滤镜中的 yadif 来进行反交错，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">ffmpeg -i input.vob -vf yadif -c:v libx264 -preset slow -crf 20 -c:a libfdk_aac -b:a 256k output.mp4如果压制出来的效果不佳（还是有扫描线），可以尝试将 vf 的部分改为 -vf yadif<span class="token operator">=</span>1:-1:0,mcdeint<span class="token operator">=</span>2:1:10。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="旋转视频"><a href="#旋转视频" class="headerlink" title="旋转视频"></a>旋转视频</h2><p>需要将原视频进行旋转，同样可以应用视频滤镜来达到目的，如下：</p><pre class="line-numbers language-bash"><code class="language-bash">ffmpeg -i input.mov -vf <span class="token string">"transpose=1"</span> -c:a copy output.mov<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，</p><ul><li>0 = 90 Counter Clockwise and Vertical Flip  (default)</li><li>1 = 90 Clockwise</li><li>2 = 90 Counter Clockwise</li><li>3 = 90 Clockwise and Vertical Flip</li></ul><p>如果想要 180 度翻转视频，则需要改为 -vf “transpose=2,transpose=2”。值得注意的是，旋转视频意味着对视频进行重编码，输出质量会稍微受到影响，可以添加 crf 参数控制视频输出质量，音频部分可以使用 copy。</p><h2 id="一个复杂的“栗子”"><a href="#一个复杂的“栗子”" class="headerlink" title="一个复杂的“栗子”"></a>一个复杂的“栗子”</h2><p>最后的这个例子，是我最近遇到的一个视频，简要的编码信息如下：</p><pre class="line-numbers language-bash"><code class="language-bash">Input <span class="token comment" spellcheck="true">#0, matroska,webm, from 'Input.mkv':</span>    Duration: 00:23:55.97, start: 0.000000, bitrate: 16372 kb/s    Stream <span class="token comment" spellcheck="true">#0:0: Video: hevc (Main 10), yuv420p10le(tv, bt709), 1920x1080, SAR 1:1 DAR 16:9, 59.94 fps, 59.94 tbr, 1k tbn, 59.94 tbc (default)</span>    Stream <span class="token comment" spellcheck="true">#0:1(jpn): Audio: flac, 48000 Hz, stereo, s32 (24 bit) (default)</span>    Stream <span class="token comment" spellcheck="true">#0:2(jpn): Audio: flac, 48000 Hz, stereo, s32 (24 bit)</span>    Stream <span class="token comment" spellcheck="true">#0:3(chi): Subtitle: hdmv_pgs_subtitle (default)</span>    Stream <span class="token comment" spellcheck="true">#0:4(chi): Subtitle: hdmv_pgs_subtitle</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，这是一个 HEVC 10bit 编码，分辨率 1080p，帧率 59.94 fps 的视频文件，带有两条 flac 编码的音轨，另有两条是 pgs 格式的图形字幕。我自己的 Macbook Pro 已经无法完全流畅地播放这个视频了，除了 HEVC 带来的巨大计算量，高帧率也是一个麻烦，可惜网上没有其它好的片源，因此，我只有自己尝试压缩。目标：维持分辨率但帧率减半，即降为 29. 97 fps，音轨只需要第一条，并且重编码为 AAC-LC，原片为日语，因此必须带有字幕，图形字幕直接嵌入视频，最后以 HEVC 10bit 重编码，少许降低码率。</p><p>改变帧率普遍会使用 -vf fps=fps=29.97 这类的参数，但自己尝试后发现一个问题，视频观看的感觉有跳跃性，不流畅，很像是丢帧的感觉。因为将帧率减半，意味着有一半的信息都丢弃了，而普通降低帧率的算法只有简单的插值运算甚至完全没有，造成了视频不连贯的效果。因此，改变帧率正确的做法是进行运动插值运算（ Motion Interpolation ），此法既可用在提高帧率上，也可以用于降低帧率，最终的结果都是提高视频播放的流畅度。这里会使用 -filter_complex 代替 vf，联合应用 minterpolate、overlay 以及 map 来解决帧率、嵌入视频，和保留一条音轨的问题。压制命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">ffmpeg -i input.mkv \-filter_complex <span class="token string">"[0:v]minterpolate='fps=29.97:mi_mode=mci:me_mode=bidir:mc_mode=aobmc:vsbmc=1'[bg],[bg][0:s:0]overlay[v]"</span> -map <span class="token string">"[v]"</span> -map 0:a:0 \-c:v libx265 -preset medium -crf 18 -pix_fmt yuv420p10le \-c:a libfdk_aac -b:a 256k \-tag:v hvc1 \output_10bit.mp4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里看起来会很复杂，实际上 -filter_complex 的工作模式就像是 pipe，[0:v] 表示输入文件的视频流，对应 Stream #0:0。从 minterpolate 到 vsbmc=1 都是插补滤镜的设置参数，具体的作用可以查看官方文档。[bg]代表该滤镜输出后的视频流，并传递给下一个滤镜 overlay。[0:s:0]表示输入文件的第一个字幕通，对应 Stream #0:3，所以如果是 [0:s:1] 则对应 Stream #0:4。 overlay 就会将该图形字幕嵌入到视频中，然后输出为 [v]，进行 mapping。视频取处理后的 [v]，音频取原输入文件的第一个音频通道，[0:a:0] 即代表 Stream #0:1。最后和此前压制视频的参数就一模一样了，压制为 HEVC 10bit 编码的视频文件。</p><p>需要注意的是，运动插值运算非常耗时，CPU 占用确不高，应该是 minterpolate 滤镜只能调用单核的缘故。在我的电脑上， 此 23 分钟左右的视频压制一次耗时约 20 小时，请谨慎使用。</p><h2 id="补充-用来自动切黑边的脚本"><a href="#补充-用来自动切黑边的脚本" class="headerlink" title="补充 - 用来自动切黑边的脚本"></a>补充 - 用来自动切黑边的脚本</h2><p>有时候碰到比较懒的小组发的片源，连黑边都不切，这样外挂字幕就跑到黑边去了，我很不喜欢……. 保存代码为 crop-border.sh 并修改权限，用法：./crop-border.sh input.mp4 output.mp4</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># autodetect crop size</span>crop<span class="token operator">=</span>`ffmpeg -i <span class="token variable">$1</span> -t 1 -vf cropdetect -f null - 2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'/crop/ { print <span class="token variable">$NF</span> }'</span> <span class="token operator">|</span> <span class="token function">tail</span> -1`<span class="token keyword">echo</span> <span class="token string">"detected crop fromat:    <span class="token variable">$crop</span>"</span><span class="token keyword">echo</span> <span class="token string">"input:            <span class="token variable">$1</span>"</span><span class="token keyword">echo</span> <span class="token string">"output:            <span class="token variable">$2</span>"</span><span class="token function">date</span> <span class="token punctuation">;</span> <span class="token function">read</span> -t 5 -p <span class="token string">"Hit ENTER or wait five seconds"</span> <span class="token punctuation">;</span> <span class="token function">date</span>ffmpeg -i <span class="token variable">$1</span> -c:a copy -c:v libx265 -preset medium -crf 18 -pix_fmt yuv420p10le -tag:v hvc1 -vf <span class="token variable">$crop</span> -y <span class="token variable">$2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>压制的参数 <code>-c:a</code> 和 <code>-c:v</code> 部分还需调整</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223204447.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;如今较为常见的视频封装格式有 &lt;code&gt;mp4&lt;/code&gt; 和 &lt;code&gt;mkv&lt;/code&gt; 等， 内部的视频编码格式从前几年盛行的 &lt;code&gt;H.264&lt;/code&gt;/&lt;code&gt;x264&lt;/code&gt; 逐渐开始向新一代的 &lt;code&gt;HEVC/x265&lt;/code&gt;（ High Efficiency Video Coding 高效视频编码）过渡，而常见的音频编码格式无非 AC3、DTS 或者 AAC 等。无论是借助带有 GUI 的编码软件，还是使用命令行，FFmpeg 是最为广泛使用的工具，理论上 FFmpeg 支持各个平台，包括 Windows、macOS、iOS 以及 Android 等，这里只介绍在 macOS 下的使用。通过简单的命令，你可以大致了解 FFmpeg 在视频转换上的强大之处，视频编码部分也集中在 x264、x265，以及如何压制 macOS High Sierra 和 iOS 11 可以正确识别并生成缩略图的 HEVC 10bit 视频。最后会用一个较为复杂的例子，应用 -filter_complex 进行视频帧率的插值运算、嵌入 pgs 图形字幕，以及最后输出 HEVC 编码进行说明。&lt;/p&gt;
&lt;h1 id=&quot;FFmpeg安装&quot;&gt;&lt;a href=&quot;#FFmpeg安装&quot; class=&quot;headerlink&quot; title=&quot;FFmpeg安装&quot;&gt;&lt;/a&gt;FFmpeg安装&lt;/h1&gt;&lt;p&gt;如果有看过我以前文章的朋友，可能会注意到使用 Homebrew 编译 mpv 的一个重要依赖就是 FFmpeg。不过，如果将其用作视频转码，默认编译的 FFmpeg 会缺少一部分组件，因此这里可能需要重新安装 FFmpeg。以我个人编译版本为例，使用 –HEAD 来配合最新的 mpv，在 Terminal 中输入如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;brew install ffmpeg --HEAD --with-fdk-aac --with-sdl2 --with-freetype --with-libass --with-libbluray --with-libvorbis --with-libvpx --with-opus --with-webp --with-x265
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等待安装结束即可。&lt;/p&gt;
&lt;h1 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇&quot;&gt;&lt;/a&gt;基础篇&lt;/h1&gt;&lt;h2 id=&quot;压制-x264-编码视频文件&quot;&gt;&lt;a href=&quot;#压制-x264-编码视频文件&quot; class=&quot;headerlink&quot; title=&quot;压制 x264 编码视频文件&quot;&gt;&lt;/a&gt;压制 x264 编码视频文件&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;ffmpeg -i input.mp4 -c:a libfdk_aac -c:v libx264 -crf 20 -preset slow output.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 FFmpeg 编码的基本规则， -i 之后的文件为输入的视频文件，即 input.mp4 ，支持的格式众多，例如 mkv、flv、vob 等等，文件可以包含目录，使用 macOS 的文件拖拽功能很方便。output.mp4 即为输出文件，文件名可自定义，视频封装格式建议对应编码格式，不应将 mpeg-2 或者 vp8 编码的视频也封装为 mp4。-c:a 之后表示输出文件的音频编码器，一般 mp4 常用的音频编码为 AAC-LC，按照官方 Wiki 指南，建议使用编码器 &lt;code&gt;libfdk_aac&lt;/code&gt; 而不是 aac，libfdk_aac 音质更好，这也是为什么在前文中编译 FFmpeg 增加 –with-fdk-aac 的原因。&lt;code&gt;-c:v&lt;/code&gt; 之后代表输出文件的视频编码器，使用 &lt;code&gt;libx264&lt;/code&gt; 即可压制 x264 编码的视频流。&lt;code&gt;-crf 20&lt;/code&gt; 代表视频编码的码率系数，数字越大，压制的效果越差，建议选择范围在 16 - 28，压制高质量的视频建议取值 20 以下。&lt;code&gt;-preset slow&lt;/code&gt; 代表一组控制压缩时间和文件大小的参数选择，一般常选 fast、medium 和 slow。&lt;/p&gt;
&lt;p&gt;以上都是基于 &lt;code&gt;one-pass&lt;/code&gt; 压制，如果需要严格控制码率则需要使用 &lt;code&gt;two-pass&lt;/code&gt;，更详细的介绍，可以参考 Encode / H.264。&lt;/p&gt;
&lt;h2 id=&quot;压制-HEVC-10bit-编码视频文件&quot;&gt;&lt;a href=&quot;#压制-HEVC-10bit-编码视频文件&quot; class=&quot;headerlink&quot; title=&quot;压制 HEVC 10bit 编码视频文件&quot;&gt;&lt;/a&gt;压制 HEVC 10bit 编码视频文件&lt;/h2&gt;
    
    </summary>
    
      <category term="OPS" scheme="http://www.jifu.io/categories/OPS/"/>
    
      <category term="MacOS" scheme="http://www.jifu.io/categories/OPS/MacOS/"/>
    
    
      <category term="MacOS" scheme="http://www.jifu.io/tags/MacOS/"/>
    
      <category term="FFmpeg" scheme="http://www.jifu.io/tags/FFmpeg/"/>
    
      <category term="视频转码" scheme="http://www.jifu.io/tags/%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81/"/>
    
      <category term="H.265" scheme="http://www.jifu.io/tags/H-265/"/>
    
  </entry>
  
  <entry>
    <title>为远程桌面启用Windows防火墙例外</title>
    <link href="http://www.jifu.io/posts/3669230936/"/>
    <id>http://www.jifu.io/posts/3669230936/</id>
    <published>2021-02-23T07:26:36.000Z</published>
    <updated>2021-02-28T13:25:18.351Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223203336.jpg" alt=""></p><h1 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h1><p>装完系统后在“远程设置处”设置为允许连接到计算机，但是上面有一个警告“必须为远程桌面启用Windows防火墙例外”。</p><p>就是没有获得防火墙的允许权限。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223202902.png" alt=""></p><p>于是打开防火墙：控制面板—–Windows 防火墙—–允许的程序：</p><a id="more"></a><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223202918.png" alt=""></p><p>发现防火墙允许的程序中确实没有“远程桌面”，而虽然用户已是管理员身份，但“更改设置”按钮不可用：</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223202935.png" alt=""></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="打开本地组策略编辑器"><a href="#打开本地组策略编辑器" class="headerlink" title="打开本地组策略编辑器"></a>打开本地组策略编辑器</h2><p>开始—— &gt; 运行—– &gt; gpedit.msc</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223202952.png" alt=""></p><h2 id="启用Windows防火墙允许入站远程桌面例外"><a href="#启用Windows防火墙允许入站远程桌面例外" class="headerlink" title="启用Windows防火墙允许入站远程桌面例外"></a>启用Windows防火墙允许入站远程桌面例外</h2><p>打开“本地组策略编辑器”，按如下设置：计算机配置—–&gt;管理模板—–&gt;网络—–&gt;网络连接—–&gt;Windows防火墙—–&gt;标准配置文件—–&gt;Windows防火墙允许入站远程桌面例外（默认为未配置），选择“<strong>已启用</strong>”，并在下面的IP地址框中输入*号（可根据需要添加相应的IP）</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223203020.png" alt=""></p><h2 id="打开防火墙策略"><a href="#打开防火墙策略" class="headerlink" title="打开防火墙策略"></a>打开防火墙策略</h2><p>设置完后，发现Windows防火墙允许的程序中已有了“远程桌面”，当然原先的警告“必须为远程桌面启用Windows防火墙例外”也已消失</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223203035.png" alt=""></p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223203051.png" alt=""></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>进行连接测试，连接界面可以出来，输入正确的用户名密码，连接时却出现“您的凭据不工作”的错误，还是无法连接</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223203101.png" alt=""></p><h3 id="凭证不工作解决方法"><a href="#凭证不工作解决方法" class="headerlink" title="凭证不工作解决方法"></a>凭证不工作解决方法</h3><p>再次进入“本地组策略编辑器”，进行如下设置：计算机配置—–&gt;管理模板—–&gt;系统—–&gt;凭据分配—–&gt;允许分配保存的凭据用于仅NTLM服务器身份验证，选择已启用，显示—–&gt;输入：“TERMSRV/*”。（确保 TERMSRV 为大写）</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223203134.png" alt=""></p><h2 id="重启电脑"><a href="#重启电脑" class="headerlink" title="重启电脑"></a>重启电脑</h2><h2 id="测试成功"><a href="#测试成功" class="headerlink" title="测试成功"></a>测试成功</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223203336.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题介绍&quot;&gt;&lt;a href=&quot;#问题介绍&quot; class=&quot;headerlink&quot; title=&quot;问题介绍&quot;&gt;&lt;/a&gt;问题介绍&lt;/h1&gt;&lt;p&gt;装完系统后在“远程设置处”设置为允许连接到计算机，但是上面有一个警告“必须为远程桌面启用Windows防火墙例外”。&lt;/p&gt;
&lt;p&gt;就是没有获得防火墙的允许权限。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223202902.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;于是打开防火墙：控制面板—–Windows 防火墙—–允许的程序：&lt;/p&gt;
    
    </summary>
    
      <category term="OPS" scheme="http://www.jifu.io/categories/OPS/"/>
    
      <category term="Windows" scheme="http://www.jifu.io/categories/OPS/Windows/"/>
    
    
      <category term="Windows" scheme="http://www.jifu.io/tags/Windows/"/>
    
      <category term="防火墙" scheme="http://www.jifu.io/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
      <category term="远程桌面" scheme="http://www.jifu.io/tags/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>高性能 Nginx HTTPS 调优 - 如何为 HTTPS 提速 30%</title>
    <link href="http://www.jifu.io/posts/1350143519/"/>
    <id>http://www.jifu.io/posts/1350143519/</id>
    <published>2021-02-23T07:11:15.000Z</published>
    <updated>2021-02-28T13:25:18.351Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223202509.png" alt=""></p><h1 id="为什么要优化-Nginx-HTTPS-延迟"><a href="#为什么要优化-Nginx-HTTPS-延迟" class="headerlink" title="为什么要优化 Nginx HTTPS 延迟"></a>为什么要优化 Nginx HTTPS 延迟</h1><p>  Nginx 常作为最常见的服务器，常被用作负载均衡 (Load Balancer)、反向代理 (Reverse Proxy)，以及网关 (Gateway) 等等。一个配置得当的 Nginx 服务器单机应该可以期望承受住 50K 到 80K 左右每秒的请求，同时将 CPU 负载在可控范围内。 但在很多时候，负载并不是需要首要优化的重点。比如对于卡拉搜索来说，我们希望用户在每次击键的时候，可以体验即时搜索的感觉，也就是说，每个搜索请求必须在 100ms - 200ms 的时间内端对端地返回给用户，才能让用户搜索时没有“卡顿”和“加载”。因此，对于我们来说，优化请求延迟才是最重要的优化方向。</p><p>这篇文章中，我们先介绍 Nginx 中的 TLS 设置有哪些与请求延迟可能相关，如何调整才能最大化加速。然后我们用优化卡拉搜索 Nginx 服务器的实例来分享如何调整 Nginx TLS/SSL 设置，为首次搜索的用户提速 30% 左右。我们会详细讨论每一步我们做了一些什么优化，优化的动机和效果。希望可以对其它遇到类似问题的同学提供帮助。 照例，本文的 Nginx 设置文件放置于 github，欢迎直接使用: 高性能 Nginx HTTPS 调优(<a href="https://github.com/Kalasearch/high-performance-nginx-tls-tuning" target="_blank" rel="noopener">https://github.com/Kalasearch/high-performance-nginx-tls-tuning</a>)</p><h1 id="TLS-握手和延迟"><a href="#TLS-握手和延迟" class="headerlink" title="TLS 握手和延迟"></a>TLS 握手和延迟</h1><p>  很多时候开发者会认为：如果不是绝对在意性能，那么了解底层和更细节的优化没有必要。这句话在很多时候是恰当的，因为很多时候复杂的底层逻辑必须包起来，才能让更高层的应用开发复杂度可控。比如说，如果你就只需要开发一个 APP 或者网站，可能并没有必要关注汇编细节，关注编译器如何优化你的代码——毕竟在苹果或者安卓上很多优化在底层就做好了。 那么，了解底层的 TLS 和应用层的 Nginx 延迟优化有什么关系呢？ 答案是多数情况下，优化网络延迟其实是在尝试减少用户和服务器之间的数据传输次数，也就是所谓的 roundtrip。由于物理限制，北京到云南的光速传播差不多就是要跑 20 来毫秒，如果你不小心让数据必须多次往返于北京和云南之间，那么必然延迟就上去了。 因此如果你需要优化请求延迟，那么了解一点底层网络的上下文则会大有裨益，很多时候甚至是你是否可以轻松理解一个优化的关键。本文中我们不深入讨论太多 TCP 或者 TLS 机制的细节，如果有兴趣的话请参考 High Performance Browser Networking 一书。 举个例子，下图中展示了如果你的服务启用了 HTTPS，在开始传输任何数据之前的数据传输情况。 <img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223201646.png" alt="">     可以看到，在你的用户拿到他需要的数据前，底层的数据包就已经在用户和你的服务器之间跑了 3 个来回。 假设每次来回需要 28 毫秒的话，用户已经等了 224 毫秒之后才开始接收数据。 同时这个 28 毫秒其实是非常乐观的假设，在国内电信、联通和移动以及各种复杂的网络状况下，用户与服务器之间的延迟更不可控。另一方面，通常一个网页需要数十个请求，这些请求不一定可以全部并行，因此几十乘以 224 毫秒，页面打开可能就是数秒之后了。 所以，原则上如果可能的话，我们需要尽量减少用户和服务器之间的往返程 (roundtrip)，在下文的设置中，对于每个设置我们会讨论为什么这个设置有可能帮助减少往返程。</p><h1 id="Nginx-中的-TLS-设置"><a href="#Nginx-中的-TLS-设置" class="headerlink" title="Nginx 中的 TLS 设置"></a>Nginx 中的 TLS 设置</h1><p>  那么在 Nginx 设置中，怎样调整参数会减少延迟呢？</p><a id="more"></a><h2 id="开启-HTTP-2"><a href="#开启-HTTP-2" class="headerlink" title="开启 HTTP/2"></a>开启 HTTP/2</h2><p>HTTP/2 标准是从 Google 的 SPDY 上进行的改进，比起 HTTP 1.1 提升了不少性能，尤其是需要并行多个请求的时候可以显著减少延迟。在现在的网络上，一个网页平均需要请求几十次，而在 HTTP 1.1 时代浏览器能做的就是多开几个连接（通常是 6 个）进行并行请求，而 HTTP 2 中可以在一个连接中进行并行请求。HTTP 2 原生支持多个并行请求，因此大大减少了顺序执行的请求的往返程，可以首要考虑开启。 如果你想自己看一下 HTTP 1.1 和 HTTP 2.0 的速度差异，可以试一下：<a href="https://www.httpvshttps.com/。我的网络测试下来" target="_blank" rel="noopener">https://www.httpvshttps.com/。我的网络测试下来</a> HTTP/2 比 HTTP 1.1 快了 66%。 <img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223201836.png" alt="">在 Nginx 中开启 HTTP 2.0 非常简单，只需要增加一个 http2 标志即可</p><pre class="line-numbers language-bash"><code class="language-bash">listen 443 ssl<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 改为</span>listen 443 ssl http2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你担心你的用户用的是旧的客户端，比如 Python 的 requests，暂时还不支持 HTTP 2 的话，那么其实不用担心。如果用户的客户端不支持 HTTP 2，那么连接会自动降级为 HTTP 1.1，保持了后向兼容。因此，所有使用旧 Client 的用户，仍然不受影响，而新的客户端则可以享受 HTTP/2 的新特性。</p><h2 id="如何确认你的网站或者-API-开启了-HTTP-2"><a href="#如何确认你的网站或者-API-开启了-HTTP-2" class="headerlink" title="如何确认你的网站或者 API 开启了 HTTP 2"></a>如何确认你的网站或者 API 开启了 HTTP 2</h2><p>在 Chrome 中打开开发者工具，点开 Protocol 之后在所有的请求中都可以看到请求用的协议了。如果 protocol 这列的值是 h2 的话，那么用的就是 HTTP 2 了 <img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223201917.png" alt=""> 当然另一个办法是直接用 curl 如果返回的 status 前有 HTTP/2 的话自然也就是 HTTP/2 开启了。</p><pre class="line-numbers language-bash"><code class="language-bash">➜  ~ curl --http2 -I https://kalasearch.cnHTTP/2 403server: Tenginecontent-type: application/xmlcontent-length: 264date: Tue, 22 Dec 2020 18:38:46 GMTx-oss-request-id: 5FE23D363ADDB93430197043x-oss-cdn-auth: successx-oss-server-time: 0x-alicdn-da-ups-status: endOs,0,403via: cache13.l2et2<span class="token punctuation">[</span>148,0<span class="token punctuation">]</span>, cache10.l2ot7<span class="token punctuation">[</span>291,0<span class="token punctuation">]</span>, cache4.us13<span class="token punctuation">[</span>360,0<span class="token punctuation">]</span>timing-allow-origin: *eagleid: 2ff6169816086623266688093e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="调整-Cipher-优先级"><a href="#调整-Cipher-优先级" class="headerlink" title="调整 Cipher 优先级"></a>调整 Cipher 优先级</h2><p>尽量挑选更新更快的 Cipher，有助于减少延迟:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 手动启用 cipher 列表</span>ssl_prefer_server_ciphers on<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># prefer a list of ciphers to prevent old and slow ciphers</span>ssl_ciphers <span class="token string">'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="启用-OCSP-Stapling"><a href="#启用-OCSP-Stapling" class="headerlink" title="启用 OCSP Stapling"></a>启用 OCSP Stapling</h2><p>在国内这可能是对使用 Let’s Encrypt 证书的服务或网站影响最大的延迟优化了。如果不启用 OCSP Stapling 的话，在用户连接你的服务器的时候，有时候需要去验证证书。而因为一些不可知的原因（这个就不说穿了）Let’s Encrypt 的验证服务器并不是非常通畅，因此可以造成有时候数秒甚至十几秒延迟的问题，这个问题在 iOS 设备上特别严重 解决这个问题的方法有两个：</p><ol><li>不使用 Let’s Encrypt，可以尝试替换为阿里云提供的免费 DV 证书</li><li>开启 OCSP Stapling</li></ol><p>开启了 OCSP Stapling 的话，跑到证书验证这一步可以省略掉。省掉一个 roundtrip，特别是网络状况不可控的 roundtrip，可能可以将你的延迟大大减少。 在 Nginx 中启用 OCSP Stapling 也非常简单，只需要设置：</p><pre class="line-numbers language-bash"><code class="language-bash">ssl_stapling on<span class="token punctuation">;</span>ssl_stapling_verify on<span class="token punctuation">;</span>ssl_trusted_certificate /path/to/full_chain.pem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="如何检测-OCSP-Stapling-是否已经开启？"><a href="#如何检测-OCSP-Stapling-是否已经开启？" class="headerlink" title="如何检测 OCSP Stapling 是否已经开启？"></a>如何检测 OCSP Stapling 是否已经开启？</h2><p>可以通过以下命令</p><pre class="line-numbers language-bash"><code class="language-bash">openssl s_client -connect test.kalasearch.cn:443 -servername kalasearch.cn -status -tlsextdebug <span class="token operator">&lt;</span> /dev/null 2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">|</span> <span class="token function">grep</span> -i <span class="token string">"OCSP response"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来测试。如果结果为</p><pre class="line-numbers language-bash"><code class="language-bash">OCSP response:OCSP Response Data:    OCSP Response Status: successful <span class="token punctuation">(</span>0x0<span class="token punctuation">)</span>    Response Type: Basic OCSP Response<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>则表明已经开启。参考 HTTPS 在 iPhone 上慢的问题 一文</p><h2 id="调整-ssl-buffer-size"><a href="#调整-ssl-buffer-size" class="headerlink" title="调整 ssl_buffer_size"></a>调整 ssl_buffer_size</h2><p>sslbuffersize 控制在发送数据时的 buffer 大小，默认设置是 16k。这个值越小，则延迟越小，而添加的报头之类会使 overhead 会变大，反之则延迟越大，overhead 越小。 因此如果你的服务是 REST API或者网站的话，将这个值调小可以减小延迟和 TTFB，但如果你的服务器是用来传输大文件的，那么可以维持 16k。关于这个值的讨论和更通用的 TLS Record Size 的讨论，可以参考：Best value for nginx’s sslbuffersize option 如果是网站或者 REST API，建议值为 4k，但是这个值的最佳取值显然会因为数据的不同而不一样，因此请尝试 2 - 16k 间不同的值。在 Nginx 中调整这个值也非常容易</p><pre class="line-numbers language-bash"><code class="language-bash">ssl_buffer_size 4k<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="启用-SSL-Session-缓存"><a href="#启用-SSL-Session-缓存" class="headerlink" title="启用 SSL Session 缓存"></a>启用 SSL Session 缓存</h2><p>启用 SSL Session 缓存可以大大减少 TLS 的反复验证，减少 TLS 握手的 roundtrip。虽然 session 缓存会占用一定内存，但是用 1M 的内存就可以缓存 4000 个连接，可以说是非常非常划算的。同时，对于绝大多数网站和服务，要达到 4000 个同时连接本身就需要非常非常大的用户基数，因此可以放心开启。 这里 ssl_session_cache 设置为使用 50M 内存，以及 4 小时的连接超时关闭时间 ssl_session_timeout</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Enable SSL cache to speed up for return visitors</span>ssl_session_cache   shared:SSL:50m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># speed up first time. 1m ~= 4000 connections</span>ssl_session_timeout 4h<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="卡拉搜索如何减少-30-的请求延迟"><a href="#卡拉搜索如何减少-30-的请求延迟" class="headerlink" title="卡拉搜索如何减少 30% 的请求延迟"></a>卡拉搜索如何减少 30% 的请求延迟</h1><p>  卡拉搜索是国内的 Algolia，致力于帮助开发者快速搭建即时搜索功能(instant search)，做国内最快最易用的搜索即服务。 开发者接入后，所有搜索请求通过卡拉 API 即可直接返回给终端用户。为了让用户有即时搜索的体验，我们需要在用户每次击键后极短的时间内（通常是 100ms 到 200ms）将结果返回给用户。因此每次搜索需要可以达到 50 毫秒以内的引擎处理时间和 200 毫秒以内的端对端时间。</p><blockquote><p>我们用豆瓣电影的数据做了一个电影搜索的 Demo，如果感兴趣的话欢迎体验一下即时搜索，尝试一下搜索“无间道”或者“大话西游”体验一下速度和相关度：<a href="https://movies-demo.kalasearch.cn/" target="_blank" rel="noopener">https://movies-demo.kalasearch.cn/</a></p></blockquote><p>对于每个请求只有 100 到 200 毫秒的延迟预算，我们必须把每一步的延迟都考虑在内。 简化一下，每个搜索请求需要经历的延迟有 <img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223202216.png" alt=""> 总延迟 = 用户请求到达服务器(T1) + 反代处理(Nginx T2) + 数据中心延迟(T3) + 服务器处理 (卡拉引擎 T4) + 用户请求返回(T3+T1) 在上述延迟中，T1 只与用户与服务器的物理距离相关，而 T3 非常小（参考Jeff Dean Numbe)可以忽略不计。 所以我们能控制的大致只有 T2 和 T4，即 Nginx 服务器的处理时间和卡拉的引擎处理时间。 Nginx 在这里作为反向代理，处理一些安全、流量控制和 TLS 的逻辑，而卡拉的引擎则是一个在 Lucene 基础上的倒排引擎。 我们首先考虑的第一个可能性是：延迟是不是来自卡拉引擎呢？ 在下图展示的 Grafana 仪表盘中，我们看到除了几个时不时的慢查询，搜索的 95% 服务器处理延迟小于 20 毫秒。对比同样的数据集上 benchmark 的 Elastic Search 引擎的 P95 搜索延迟则在 200 毫秒左右，所以排除了引擎速度慢的可能。 <img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223202234.png" alt=""> 而在阿里云监控中，我们设置了从全国各地向卡拉服务器发送搜索请求。我们终于发现 SSL 处理时间时常会超过 300 毫秒，也就是说在 T2 这一步，光处理 TLS 握手之类的事情，Nginx 已经用掉了我们所有的请求时间预算。 同时检查之后我们发现，在苹果设备上搜索速度格外慢，特别是第一次访问的设备。因此我们大致判断应该是因为我们使用的 Let’s Encrypt 证书的问题。 我们按照上文中的步骤对 Nginx 设置进行了调整，并将步骤总结出来写了这篇文章。在调整了 Nginx TLS 的设置后，SSL 时间从平均的 140ms 降低到了 110ms 左右（全国所有省份联通和移动测试点），同时苹果设备上首次访问慢的问题也消失了。 <img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223202249.png" alt=""> 在调整过后，全国范围内测试的搜索延迟降低到了 150 毫秒左右。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  调整 Nginx 中的 TLS 设置对于使用 HTTPS 的服务和网站延迟有非常大的影响。<br>  本文中总结了 Nginx 中与 TLS 相关的设置，详细讨论各个设置可能对延迟的影响，并给出了调整建议。之后我们会继续讨论 HTTP/2 对比 HTTP 1.x 有哪些具体改进，以及在 REST API 使用 HTTP/2 有哪些优缺点</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223202509.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;为什么要优化-Nginx-HTTPS-延迟&quot;&gt;&lt;a href=&quot;#为什么要优化-Nginx-HTTPS-延迟&quot; class=&quot;headerlink&quot; title=&quot;为什么要优化 Nginx HTTPS 延迟&quot;&gt;&lt;/a&gt;为什么要优化 Nginx HTTPS 延迟&lt;/h1&gt;&lt;p&gt;  Nginx 常作为最常见的服务器，常被用作负载均衡 (Load Balancer)、反向代理 (Reverse Proxy)，以及网关 (Gateway) 等等。一个配置得当的 Nginx 服务器单机应该可以期望承受住 50K 到 80K 左右每秒的请求，同时将 CPU 负载在可控范围内。 但在很多时候，负载并不是需要首要优化的重点。比如对于卡拉搜索来说，我们希望用户在每次击键的时候，可以体验即时搜索的感觉，也就是说，每个搜索请求必须在 100ms - 200ms 的时间内端对端地返回给用户，才能让用户搜索时没有“卡顿”和“加载”。因此，对于我们来说，优化请求延迟才是最重要的优化方向。&lt;/p&gt;
&lt;p&gt;这篇文章中，我们先介绍 Nginx 中的 TLS 设置有哪些与请求延迟可能相关，如何调整才能最大化加速。然后我们用优化卡拉搜索 Nginx 服务器的实例来分享如何调整 Nginx TLS/SSL 设置，为首次搜索的用户提速 30% 左右。我们会详细讨论每一步我们做了一些什么优化，优化的动机和效果。希望可以对其它遇到类似问题的同学提供帮助。 照例，本文的 Nginx 设置文件放置于 github，欢迎直接使用: 高性能 Nginx HTTPS 调优(&lt;a href=&quot;https://github.com/Kalasearch/high-performance-nginx-tls-tuning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Kalasearch/high-performance-nginx-tls-tuning&lt;/a&gt;)&lt;/p&gt;
&lt;h1 id=&quot;TLS-握手和延迟&quot;&gt;&lt;a href=&quot;#TLS-握手和延迟&quot; class=&quot;headerlink&quot; title=&quot;TLS 握手和延迟&quot;&gt;&lt;/a&gt;TLS 握手和延迟&lt;/h1&gt;&lt;p&gt;  很多时候开发者会认为：如果不是绝对在意性能，那么了解底层和更细节的优化没有必要。这句话在很多时候是恰当的，因为很多时候复杂的底层逻辑必须包起来，才能让更高层的应用开发复杂度可控。比如说，如果你就只需要开发一个 APP 或者网站，可能并没有必要关注汇编细节，关注编译器如何优化你的代码——毕竟在苹果或者安卓上很多优化在底层就做好了。 那么，了解底层的 TLS 和应用层的 Nginx 延迟优化有什么关系呢？ 答案是多数情况下，优化网络延迟其实是在尝试减少用户和服务器之间的数据传输次数，也就是所谓的 roundtrip。由于物理限制，北京到云南的光速传播差不多就是要跑 20 来毫秒，如果你不小心让数据必须多次往返于北京和云南之间，那么必然延迟就上去了。 因此如果你需要优化请求延迟，那么了解一点底层网络的上下文则会大有裨益，很多时候甚至是你是否可以轻松理解一个优化的关键。本文中我们不深入讨论太多 TCP 或者 TLS 机制的细节，如果有兴趣的话请参考 High Performance Browser Networking 一书。 举个例子，下图中展示了如果你的服务启用了 HTTPS，在开始传输任何数据之前的数据传输情况。 &lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210223201646.png&quot; alt=&quot;&quot;&gt;     可以看到，在你的用户拿到他需要的数据前，底层的数据包就已经在用户和你的服务器之间跑了 3 个来回。 假设每次来回需要 28 毫秒的话，用户已经等了 224 毫秒之后才开始接收数据。 同时这个 28 毫秒其实是非常乐观的假设，在国内电信、联通和移动以及各种复杂的网络状况下，用户与服务器之间的延迟更不可控。另一方面，通常一个网页需要数十个请求，这些请求不一定可以全部并行，因此几十乘以 224 毫秒，页面打开可能就是数秒之后了。 所以，原则上如果可能的话，我们需要尽量减少用户和服务器之间的往返程 (roundtrip)，在下文的设置中，对于每个设置我们会讨论为什么这个设置有可能帮助减少往返程。&lt;/p&gt;
&lt;h1 id=&quot;Nginx-中的-TLS-设置&quot;&gt;&lt;a href=&quot;#Nginx-中的-TLS-设置&quot; class=&quot;headerlink&quot; title=&quot;Nginx 中的 TLS 设置&quot;&gt;&lt;/a&gt;Nginx 中的 TLS 设置&lt;/h1&gt;&lt;p&gt;  那么在 Nginx 设置中，怎样调整参数会减少延迟呢？&lt;/p&gt;
    
    </summary>
    
      <category term="back-end" scheme="http://www.jifu.io/categories/back-end/"/>
    
      <category term="Middle-ware" scheme="http://www.jifu.io/categories/back-end/Middle-ware/"/>
    
      <category term="Nginx" scheme="http://www.jifu.io/categories/back-end/Middle-ware/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://www.jifu.io/tags/Nginx/"/>
    
      <category term="高性能" scheme="http://www.jifu.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
      <category term="调优" scheme="http://www.jifu.io/tags/%E8%B0%83%E4%BC%98/"/>
    
      <category term="提速" scheme="http://www.jifu.io/tags/%E6%8F%90%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5.4 有什么新功能？</title>
    <link href="http://www.jifu.io/posts/684390890/"/>
    <id>http://www.jifu.io/posts/684390890/</id>
    <published>2021-02-18T09:44:13.000Z</published>
    <updated>2021-02-28T13:25:18.354Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210218225507.png" alt=""></p><h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>多个变量参数，改进隐式成员语法，结果构建器等。</p><p>Swift 5.4带来了一些巨大的编译改进，包括更好地完成带错误的表达式中的代码，以及增量编译的大提速。不过，它也增加了一些重要的新特性和改进，让我们在这里深入了解一下……</p><ul><li><p>小贴士：</p><p>  如果你想自己尝试代码样本，也可以下载这个作为Xcode Playground。</p></li></ul><h1 id="改进了隐式成员语法"><a href="#改进了隐式成员语法" class="headerlink" title="改进了隐式成员语法"></a>改进了隐式成员语法</h1><p>SE-0287改进了Swift使用隐式成员表达式的能力，所以你可以制作它们的链子，而不是只支持一个单一的静态成员。</p><p>Swift一直以来都有能力使用隐式成员语法来处理简单的表达式，例如，如果你想在SwiftUI中给一些文本着色，你可以使用.red而不是Color.red。</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">struct</span> <span class="token builtin">ContentView1</span><span class="token punctuation">:</span> <span class="token builtin">View</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> body<span class="token punctuation">:</span> some <span class="token builtin">View</span> <span class="token punctuation">{</span>        <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"You're not my supervisor!"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">foregroundColor</span><span class="token punctuation">(</span><span class="token punctuation">.</span>red<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Swift 5.4之前，这在更复杂的表达式中是行不通的。例如，如果你想让你的红色略微透明，你就需要这样写。</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">struct</span> <span class="token builtin">ContentView2</span><span class="token punctuation">:</span> <span class="token builtin">View</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> body<span class="token punctuation">:</span> some <span class="token builtin">View</span> <span class="token punctuation">{</span>        <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"You're not my supervisor!"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">foregroundColor</span><span class="token punctuation">(</span><span class="token builtin">Color</span><span class="token punctuation">.</span>red<span class="token punctuation">.</span><span class="token function">opacity</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><p>从Swift 5.4开始，编译器能够理解多个链式成员，这意味着可以推断出Color类型。</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">struct</span> <span class="token builtin">ContentView3</span><span class="token punctuation">:</span> <span class="token builtin">View</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> body<span class="token punctuation">:</span> some <span class="token builtin">View</span> <span class="token punctuation">{</span>        <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"You're not my supervisor!"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">foregroundColor</span><span class="token punctuation">(</span><span class="token punctuation">.</span>red<span class="token punctuation">.</span><span class="token function">opacity</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="函数中的多变量参数"><a href="#函数中的多变量参数" class="headerlink" title="函数中的多变量参数"></a>函数中的多变量参数</h1><p>SE-0284引入了让函数、下标和初始化器使用多个变量参数的能力，只要变量参数后面的所有参数都有标签。在Swift 5.4之前，这种情况下只能有一个变量参数。</p><p>所以，有了这个改进，我们可以写一个函数，接受一个变量参数，存储足球比赛中进球的次数，再加上第二个变量参数，打出进球球员的名字。</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">func</span> <span class="token function">summarizeGoals</span><span class="token punctuation">(</span>times<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> players<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> joinedNames <span class="token operator">=</span> <span class="token builtin">ListFormatter</span><span class="token punctuation">.</span><span class="token function">localizedString</span><span class="token punctuation">(</span>byJoining<span class="token punctuation">:</span> players<span class="token punctuation">)</span>    <span class="token keyword">let</span> joinedTimes <span class="token operator">=</span> <span class="token builtin">ListFormatter</span><span class="token punctuation">.</span><span class="token function">localizedString</span><span class="token punctuation">(</span>byJoining<span class="token punctuation">:</span> times<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>times<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token delimiter variable">)</span></span> goals where scored by <span class="token interpolation"><span class="token delimiter variable">\(</span>joinedNames<span class="token delimiter variable">)</span></span> at the follow minutes: <span class="token interpolation"><span class="token delimiter variable">\(</span>joinedTimes<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要调用该函数，提供两组值作为变量参数，确保第一个变量之后的所有参数都有标签。</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token function">summarizeGoals</span><span class="token punctuation">(</span>times<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> players<span class="token punctuation">:</span> <span class="token string">"Dani"</span><span class="token punctuation">,</span> <span class="token string">"Jamie"</span><span class="token punctuation">,</span> <span class="token string">"Roy"</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="结果生成器"><a href="#结果生成器" class="headerlink" title="结果生成器"></a>结果生成器</h1><p>函数构建器在Swift 5.1中非正式地出现了，但在Swift 5.4之前，它们作为SE-0289正式通过了Swift进化提案过程，以便进行讨论和完善。作为这个过程的一部分，它们被重新命名为结果构建器以更好地反映它们的实际目的，甚至获得了一些新的功能。</p><p>首先是最重要的部分：结果构建器允许我们通过在我们选择的序列中一步步地创造一个新的价值。它们为SwiftUI的视图创建系统的很大一部分提供了动力，所以当我们拥有一个内部有各种视图的VStack时，Swift会默默地将它们归为一个内部的TupleView类型，这样它们就可以作为VStack的一个子代来存储–它将一个视图序列变成了一个视图。</p><p>结果构建器应该有自己的详细文章，但我至少想给你一些小的代码示例，这样你就可以看到它们的运作。</p><p>下面是一个返回单个字符串的函数。</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">func</span> <span class="token function">makeSentence1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>    <span class="token string">"Why settle for a Duke when you can have a Prince?"</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">makeSentence1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这很好用，但如果有几个字符串我们想连接在一起呢？就像SwiftUI一样，我们可能想把它们都单独提供，然后让Swift来解决。</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token comment" spellcheck="true">// This is invalid Swift, and will not compile.</span><span class="token comment" spellcheck="true">// func makeSentence2() -> String {</span><span class="token comment" spellcheck="true">//     "Why settle for a Duke"</span><span class="token comment" spellcheck="true">//     "when you can have"</span><span class="token comment" spellcheck="true">//     "a Prince?"</span><span class="token comment" spellcheck="true">// }</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就其本身而言，这段代码是行不通的，因为Swift不再理解我们的意思。然而，我们可以创建一个结果生成器，它可以理解如何使用我们想要的任何转换将几个字符串转换为一个字符串，就像这样。</p><pre class="line-numbers language-swift"><code class="language-swift">`@resultBuilder<span class="token keyword">struct</span> <span class="token builtin">SimpleStringBuilder</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function">buildBlock</span><span class="token punctuation">(</span><span class="token number">_</span> parts<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        parts<span class="token punctuation">.</span><span class="token function">joined</span><span class="token punctuation">(</span>separator<span class="token punctuation">:</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管这只是少量的代码，但有很多需要解压。</p><ul><li><p>@resultBuilder属性告诉SwiftUI以下类型应该被视为结果构建器。</p><p>  以前这种行为是通过@_functionBuilder实现的，它有一个下划线来表明这不是为一般使用而设计的。</p></li><li><p>每个结果构建器都必须提供至少一个名为buildBlock()的静态方法，该方法应该接收某种数据并对其进行转换。</p><p>  上面的例子是接收零个或多个字符串，将它们连接起来，然后以单个字符串的形式发送回来。</p></li><li><p>最终的结果是，我们的SimpleStringBuilder结构变成了一个结果构建器，这意味着我们可以在任何需要它的字符串连接能力的地方使用@SimpleStringBuilder。</p></li></ul><p>没有什么可以阻止我们直接使用SimpleStringBuilder.buildBlock()，就像这样。</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">let</span> joined <span class="token operator">=</span> <span class="token builtin">SimpleStringBuilder</span><span class="token punctuation">.</span><span class="token function">buildBlock</span><span class="token punctuation">(</span>    <span class="token string">"Why settle for a Duke"</span><span class="token punctuation">,</span>    <span class="token string">"when you can have"</span><span class="token punctuation">,</span>    <span class="token string">"a Prince?"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>joined<span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而，由于我们在SimpleStringBuilder结构中使用了@resultBuilder注解，我们也可以将其应用到函数中，就像这样。</p><pre class="line-numbers language-swift"><code class="language-swift">`@<span class="token builtin">SimpleStringBuilder</span> <span class="token keyword">func</span> <span class="token function">makeSentence3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>    <span class="token string">"Why settle for a Duke"</span>    <span class="token string">"when you can have"</span>    <span class="token string">"a Prince?"</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">makeSentence3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，我们不再需要每个字符串末尾的逗号--@resultBuilder通过使用SimpleStringBuilder自动将makeSentence()中的每个语句转换为单个字符串。</p><p>在实践中，结果生成器能够做得更多，通过向你的生成器类型添加更多的方法来完成。例如，我们可以通过添加两个额外的方法来为我们的SimpleStringBuilder添加if/else支持，这两个方法描述了我们要如何转换数据。在我们的代码中，我们根本不想转换我们的字符串，所以我们可以直接把它们送回去。</p><pre class="line-numbers language-swift"><code class="language-swift">`@resultBuilder<span class="token keyword">struct</span> <span class="token builtin">ConditionalStringBuilder</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function">buildBlock</span><span class="token punctuation">(</span><span class="token number">_</span> parts<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        parts<span class="token punctuation">.</span><span class="token function">joined</span><span class="token punctuation">(</span>separator<span class="token punctuation">:</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function">buildEither</span><span class="token punctuation">(</span><span class="token builtin">first</span> component<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> component    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function">buildEither</span><span class="token punctuation">(</span>second component<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> component    <span class="token punctuation">}</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我知道，看起来我们几乎没有做任何工作，但现在我们的函数能够使用条件。</p><pre class="line-numbers language-swift"><code class="language-swift">`@<span class="token builtin">ConditionalStringBuilder</span> <span class="token keyword">func</span> <span class="token function">makeSentence4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>    <span class="token string">"Why settle for a Duke"</span>    <span class="token string">"when you can have"</span>    <span class="token keyword">if</span> <span class="token builtin">Bool</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token string">"a Prince?"</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token string">"a King?"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">makeSentence4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，我们也可以通过在构建器类型中添加 buildArray() 方法来添加对循环的支持。</p><pre class="line-numbers language-swift"><code class="language-swift">`@resultBuilder<span class="token keyword">struct</span> <span class="token builtin">ComplexStringBuilder</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function">buildBlock</span><span class="token punctuation">(</span><span class="token number">_</span> parts<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        parts<span class="token punctuation">.</span><span class="token function">joined</span><span class="token punctuation">(</span>separator<span class="token punctuation">:</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function">buildEither</span><span class="token punctuation">(</span><span class="token builtin">first</span> component<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> component    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function">buildEither</span><span class="token punctuation">(</span>second component<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> component    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token function">buildArray</span><span class="token punctuation">(</span><span class="token number">_</span> components<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        components<span class="token punctuation">.</span><span class="token function">joined</span><span class="token punctuation">(</span>separator<span class="token punctuation">:</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们可以使用for循环。</p><pre class="line-numbers language-swift"><code class="language-swift">`@<span class="token builtin">ComplexStringBuilder</span> <span class="token keyword">func</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>i<span class="token delimiter variable">)</span></span>…"</span>    <span class="token punctuation">}</span>    <span class="token string">"Lift off!"</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这感觉几乎就像魔法一样，因为结果构建器系统几乎为我们做了所有的工作，尽管我们的例子已经相当简单，但我希望你能感受到结果构建器给Swift带来的非凡力量。</p><p>值得补充的是，Swift 5.4扩展了结果构建器系统，支持属性被放置在存储的属性上，这将自动调整结构的隐式成员初始化器来应用结果构建器。</p><p>这对于使用结果构建器的自定义SwiftUI视图特别有帮助，比如这个视图。</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">struct</span> <span class="token builtin">CustomVStack</span><span class="token operator">&lt;</span><span class="token builtin">Content</span><span class="token punctuation">:</span> <span class="token builtin">View</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token builtin">View</span> <span class="token punctuation">{</span>    @<span class="token builtin">ViewBuilder</span> <span class="token keyword">let</span> content<span class="token punctuation">:</span> <span class="token builtin">Content</span>    <span class="token keyword">var</span> body<span class="token punctuation">:</span> some <span class="token builtin">View</span> <span class="token punctuation">{</span>        <span class="token builtin">VStack</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// custom functionality here</span>            content        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你想看到更多高级的、实际操作的结果构建器的例子，你应该查看GitHub上的Awesome Function Builders仓库。</p><h1 id="本地函数现在支持重载"><a href="#本地函数现在支持重载" class="headerlink" title="本地函数现在支持重载"></a>本地函数现在支持重载</h1><p>SR-10069要求能够在本地上下文中重载函数，这实际上意味着嵌套函数现在可以重载，这样Swift就可以根据使用的类型来选择运行哪个函数。</p><p>例如，如果我们想制作一些简单的 cookie，我们可能会写这样的代码。</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">struct</span> <span class="token builtin">Butter</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token builtin">Flour</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token builtin">Sugar</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">makeCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token builtin">Butter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Adding butter…"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token builtin">Flour</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Adding flour…"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token builtin">Sugar</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Adding sugar…"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token function">Butter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token function">Flour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token function">Sugar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Swift 5.4之前，三个add()方法只有在没有嵌套在makeCookies()里面的情况下才能被重载，但从Swift 5.4开始，这种情况下也支持函数重载。</p><p>现在支持本地变量的属性包装器了 属性包装器最早是在Swift 5.1中引入的，作为一种以简单、可重用的方式为属性附加额外功能的方式，但在Swift 5.4中，它们的行为得到了扩展，支持在函数中作为局部变量使用。</p><p>例如，我们可以创建一个属性包装器，确保其值永远不会低于零。</p><pre class="line-numbers language-swift"><code class="language-swift">`@propertyWrapper <span class="token keyword">struct</span> <span class="token builtin">NonNegative</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Numeric</span> <span class="token operator">&amp;</span> <span class="token builtin">Comparable</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> value<span class="token punctuation">:</span> T    <span class="token keyword">var</span> wrappedValue<span class="token punctuation">:</span> T <span class="token punctuation">{</span>        <span class="token keyword">get</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span>        <span class="token keyword">set</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> newValue <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>                value <span class="token operator">=</span> <span class="token number">0</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                value <span class="token operator">=</span> newValue            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">init</span><span class="token punctuation">(</span>wrappedValue<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> wrappedValue <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">0</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token operator">=</span> wrappedValue        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而从Swift 5.4开始，我们可以在一个常规函数里面使用这个属性包装器，而不仅仅是附加到一个属性上。例如，我们可以写一个游戏，在这个游戏中，我们的玩家可以获得或失去分数，但他们的分数绝对不能低于0。</p><pre class="line-numbers language-swift"><code class="language-swift">`<span class="token keyword">func</span> <span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    @<span class="token builtin">NonNegative</span> <span class="token keyword">var</span> score <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">// player was correct</span>    score <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span>    <span class="token comment" spellcheck="true">// player was correct again</span>    score <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">8</span>    <span class="token comment" spellcheck="true">// player got one wrong</span>    score <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">15</span>    <span class="token comment" spellcheck="true">// player got another one wrong</span>    score <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">16</span>    <span class="token function">print</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="软件包现在可以声明可执行目标"><a href="#软件包现在可以声明可执行目标" class="headerlink" title="软件包现在可以声明可执行目标"></a>软件包现在可以声明可执行目标</h1><p>SE-0294 为使用 Swift 包管理器的应用程序增加了一个新的目标选项，允许我们明确声明一个可执行目标。</p><p>这对于想要使用 SE-0281（使用 @main 来标记你的程序的入口点）的人来说特别重要，因为它与 Swift 包管理器玩得并不好–它总是会寻找 main.swift 文件。</p><p>通过这次修改，我们现在可以删除main.swift而使用@main来代替。注意：你必须在你的Package.swift文件中指定// swift-tools-version:5.4才能获得这个新功能。</p><h1 id="自己尝试"><a href="#自己尝试" class="headerlink" title="自己尝试"></a>自己尝试</h1><p>Swift 5.4可以通过Xcode 12.5获得，Xcode 12.5于2021年2月1日进入测试版。如果你还没有升级到macOS Big Sur，你将无法安装Xcode 12.5，所以你应该从<a href="https://swift.org/download/" target="_blank" rel="noopener">https://swift.org/download/</a> 下载一个Swift 5.4工具链–你可以将其安装到Xcode 12.4和更早的版本中。</p><p>你最期待Swift 5.4的哪些功能？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210218225507.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;导言&quot;&gt;&lt;a href=&quot;#导言&quot; class=&quot;headerlink&quot; title=&quot;导言&quot;&gt;&lt;/a&gt;导言&lt;/h1&gt;&lt;p&gt;多个变量参数，改进隐式成员语法，结果构建器等。&lt;/p&gt;
&lt;p&gt;Swift 5.4带来了一些巨大的编译改进，包括更好地完成带错误的表达式中的代码，以及增量编译的大提速。不过，它也增加了一些重要的新特性和改进，让我们在这里深入了解一下……&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;小贴士：&lt;/p&gt;
&lt;p&gt;  如果你想自己尝试代码样本，也可以下载这个作为Xcode Playground。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;改进了隐式成员语法&quot;&gt;&lt;a href=&quot;#改进了隐式成员语法&quot; class=&quot;headerlink&quot; title=&quot;改进了隐式成员语法&quot;&gt;&lt;/a&gt;改进了隐式成员语法&lt;/h1&gt;&lt;p&gt;SE-0287改进了Swift使用隐式成员表达式的能力，所以你可以制作它们的链子，而不是只支持一个单一的静态成员。&lt;/p&gt;
&lt;p&gt;Swift一直以来都有能力使用隐式成员语法来处理简单的表达式，例如，如果你想在SwiftUI中给一些文本着色，你可以使用.red而不是Color.red。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;`struct ContentView1: View {
    var body: some View {
        Text(&amp;quot;You&amp;#39;re not my supervisor!&amp;quot;)
            .foregroundColor(.red)
    }
}
`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Swift 5.4之前，这在更复杂的表达式中是行不通的。例如，如果你想让你的红色略微透明，你就需要这样写。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;`struct ContentView2: View {
    var body: some View {
        Text(&amp;quot;You&amp;#39;re not my supervisor!&amp;quot;)
            .foregroundColor(Color.red.opacity(0.5))
    }
}
`
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="iOS Development" scheme="http://www.jifu.io/categories/iOS-Development/"/>
    
    
      <category term="Swift" scheme="http://www.jifu.io/tags/Swift/"/>
    
      <category term="新特性" scheme="http://www.jifu.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>快速改善用户界面的10个技巧</title>
    <link href="http://www.jifu.io/posts/729727978/"/>
    <id>http://www.jifu.io/posts/729727978/</id>
    <published>2021-02-14T02:35:19.000Z</published>
    <updated>2021-02-28T13:25:18.351Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214154434.jpg" alt=""></p><p>创建美观、好用和高效的 UI 需要花费时间，并且需要不断的调整修正，才能产生让用户和自己真正满意的设计。在本文中，总结了一些简单易用的设计小技巧，通过进行一些简单的视觉调整，可以快速改善你要创建的视觉效果。</p><h1 id="1-减轻文本的字重"><a href="#1-减轻文本的字重" class="headerlink" title="1. 减轻文本的字重"></a><strong>1. 减轻文本的字重</strong></h1><p>当涉及到长篇内容时，某些常规的粗体字看起来会有些沉重和生硬，可以通过选择深灰色（Dark Gray），比如＃4F4F4F 来解决这个问题，让文本看起来更美观一些。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153635.jpg" alt=""></p><h1 id="2-字号越小，行高越高"><a href="#2-字号越小，行高越高" class="headerlink" title="2. 字号越小，行高越高"></a><strong>2. 字号越小，行高越高</strong></h1><p>当你的字号减小时，增加行高可以达到更好的、全面的易读性；当字号增加时，只需降低行高也可以达到同样的效果。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153701.jpg" alt=""></p><h1 id="3-选择基色，使用色调和阴影来增加一致性"><a href="#3-选择基色，使用色调和阴影来增加一致性" class="headerlink" title="3. 选择基色，使用色调和阴影来增加一致性"></a><strong>3. 选择基色，使用色调和阴影来增加一致性</strong></h1><p>你不必总是用多种颜色来填充你的设计，如果项目允许，则只需使用一个固定的调色板，通过选择一个基础色，然后使用色调和阴影，就可以用最简单的方式增加设计的一致性。</p><a id="more"></a><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153717.jpg" alt=""></p><h1 id="4-突出最重要的元素"><a href="#4-突出最重要的元素" class="headerlink" title="4. 突出最重要的元素"></a><strong>4. 突出最重要的元素</strong></h1><p>通过使用字号、粗细和颜色的组合，你可以轻松的在 UI 中突出最重要的元素，通过简单的调整即可使用户体验更好。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153758.jpg" alt=""></p><h1 id="5-为了保持一致性，确保图标具有相同的视觉样式"><a href="#5-为了保持一致性，确保图标具有相同的视觉样式" class="headerlink" title="5. 为了保持一致性，确保图标具有相同的视觉样式"></a><strong>5. 为了保持一致性，确保图标具有相同的视觉样式</strong></h1><p>在 UI 中设计图标时，要确保它们具有相同的视觉风格，相同的字重，填充或描边，不要混搭。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153814.jpg" alt=""></p><h1 id="6-始终将-CTA（行动召唤）按钮放在屏幕中最突出的位置"><a href="#6-始终将-CTA（行动召唤）按钮放在屏幕中最突出的位置" class="headerlink" title="6. 始终将 CTA（行动召唤）按钮放在屏幕中最突出的位置"></a><strong>6. 始终将 CTA（行动召唤）按钮放在屏幕中最突出的位置</strong></h1><p>通过使用颜色对比、大小和标签，确保 “行动召唤” 尽可能突出。如果可以的话，不要总是只依赖图标，也可以使用文本标签，让用户能够更好地理解。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153834.jpg" alt=""></p><h1 id="7-为表单错误添加额外的视觉帮助"><a href="#7-为表单错误添加额外的视觉帮助" class="headerlink" title="7. 为表单错误添加额外的视觉帮助"></a><strong>7. 为表单错误添加额外的视觉帮助</strong></h1><p>当用户填写任何类型的表单时，在用户刚刚执行的操作附近添加错误消息是一种简单且非常有用的额外视觉帮助。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153900.jpg" alt=""></p><h1 id="8-突出显示菜单中最常用的操作"><a href="#8-突出显示菜单中最常用的操作" class="headerlink" title="8. 突出显示菜单中最常用的操作"></a><strong>8. 突出显示菜单中最常用的操作</strong></h1><p>当设计一个在应用程序内部使用的菜单时，在屏幕最明显的位置，要确保给出最常用的操作 (例如：上传图片，添加文件等)。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153922.jpgj" alt=""></p><h1 id="9-限制使用居中文字"><a href="#9-限制使用居中文字" class="headerlink" title="9. 限制使用居中文字"></a><strong>9. 限制使用居中文字</strong></h1><p>尽量只在标题和小段文字中使用居中文字。对于所有其它的文本内容，都要保持左对齐。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153940.jpg" alt=""></p><h1 id="10-巧妙地使用留白"><a href="#10-巧妙地使用留白" class="headerlink" title="10. 巧妙地使用留白"></a><strong>10. 巧妙地使用留白</strong></h1><p>适度地使用留白，即使是少量的留白，也能让你的设计更加亮丽。这是改进设计最快速、最简单的方法之一。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153954.jpg" alt=""></p><p>以上是关于快速改善用户界面的 10 个小技巧，希望在你认真做设计的时候可以给你带来灵感，如果你也收藏了很多小技巧，欢迎在下方留言，我们一起学习！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214154434.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;创建美观、好用和高效的 UI 需要花费时间，并且需要不断的调整修正，才能产生让用户和自己真正满意的设计。在本文中，总结了一些简单易用的设计小技巧，通过进行一些简单的视觉调整，可以快速改善你要创建的视觉效果。&lt;/p&gt;
&lt;h1 id=&quot;1-减轻文本的字重&quot;&gt;&lt;a href=&quot;#1-减轻文本的字重&quot; class=&quot;headerlink&quot; title=&quot;1. 减轻文本的字重&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 减轻文本的字重&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;当涉及到长篇内容时，某些常规的粗体字看起来会有些沉重和生硬，可以通过选择深灰色（Dark Gray），比如＃4F4F4F 来解决这个问题，让文本看起来更美观一些。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153635.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-字号越小，行高越高&quot;&gt;&lt;a href=&quot;#2-字号越小，行高越高&quot; class=&quot;headerlink&quot; title=&quot;2. 字号越小，行高越高&quot;&gt;&lt;/a&gt;&lt;strong&gt;2. 字号越小，行高越高&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;当你的字号减小时，增加行高可以达到更好的、全面的易读性；当字号增加时，只需降低行高也可以达到同样的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210214153701.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;3-选择基色，使用色调和阴影来增加一致性&quot;&gt;&lt;a href=&quot;#3-选择基色，使用色调和阴影来增加一致性&quot; class=&quot;headerlink&quot; title=&quot;3. 选择基色，使用色调和阴影来增加一致性&quot;&gt;&lt;/a&gt;&lt;strong&gt;3. 选择基色，使用色调和阴影来增加一致性&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;你不必总是用多种颜色来填充你的设计，如果项目允许，则只需使用一个固定的调色板，通过选择一个基础色，然后使用色调和阴影，就可以用最简单的方式增加设计的一致性。&lt;/p&gt;
    
    </summary>
    
      <category term="Design" scheme="http://www.jifu.io/categories/Design/"/>
    
    
      <category term="改善" scheme="http://www.jifu.io/tags/%E6%94%B9%E5%96%84/"/>
    
      <category term="用户界面" scheme="http://www.jifu.io/tags/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/"/>
    
      <category term="技巧" scheme="http://www.jifu.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 排序的艺术：你真的懂 Order By 吗？</title>
    <link href="http://www.jifu.io/posts/554387356/"/>
    <id>http://www.jifu.io/posts/554387356/</id>
    <published>2021-02-08T09:50:55.000Z</published>
    <updated>2021-02-28T13:25:18.351Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210208225632.png" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>业务中的各种查询通常对应了用户所看到的各项列表，列表一般是根据某个维度进行排序。</p><p>换句话说，业务中使用 <code>SELECT</code> 语句的时候除了不可避免的搭配 <code>WHERE</code> 以外，还会配合 <code>ORDER BY</code> 进行使用。</p><p>今天来好好聊聊 MySQL 的 <code>ORDER BY</code> 排序。</p><hr><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>说到排序算法，有插入排序、选择排序、归并排序、堆排序、快速排序、计数排序、桶排序、基数排序、冒泡排序、希尔排序、梳排序 …</p><p>关于各种排序算法的排序流程和具体实现，不是本篇博客的重点，不作详细说明。</p><p>这里直接贴各类排序算法的时空复杂度：</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210208225222.webp" alt=""></p><p>通常我们实现的这些排序算法，都是在”纯内存“环境中进行。</p><p>MySQL 作为数据库难道是在先将所有要排序的数据加载到内存，再应用排序算法吗？</p><hr><h2 id="MySQL-的排序方案"><a href="#MySQL-的排序方案" class="headerlink" title="MySQL 的排序方案"></a>MySQL 的排序方案</h2><p>在分析 MySQL 的不同的排序方案之前，先来了解 sort buffer 概念。</p><p>MySQL 会为每个线程分配固定大小的 sort buffer 用作排序。</p><a id="more"></a><p>sort buffer 是具有逻辑概念的内存区域，大小由 <code>sort_buffer_size</code> 参数控制，默认为 256 kb。</p><p>由于 sort buffer 大小固定，而 data（待排序的数据量）并不固定，所以根据 sort buffer 与 data（待排序数据量）的大小差值，可分为内部排序和外部排序：</p><ul><li><p><code>data &lt;= sort buffer</code>：即 sort buffer 够用，这时候 MySQL 只需要在内存中进行排序即可。内部排序使用的是快速排序</p></li><li><p><code>data &gt; sort buffer</code>：这时候 sort buffer 不够用，MySQL 需要借助外部“容器”（通常是文件）进行排序。通常会将待排序数据分成多个“小文件”，对各个“小文件”进行排序，再汇总成一个有序的“大文件”。外部排序使用的是归并排序</p></li></ul><p>如何验证当前执行的排序语句使用的是内部排序还是外部排序？</p><p>可以通过 <code>EXPLAIN</code> 命令来查看，如果在分析结果中的 <code>Extra</code> 字段里包含 <code>Using filesort</code> 字眼，说明执行了外部排序操作。</p><h2 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h2><p><strong>「全字段排序是指，只要与最终结果集有关的字段都会被放进 sort buffer，而不管该字段本身是否参与排序。」</strong></p><p>以下面的 SQL 为例子：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT nick_name, age, phone FROM t_user WHERE city = "深圳" ORDER BY nick_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>假设 city 字段上有索引，全字段排序的过程：</p><ol><li><p>从 city 索引树上找到第一条值为深圳的数据，取得 id 之后回表（回到主键索引）取得 nick_name、age、phone 三个字段放入 sort buffer</p></li><li><p>从 city 索引树取下一条值为深圳的数据，重复 1 过程，直到下一条数据不满足值为深圳条件</p></li><li><p>到这一步，所有 city = 深圳 的数据都在 sort buffer 了。对 nick_name 执行快速排序</p></li><li><p>将排序结果返回</p></li></ol><p>可以看到当查询条件本身有索引可用的话，全字段排序的排序过程都在 sort buffer（内存）进行，回表次数为符合条件的数据个数。</p><p>当然，如果我们建立的是 city、nick_name、age、phone 的联合索引，还可以实现“索引覆盖”，即在一棵索引树上取得全部所需数据，减少回表（随机读）次数。</p><p>不过针对每个查询或排序语句建立联合索引，会导致索引过多，大大降低写入更新数据的速度，以及大大提升数据所需要的存储空间。</p><p>生产上对索引的建立修改需要格外谨慎。</p><h2 id="rowId-排序"><a href="#rowId-排序" class="headerlink" title="rowId 排序"></a>rowId 排序</h2><p>rowId 就是 MySQL 对每行数据的唯一标识符。</p><p>当数据表有主键时，rowId 就是表主键；当数据表没有主键或者主键被删除时，MySQL 会自动生成一个长度为 6 字节的 rowId 为作为 rowId。</p><p><strong>「rowId 排序是指只将与排序相关的字段和 rowId 放入 sort buffer，其余结果集需要用到的数据在排序完成后，通过 rowId 回表取得。」</strong></p><p>全字段排序的流程看着已经十分合理，为什么还需要有个 rowId 排序？</p><p>这是我们只需要输出三个字段的情况，假如我们有上百个字段需要返回呢？sort buffer 默认只有 256 kb。能够装下多少行的原始数据行？</p><p>所以当待排序的数据行很大的时候，使用全字段排序必然会导致“外部排序”。而且是使用很多临时文件的“外部排序”，效率很低下。</p><p>相比全字段排序，rowId 排序的好处是在 sort buffer 大小固定的情况下，sort buffer 能够容纳更多的数据行，能够避免使用或者少使用“外部排序文件”。</p><p>缺点是最终返回结果集的时候，需要再次进行回表。</p><p>还是之前那个例子：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT nick_name, age, phone FROM t_user WHERE city = "深圳" ORDER BY nick_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="rowId-排序全过程"><a href="#rowId-排序全过程" class="headerlink" title="rowId 排序全过程"></a>rowId 排序全过程</h3><ol><li><p>从 city 索引树上找到第一条值为深圳的数据，取得 id 之后回表（回到主键索引）取得 nick_name 这个与排序相关的字段和主键 id 一起放入 sort buffer</p></li><li><p>从 city 索引树取下一条值为深圳的数据，重复 1 过程，直到下一条数据不满足值为深圳条件</p></li><li><p>这时候，所有 city = 深圳 的数据都在 sort buffer 了（sort buffer 里面的数据包含两个字段： id 和 nick_name）。对 nick_name 执行快速排序</p></li><li><p>利用排序好的数据，使用主键 id 再次回表取其他字段，将结果返回</p></li></ol><p>注意：在步骤 4 中不会等所有排序好的 id 回表完再返回，而是每个 id 回表一次，取得该行数据之后立即返回，所以不会消耗额外的内存。</p><h2 id="优先队列排序"><a href="#优先队列排序" class="headerlink" title="优先队列排序"></a>优先队列排序</h2><p>无论是使用全字段排序还是 rowId 排序，都不可避免了对所有符合 <code>WHRER</code> 条件的数据进行了排序。</p><p>有读者可能会认为，那不是应该的吗？</p><p>设想一下，如果我们还搭配着 <code>LIMIT</code> 使用呢？</p><p>例如我们在排序语句后添加 <code>LIMIT 3</code> ，哪怕查出来的数据有 10W 行，我们也只需要前 3 行有序。</p><p>为了得到前 3 行数据，而不得不将 10W 行数据载入内存，大大降低了 sort buffer 的利用率。</p><p>这时候你可能想到利用“最小堆”、“最大堆”来进行排序。</p><p>没错，这正是 MySQL 针对带有 <code>LIMIT</code> 的 <code>ORDER BY</code> 语句的优化：使用优先队列进行排序。</p><p>以下面的 SQL 为例子：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT nick_name, age, phone FROM t_user WHERE city = "深圳" ORDER BY nick_name LIMIT 3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优先队列进行排序的流程"><a href="#优先队列进行排序的流程" class="headerlink" title="优先队列进行排序的流程"></a>优先队列进行排序的流程</h3><ol><li><p>在所有待排序的数据，取数量为 <code>LIMIT</code> （本例中为 3）的数据，构建一个堆</p></li><li><p>不断的取下一行数据，更新堆节点</p></li><li><p>当所有行的扫描完，得到最终的排序结果</p></li></ol><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择?"></a>如何选择?</h2><p>现在我们知道有全字段排序和 rowId 排序，那么 MySQL 是如何在这两种排序方案中做选择呢？</p><p>由于 rowId 排序相对于全字段排序，不可避免的多了一次回表操作，回表操作意味着随机读，而随机 IO 是数据库中最昂贵的操作。</p><p>所以 MySQL 会在尽可能的情况下选择全字段排序。</p><p>那么什么情况下 MySQL 会选择 rowId 排序呢，是否有具体的值可以量度？</p><p>答案是有的，通过参数 <code>max_length_for_sort_data</code> 可以控制用于排序的行数据最大长度，默认值为 1024 字节。</p><p>当单行数据长度超过该值，MySQL 就会觉得如果还用全字段排序，会导致 sort buffer 容纳下的行数太少，从而转为使用 rowId 排序。</p><hr><h1 id="临时表排序"><a href="#临时表排序" class="headerlink" title="临时表排序"></a>临时表排序</h1><p>通常对于一个执行较慢的排序语句，在使用 <code>EXPLAIN</code> 进行执行过程分析的时候除了能看到 <code>Using filesort</code> 以外，还能看到 <code>Using temporary</code>，代表在排序过程中使用到了临时表。</p><h2 id="内存临时表排序"><a href="#内存临时表排序" class="headerlink" title="内存临时表排序"></a>内存临时表排序</h2><p>MySQL 优先使用内存临时表。当 MySQL 使用内存临时表时，临时表存储引擎为 memory 。</p><p>如果当前 MySQL 使用的是内存临时表的话，将会直接使用 rowId 排序，因为这时候所谓的“回表”只是在内存表中读数据，操作不涉及硬盘的随机 IO 读。</p><p>使用 rowId 可以在 sort buffer 容纳给多的行，避免或减少外部排序文件的使用。</p><h2 id="磁盘临时表排序"><a href="#磁盘临时表排序" class="headerlink" title="磁盘临时表排序"></a>磁盘临时表排序</h2><p>如果系统中很多需要使用临时表的排序语句执行，而又不加以限制，全都使用临时表的话，内存很快就会被打满。</p><p>所以 MySQL 提供了 <code>tmp_table_size</code> 参数限制了内存临时表的大小，默认值是 16M。</p><p><code>如果临时表大小超过了tmp_table_size</code>，那么内存临时表就会转成磁盘临时表。</p><p>当使用磁盘临时表的时候，表储存引擎将不再是 memory，而是由 <code>internal_tmp_disk_storage_engine</code> 参数控制，默认为 <code>InnoDB</code> 。</p><p>这时候 MySQL 会根据单行大小是否超过 <code>max_length_for_sort_data</code> 决定采用全字段排序还是 rowId 排序。</p><hr><h1 id="总-结"><a href="#总-结" class="headerlink" title="总#结"></a>总#结</h1><p>总结一下，MySQL 总是使用 <strong>「“最快”」</strong> 的排序方案：</p><ul><li><p>当排序数据量不超过 sort buffer 容量时，MySQL 将会在内存使用快速排序算法进行排序（内部排序）；当排序数据量超过 sort buffer 容量时，MySQL 将会借助临时磁盘文件使用归并排序算法进行排序（外部排序）</p></li><li><p>在进行真正排序时，MySQL 又会根据数据单行长度是否超过 <code>max_length_for_sort_data而决定使用</code> rowId 排序还是全字段排序，优先选择全字段排序，以减少回表次数</p></li><li><p>当需要借助临时表的时候，MySQL 会优先使用内存临时表（此时表引擎为 memory 引擎），回内存临时表取数据并不涉及随机读，也不涉及扫描行，效率较高。所以在配合内存临时表的时候，会使用 rowId 排序方式；当内存临时表大小超过 <code>tmp_table_size</code> 限制时，则需要将内存临时表转换为磁盘临时表，这时候由于回表意味着随机读，所以会搭配全字段排序方式</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210208225632.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;业务中的各种查询通常对应了用户所看到的各项列表，列表一般是根据某个维度进行排序。&lt;/p&gt;
&lt;p&gt;换句话说，业务中使用 &lt;code&gt;SELECT&lt;/code&gt; 语句的时候除了不可避免的搭配 &lt;code&gt;WHERE&lt;/code&gt; 以外，还会配合 &lt;code&gt;ORDER BY&lt;/code&gt; 进行使用。&lt;/p&gt;
&lt;p&gt;今天来好好聊聊 MySQL 的 &lt;code&gt;ORDER BY&lt;/code&gt; 排序。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;p&gt;说到排序算法，有插入排序、选择排序、归并排序、堆排序、快速排序、计数排序、桶排序、基数排序、冒泡排序、希尔排序、梳排序 …&lt;/p&gt;
&lt;p&gt;关于各种排序算法的排序流程和具体实现，不是本篇博客的重点，不作详细说明。&lt;/p&gt;
&lt;p&gt;这里直接贴各类排序算法的时空复杂度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210208225222.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;通常我们实现的这些排序算法，都是在”纯内存“环境中进行。&lt;/p&gt;
&lt;p&gt;MySQL 作为数据库难道是在先将所有要排序的数据加载到内存，再应用排序算法吗？&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;MySQL-的排序方案&quot;&gt;&lt;a href=&quot;#MySQL-的排序方案&quot; class=&quot;headerlink&quot; title=&quot;MySQL 的排序方案&quot;&gt;&lt;/a&gt;MySQL 的排序方案&lt;/h2&gt;&lt;p&gt;在分析 MySQL 的不同的排序方案之前，先来了解 sort buffer 概念。&lt;/p&gt;
&lt;p&gt;MySQL 会为每个线程分配固定大小的 sort buffer 用作排序。&lt;/p&gt;
    
    </summary>
    
      <category term="back-end" scheme="http://www.jifu.io/categories/back-end/"/>
    
      <category term="Middle-ware" scheme="http://www.jifu.io/categories/back-end/Middle-ware/"/>
    
      <category term="MySQL" scheme="http://www.jifu.io/categories/back-end/Middle-ware/MySQL/"/>
    
    
      <category term="排序" scheme="http://www.jifu.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="MySQL" scheme="http://www.jifu.io/tags/MySQL/"/>
    
      <category term="Order by" scheme="http://www.jifu.io/tags/Order-by/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X设置SMB进行文件共享</title>
    <link href="http://www.jifu.io/posts/2776773816/"/>
    <id>http://www.jifu.io/posts/2776773816/</id>
    <published>2021-02-08T09:42:05.000Z</published>
    <updated>2021-02-28T13:25:18.351Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210208224528.jpg" alt=""></p><h1 id="新增共享用户"><a href="#新增共享用户" class="headerlink" title="新增共享用户"></a>新增共享用户</h1><p>进入系统偏好设置，点击用户和群组，添加共享用户。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210208224302.png" alt=""></p><h1 id="设置共享"><a href="#设置共享" class="headerlink" title="设置共享"></a>设置共享</h1><p>进入系统偏好设置，点击共享，设置共享相关配置。</p><a id="more"></a><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210208224336.png" alt=""></p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210208224353.png" alt=""></p><h1 id="访问共享"><a href="#访问共享" class="headerlink" title="访问共享"></a>访问共享</h1><p>在windows中访问Mac OS的共享文件。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210208224408.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210208224528.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;新增共享用户&quot;&gt;&lt;a href=&quot;#新增共享用户&quot; class=&quot;headerlink&quot; title=&quot;新增共享用户&quot;&gt;&lt;/a&gt;新增共享用户&lt;/h1&gt;&lt;p&gt;进入系统偏好设置，点击用户和群组，添加共享用户。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210208224302.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;设置共享&quot;&gt;&lt;a href=&quot;#设置共享&quot; class=&quot;headerlink&quot; title=&quot;设置共享&quot;&gt;&lt;/a&gt;设置共享&lt;/h1&gt;&lt;p&gt;进入系统偏好设置，点击共享，设置共享相关配置。&lt;/p&gt;
    
    </summary>
    
      <category term="OPS" scheme="http://www.jifu.io/categories/OPS/"/>
    
      <category term="MacOS" scheme="http://www.jifu.io/categories/OPS/MacOS/"/>
    
    
      <category term="Mac OS" scheme="http://www.jifu.io/tags/Mac-OS/"/>
    
      <category term="SMB" scheme="http://www.jifu.io/tags/SMB/"/>
    
      <category term="文件共享" scheme="http://www.jifu.io/tags/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>苹果 Mac 重置 SMC、NVRAM、PRAM 方法教程 - 解决 macOS 卡顿或无法启动</title>
    <link href="http://www.jifu.io/posts/3653564083/"/>
    <id>http://www.jifu.io/posts/3653564083/</id>
    <published>2021-02-06T09:02:47.000Z</published>
    <updated>2021-02-28T13:25:18.351Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206220909.jpg" alt=""></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>使用苹果 <code>mac</code> 或 <code>MacBook</code> 电脑的过程中，经常会遇到各种各样的问题和疑难杂症，比如系统卡顿、无法启动等。如果联系苹果客服技术支持，很多时候他们都会引导你首先尝试<strong>重置 SMC</strong>、<strong>重置 NVRAM 和 PRAM</strong> 等措施。</p><p>很多疑难杂症在经过<strong>重置 SMC、NVRAM、PRAM</strong> 之后都神奇地解决了。所以如果你的 Mac 也遇到了一些奇奇怪怪的问题，不妨自行尝试重置一下，有时真的会有奇效。注意：<strong>本文仅适合搭载 Intel 处理器的 Mac 电脑</strong>，配备 M1 芯片的 Mac 并不适用。</p><h1 id="Mac-重置-SMC-方法教程"><a href="#Mac-重置-SMC-方法教程" class="headerlink" title="Mac 重置 SMC 方法教程"></a>Mac 重置 SMC 方法教程</h1><p><strong>SMC</strong> 系统管理控制器，重置系统管理控制器 (SMC) 可以解决某些与电源、电池和其他功能相关的问题。包括比如电源按钮、USB 端口的电源；电池和充电；风扇和其他热能管理功能；指示灯或感应器，例如状态指示灯（睡眠状态、电池充电状态等）、突发移动感应器、环境光传感器和键盘背光；打开和合上笔记本电脑盖时的行为等等……</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206220448.webp" alt=""></p><h2 id="检查你的-Mac-是否配备-T2-芯片"><a href="#检查你的-Mac-是否配备-T2-芯片" class="headerlink" title="检查你的 Mac 是否配备 T2 芯片"></a>检查你的 Mac 是否配备 T2 芯片</h2><p>点击左上角菜单的 <code></code> →“关于本机”→“系统报告”→“控制器” 中就能看到你的 Mac 是否配备 Apple T2 芯片了。</p><h2 id="配备-T2-芯片的-Mac-重置-SMC-方法教程"><a href="#配备-T2-芯片的-Mac-重置-SMC-方法教程" class="headerlink" title="配备 T2 芯片的 Mac 重置 SMC 方法教程"></a>配备 T2 芯片的 Mac 重置 SMC 方法教程</h2><h2 id="配备-T2-芯片的笔记本电脑的重置方法-MacBook-等"><a href="#配备-T2-芯片的笔记本电脑的重置方法-MacBook-等" class="headerlink" title="配备 T2 芯片的笔记本电脑的重置方法 (MacBook 等)"></a>配备 T2 芯片的笔记本电脑的重置方法 (MacBook 等)</h2><p>重置 SMC 之前，请尝试以下步骤：</p><ol><li>将 Mac 关机。</li><li>按住电源按钮 10 秒钟，然后松开这个按钮。</li><li>等待几秒钟，然后按下电源按钮以将 Mac 开机。</li></ol><p>如果问题仍然存在，请按照以下步骤重置 SMC：</p><ol><li>将 Mac 关机。</li><li>在内建键盘上，同时按住左侧的 <code>Control</code> + <code>Option</code> (Alt) +<code>Shift</code>。Mac 可能会开机。<br><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206220528.webp" alt=""></li><li>按住全部三个按键 7 秒钟，然后在不松开按键的情况下按住电源按钮。如果 Mac 处于开机状态，它将在您按住这些按键时关机。</li><li>继续按住全部四个按键 7 秒钟，然后松开这些按键。</li><li>等待几秒钟，然后按下电源按钮以将 Mac 开机。</li></ol><a id="more"></a><h2 id="配备-T2-芯片的台式电脑-iMac-Mac-Mini-Mac-Pro-等"><a href="#配备-T2-芯片的台式电脑-iMac-Mac-Mini-Mac-Pro-等" class="headerlink" title="配备 T2 芯片的台式电脑 (iMac / Mac Mini / Mac Pro 等)"></a>配备 T2 芯片的台式电脑 (iMac / Mac Mini / Mac Pro 等)</h2><ul><li>将 Mac 关机，然后拔下电源线。</li><li>等待 15 秒钟，然后重新接回电源线。</li><li>等待 5 秒钟，然后按下电源按钮以将 Mac 开机。</li></ul><h2 id="其他-Mac-上重置-SMC-方法教程-无-T2-芯片-："><a href="#其他-Mac-上重置-SMC-方法教程-无-T2-芯片-：" class="headerlink" title="其他 Mac 上重置 SMC 方法教程 (无 T2 芯片)："></a>其他 Mac 上重置 SMC 方法教程 (无 T2 芯片)：</h2><p>如果您的 Mac 没有配备 Apple T2 安全芯片，请按照以下步骤操作。</p><h2 id="装有不可拆卸电池的笔记本电脑-MacBook"><a href="#装有不可拆卸电池的笔记本电脑-MacBook" class="headerlink" title="装有不可拆卸电池的笔记本电脑 (MacBook)"></a>装有不可拆卸电池的笔记本电脑 (MacBook)</h2><p>这类电脑包括 2009 年中至 2017 年推出的 <code>MacBook</code> 机型、2017 年或之前推出的 MacBook Air 机型，以及所有 MacBook 机型，但 MacBook（13 英寸，2009 年中）除外。</p><ol><li>将 Mac 关机。</li><li>在内建键盘上，同时按住键盘左侧的 <code>Shift</code> + <code>Control</code> + <code>Option</code> (Alt)<br><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206220617.webp" alt=""></li><li>在按住全部三个按键的情况下，按住电源按钮。</li><li>全部 4 个按键已被按下的笔记本电脑键盘</li><li>按住全部四个按键 10 秒钟。</li><li>松开所有按键，然后按下电源按钮以将 Mac 开机。</li></ol><h2 id="装有可拆卸电池的笔记本电脑-早期型号"><a href="#装有可拆卸电池的笔记本电脑-早期型号" class="headerlink" title="装有可拆卸电池的笔记本电脑 (早期型号)"></a>装有可拆卸电池的笔记本电脑 (早期型号)</h2><p>这类电脑包括 2009 年初或之前推出的所有 MacBook Pro 和 MacBook 机型，以及 MacBook（13 英寸，2009 年中）。</p><ol><li>将 Mac 关机。</li><li>拆下电池。</li><li>按住电源按钮 5 秒钟。</li><li>重新安装电池。</li><li>按下电源按钮以将 Mac 开机。</li></ol><h2 id="台式电脑-iMac-Mac-Pro-Mac-Mini-等"><a href="#台式电脑-iMac-Mac-Pro-Mac-Mini-等" class="headerlink" title="台式电脑 (iMac / Mac Pro / Mac Mini 等)"></a>台式电脑 (iMac / Mac Pro / Mac Mini 等)</h2><ol><li>将 Mac 关机，然后拔下电源线。</li><li>等待 15 秒钟，然后重新接回电源线。</li><li>等待 5 秒钟，然后按下电源按钮以将 Mac 开机。</li></ol><h2 id="重置-Mac-上的-NVRAM-或-PRAM-方法教程"><a href="#重置-Mac-上的-NVRAM-或-PRAM-方法教程" class="headerlink" title="重置 Mac 上的 NVRAM 或 PRAM 方法教程"></a>重置 Mac 上的 NVRAM 或 PRAM 方法教程</h2><p><strong>NVRAM</strong>（非易失性随机访问存储器）是一小部分内存，Mac 使用这些内存来储存某些设置。同样，PRAM（参数 RAM）也储存着类似的信息，且 <strong>NVRAM 和 PRAM 的重置步骤完全相同</strong>。</p><p>重置 NVRAM / PRAM 可以解决一些设置问题，包括音量、显示屏分辨率、启动磁盘选择、时区，以及最近的内核崩溃信息；或者<strong>解决 Mac 系统无法启动的问题</strong>。</p><h2 id="怎样重置-Mac-的-NVRAM-和-PRAM"><a href="#怎样重置-Mac-的-NVRAM-和-PRAM" class="headerlink" title="怎样重置 Mac 的 NVRAM 和 PRAM"></a>怎样重置 Mac 的 NVRAM 和 PRAM</h2><ol><li>将 Mac 关机</li><li>然后开机并立即同时按住以下四个按键：<code>Option</code> + <code>Command</code> + <code>P</code> + <code>R</code></li><li>您可以在大约 20 秒后松开这些按键，在此期间您的 Mac 可能看似在重新启动。</li></ol><ul><li>如果 Mac 电脑发出启动声，您可以在第二次启动声过后松开这些按键。</li><li>在搭载 Apple T2 安全芯片的 Mac 电脑上，您可以在 Apple 标志第二次出现并消失后松开这些按键。</li></ul><p>注意：如果您的 Mac 使用了 <code>固件密码</code> 这个组合键将不起任何作用或导致您的 Mac 从 <code>MacOS</code> 恢复功能启动。要重置 NVRAM，请先关闭固件密码。</p><p>如果你重置了 NVRAM 和 PRAM，在您的 Mac 启动后，您可能需要打开 “系统偏好设置” 并调整已重置的任何设置，例如音量、显示屏分辨率、启动磁盘选择或时区。</p><ul><li>如果您使用的是 Mac 台式电脑而非笔记本电脑，并且每次关闭 Mac 并断开 Mac 电源时，音量或时区等设置均会重置，则您可能需要更换 Mac 中的电池。这个小电池位于电脑的主板上，用于在断开 Mac 电源连接时帮助 NVRAM 保存设置。您可以携 Mac 前往 Apple 服务提供商处来更换该电池。</li><li>如果遇到了与睡眠、唤醒、电源、为 Mac 笔记本电脑电池充电有关的问题或其他与电源相关的症状，您可能需要根据本文前面的方法重置 SMC（系统管理控制器）。</li></ul><!-- # 参考资料 --><!-- > -[]() -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206220909.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;使用苹果 &lt;code&gt;mac&lt;/code&gt; 或 &lt;code&gt;MacBook&lt;/code&gt; 电脑的过程中，经常会遇到各种各样的问题和疑难杂症，比如系统卡顿、无法启动等。如果联系苹果客服技术支持，很多时候他们都会引导你首先尝试&lt;strong&gt;重置 SMC&lt;/strong&gt;、&lt;strong&gt;重置 NVRAM 和 PRAM&lt;/strong&gt; 等措施。&lt;/p&gt;
&lt;p&gt;很多疑难杂症在经过&lt;strong&gt;重置 SMC、NVRAM、PRAM&lt;/strong&gt; 之后都神奇地解决了。所以如果你的 Mac 也遇到了一些奇奇怪怪的问题，不妨自行尝试重置一下，有时真的会有奇效。注意：&lt;strong&gt;本文仅适合搭载 Intel 处理器的 Mac 电脑&lt;/strong&gt;，配备 M1 芯片的 Mac 并不适用。&lt;/p&gt;
&lt;h1 id=&quot;Mac-重置-SMC-方法教程&quot;&gt;&lt;a href=&quot;#Mac-重置-SMC-方法教程&quot; class=&quot;headerlink&quot; title=&quot;Mac 重置 SMC 方法教程&quot;&gt;&lt;/a&gt;Mac 重置 SMC 方法教程&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;SMC&lt;/strong&gt; 系统管理控制器，重置系统管理控制器 (SMC) 可以解决某些与电源、电池和其他功能相关的问题。包括比如电源按钮、USB 端口的电源；电池和充电；风扇和其他热能管理功能；指示灯或感应器，例如状态指示灯（睡眠状态、电池充电状态等）、突发移动感应器、环境光传感器和键盘背光；打开和合上笔记本电脑盖时的行为等等……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206220448.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;检查你的-Mac-是否配备-T2-芯片&quot;&gt;&lt;a href=&quot;#检查你的-Mac-是否配备-T2-芯片&quot; class=&quot;headerlink&quot; title=&quot;检查你的 Mac 是否配备 T2 芯片&quot;&gt;&lt;/a&gt;检查你的 Mac 是否配备 T2 芯片&lt;/h2&gt;&lt;p&gt;点击左上角菜单的 &lt;code&gt;&lt;/code&gt; →“关于本机”→“系统报告”→“控制器” 中就能看到你的 Mac 是否配备 Apple T2 芯片了。&lt;/p&gt;
&lt;h2 id=&quot;配备-T2-芯片的-Mac-重置-SMC-方法教程&quot;&gt;&lt;a href=&quot;#配备-T2-芯片的-Mac-重置-SMC-方法教程&quot; class=&quot;headerlink&quot; title=&quot;配备 T2 芯片的 Mac 重置 SMC 方法教程&quot;&gt;&lt;/a&gt;配备 T2 芯片的 Mac 重置 SMC 方法教程&lt;/h2&gt;&lt;h2 id=&quot;配备-T2-芯片的笔记本电脑的重置方法-MacBook-等&quot;&gt;&lt;a href=&quot;#配备-T2-芯片的笔记本电脑的重置方法-MacBook-等&quot; class=&quot;headerlink&quot; title=&quot;配备 T2 芯片的笔记本电脑的重置方法 (MacBook 等)&quot;&gt;&lt;/a&gt;配备 T2 芯片的笔记本电脑的重置方法 (MacBook 等)&lt;/h2&gt;&lt;p&gt;重置 SMC 之前，请尝试以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 Mac 关机。&lt;/li&gt;
&lt;li&gt;按住电源按钮 10 秒钟，然后松开这个按钮。&lt;/li&gt;
&lt;li&gt;等待几秒钟，然后按下电源按钮以将 Mac 开机。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果问题仍然存在，请按照以下步骤重置 SMC：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 Mac 关机。&lt;/li&gt;
&lt;li&gt;在内建键盘上，同时按住左侧的 &lt;code&gt;Control&lt;/code&gt; + &lt;code&gt;Option&lt;/code&gt; (Alt) +&lt;code&gt;Shift&lt;/code&gt;。Mac 可能会开机。&lt;br&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206220528.webp&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;按住全部三个按键 7 秒钟，然后在不松开按键的情况下按住电源按钮。如果 Mac 处于开机状态，它将在您按住这些按键时关机。&lt;/li&gt;
&lt;li&gt;继续按住全部四个按键 7 秒钟，然后松开这些按键。&lt;/li&gt;
&lt;li&gt;等待几秒钟，然后按下电源按钮以将 Mac 开机。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="OPS" scheme="http://www.jifu.io/categories/OPS/"/>
    
      <category term="MacOS" scheme="http://www.jifu.io/categories/OPS/MacOS/"/>
    
    
      <category term="Mac OS" scheme="http://www.jifu.io/tags/Mac-OS/"/>
    
      <category term="Mac" scheme="http://www.jifu.io/tags/Mac/"/>
    
      <category term="NVRAM" scheme="http://www.jifu.io/tags/NVRAM/"/>
    
      <category term="SMC" scheme="http://www.jifu.io/tags/SMC/"/>
    
      <category term="PRAM" scheme="http://www.jifu.io/tags/PRAM/"/>
    
      <category term="卡顿" scheme="http://www.jifu.io/tags/%E5%8D%A1%E9%A1%BF/"/>
    
  </entry>
  
  <entry>
    <title>深入了解 gradle 和 maven 的区别</title>
    <link href="http://www.jifu.io/posts/1797699998/"/>
    <id>http://www.jifu.io/posts/1797699998/</id>
    <published>2021-02-06T08:45:53.000Z</published>
    <updated>2021-02-28T13:25:18.350Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206215843.png" alt=""></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>gradle 和 maven 都可以用来构建 java 程序，甚至在某些情况下，两者还可以互相转换，那么他们两个的共同点和不同点是什么？我们如何在项目中选择使用哪种技术呢？一起来看看吧。</p><p>虽然 gradle 和 maven 都可以作为 java 程序的构建工具。但是两者还是有很大的不同之处的。我们可以从下面几个方面来进行分析。</p><h1 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h1><p>Google 选择 gradle 作为 android 的构建工具不是没有理由的，其中一个非常重要的原因就是因为 gradle 够灵活。一方面是因为 gradle 使用的是 groovy 或者 kotlin 语言作为脚本的编写语言，这样极大的提高了脚本的灵活性，但是其本质上的原因是 gradle 的基础架构能够支持这种灵活性。</p><p>你可以使用 gradle 来构建 native 的 C/C++ 程序，甚至扩展到任何语言的构建。</p><p>相对而言，maven 的灵活性就差一些，并且自定义起来也比较麻烦，但是 maven 的项目比较容易看懂，并且上手简单。</p><p>所以如果你的项目没有太多自定义构建需求的话还是推荐使用 maven，但是如果有自定义的构建需求，那么还是投入 gradle 的怀抱吧。</p><h1 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h1><p>虽然现在大家的机子性能都比较强劲，好像在做项目构建的时候性能的优势并不是那么的迫切，但是对于大型项目来说，一次构建可能会需要很长的时间，尤其对于自动化构建和 CI 的环境来说，当然希望这个构建是越快越好。</p><p>Gradle 和 Maven 都支持并行的项目构建和依赖解析。但是 gradle 的三个特点让 gradle 可以跑的比 maven 快上一点：</p><a id="more"></a><h2 id="增量构建"><a href="#增量构建" class="headerlink" title="增量构建"></a>增量构建</h2><p>gradle 为了提升构建的效率，提出了增量构建的概念，为了实现增量构建，gradle 将每一个 task 都分成了三部分，分别是 input 输入，任务本身和 output 输出。下图是一个典型的 java 编译的 task。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206214714.webp" alt=""></p><p>以上图为例，input 就是目标 jdk 的版本，源代码等，output 就是编译出来的 class 文件。</p><p>增量构建的原理就是监控 input 的变化，只有 input 发送变化了，才重新执行 task 任务，否则 gradle 认为可以重用之前的执行结果。</p><p>所以在编写 gradle 的 task 的时候，需要指定 task 的输入和输出。</p><p>并且要注意只有会对输出结果产生变化的才能被称为输入，如果你定义了对初始结果完全无关的变量作为输入，则这些变量的变化会导致 gradle 重新执行 task，导致了不必要的性能的损耗。</p><p>还要注意不确定执行结果的任务，比如说同样的输入可能会得到不同的输出结果，那么这样的任务将不能够被配置为增量构建任务。</p><h2 id="构建缓存"><a href="#构建缓存" class="headerlink" title="构建缓存"></a>构建缓存</h2><p>gradle 可以重用同样 input 的输出作为缓存，大家可能会有疑问了，这个缓存和增量编译不是一个意思吗？</p><p>在同一个机子上是的，但是缓存可以跨机器共享. 如果你是在一个 CI 服务的话，build cache 将会非常有用。因为 developer 的 build 可以直接从 CI 服务器上面拉取构建结果，非常的方便。</p><h2 id="Gradle-守护进程"><a href="#Gradle-守护进程" class="headerlink" title="Gradle 守护进程"></a>Gradle 守护进程</h2><p>gradle 会开启一个守护进程来和各个 build 任务进行交互，优点就是不需要每次构建都初始化需要的组件和服务。</p><p>同时因为守护进程是一个一直运行的进程，除了可以避免每次 JVM 启动的开销之外，还可以缓存项目结构，文件，task 和其他的信息，从而提升运行速度。</p><p>我们可以运行 gradle –status 来查看正在运行的 daemons 进程。</p><p>从 Gradle 3.0 之后，daemons 是默认开启的，你可以使用 org.gradle.daemon=false 来禁止 daemons。</p><p>我们可以通过下面的几个图来直观的感受一下 gradle 和 maven 的性能比较：</p><h2 id="使用-gradle-和-maven-构建-Apache-Commons-Lang-3-的比较"><a href="#使用-gradle-和-maven-构建-Apache-Commons-Lang-3-的比较" class="headerlink" title="使用 gradle 和 maven 构建 Apache Commons Lang 3 的比较"></a>使用 gradle 和 maven 构建 Apache Commons Lang 3 的比较</h2><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206214830.webp" alt=""></p><h2 id="使用-gradle-和-maven-构建小项目（10-个模块，每个模块-50-个源文件和-50-个测试文件）的比较"><a href="#使用-gradle-和-maven-构建小项目（10-个模块，每个模块-50-个源文件和-50-个测试文件）的比较" class="headerlink" title="使用 gradle 和 maven 构建小项目（10 个模块，每个模块 50 个源文件和 50 个测试文件）的比较"></a>使用 gradle 和 maven 构建小项目（10 个模块，每个模块 50 个源文件和 50 个测试文件）的比较</h2><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206214841.webp" alt=""></p><h2 id="使用-gradle-和-maven-构建大项目（500-个模块，每个模块-100-个源文件和-100-个测试文件）的比较"><a href="#使用-gradle-和-maven-构建大项目（500-个模块，每个模块-100-个源文件和-100-个测试文件）的比较" class="headerlink" title="使用 gradle 和 maven 构建大项目（500 个模块，每个模块 100 个源文件和 100 个测试文件）的比较"></a>使用 gradle 和 maven 构建大项目（500 个模块，每个模块 100 个源文件和 100 个测试文件）的比较</h2><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206214917.webp" alt=""></p><p>可以看到 gradle 性能的提升是非常明显的。</p><h1 id="依赖的区别"><a href="#依赖的区别" class="headerlink" title="依赖的区别"></a>依赖的区别</h1><p>gradle 和 maven 都可以本地缓存依赖文件，并且都支持依赖文件的并行下载。</p><p>在 maven 中只可以通过版本号来覆盖一个依赖项。而 gradle 更加灵活，你可以自定义依赖关系和替换规则，通过这些替换规则，gradle 可以构建非常复杂的项目。</p><p>因为 maven 出现的时间比较早，所以基本上所有的 java 项目都支持 maven，但是并不是所有的项目都支持 gradle。如果你有需要把 maven 项目迁移到 gradle 的想法，那么就一起来看看吧。</p><p>根据我们之前的介绍，大家可以发现 gradle 和 maven 从本质上来说就是不同的，gradle 通过 task 的 DAG 图来组织任务，而 maven 则是通过 attach 到 phases 的 goals 来执行任务。</p><p>虽然两者的构建有很大的不同，但是得益于 gradle 和 maven 相识的各种约定规则，从 maven 移植到 gradle 并不是那么难。</p><p>要想从 maven 移植到 gradle，首先要了解下 maven 的 build 生命周期，maven 的生命周期包含了 clean，compile，test，package，verify，install 和 deploy 这几个 phase。</p><p>我们需要将 maven 的生命周期 phase 转换为 gradle 的生命周期 task。这里需要使用到 gradle 的 Base Plugin，Java Plugin 和 Maven Publish Plugin。</p><p>先看下怎么引入这三个 plugin：</p><pre class="line-numbers language-bash"><code class="language-bash">plugins <span class="token punctuation">{</span>    <span class="token function">id</span> <span class="token string">'base'</span>    <span class="token function">id</span> <span class="token string">'java'</span>    <span class="token function">id</span> <span class="token string">'maven-publish'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>clean 会被转换成为 clean task，compile 会被转换成为 classes task，test 会被转换成为 test task，package 会被转换成为 assemble task，verify 会被转换成为 check task，install 会被转换成为 Maven Publish Plugin 中的 publishToMavenLocal task，deploy 会被转换成为 Maven Publish Plugin 中的 publish task。</p><p>有了这些 task 之间的对应关系，我们就可以尝试进行 maven 到 gradle 的转换了。</p><h1 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h1><p>我们除了可以使用 gradle init 命令来创建一个 gradle 的架子之外，还可以使用这个命令来将 maven 项目转换成为 gradle 项目，gradle init 命令会去读取 pom 文件，并将其转换成为 gradle 项目。</p><h1 id="转换依赖"><a href="#转换依赖" class="headerlink" title="转换依赖"></a>转换依赖</h1><p>gradle 和 maven 的依赖都包含了 group ID, artifact ID 和版本号。两者本质上是一样的，只是形式不同，我们看一个转换的例子：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上是一个 maven 的例子，我们看下 gradle 的例子怎写：</p><pre class="line-numbers language-xml"><code class="language-xml">dependencies {    implementation 'log4j:log4j:1.2.12'  }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到 gradle 比 maven 写起来要简单很多。</p><p>注意这里的 implementation 实际上是由 Java Plugin 来实现的。</p><p>我们在 maven 的依赖中有时候还会用到 scope 选项，用来表示依赖的范围，我们看下这些范围该如何进行转换：</p><h2 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h2><p>在 gradle 可以有两种配置来替换 compile，我们可以使用 implementation 或者 api。</p><p>前者在任何使用 Java Plugin 的 gradle 中都可以使用，而 api 只能在使用 Java Library Plugin 的项目中使用。</p><p>当然两者是有区别的，如果你是构建应用程序或者 webapp，那么推荐使用 implementation，如果你是在构建 Java libraries，那么推荐使用 api。</p><h2 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h2><p>可以替换成 runtimeOnly 。</p><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>gradle 中的 test 分为两种，一种是编译 test 项目的时候需要，那么可以使用 testImplementation，一种是运行 test 项目的时候需要，那么可以使用 testRuntimeOnly。</p><h2 id="provided"><a href="#provided" class="headerlink" title="provided"></a>provided</h2><p>可以替换成为 compileOnly。</p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>在 maven 中，import 经常用在 dependencyManagement 中，通常用来从一个 pom 文件中导入依赖项，从而保证项目中依赖项目版本的一致性。</p><p>在 gradle 中，可以使用 platform() 或者 enforcedPlatform() 来导入 pom 文件：</p><pre class="line-numbers language-xml"><code class="language-xml">dependencies {    implementation platform('org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE')    implementation 'com.google.code.gson:gson'    implementation 'dom4j:dom4j'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如上面的例子中，我们导入了 spring-boot-dependencies。因为这个 pom 中已经定义了依赖项的版本号，所以我们在后面引入 gson 的时候就不需要指定版本号了。</p><p>platform 和 enforcedPlatform 的区别在于，enforcedPlatform 会将导入的 pom 版本号覆盖其他导入的版本号：</p><pre class="line-numbers language-xml"><code class="language-xml">dependencies {    // import a BOM. The versions used in this file will override any other version found in the graph    implementation enforcedPlatform('org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE')    // define dependencies without versions    implementation 'com.google.code.gson:gson'    implementation 'dom4j:dom4j'    // this version will be overridden by the one found in the BOM    implementation 'org.codehaus.groovy:groovy:1.8.6'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="转换-repositories-仓库"><a href="#转换-repositories-仓库" class="headerlink" title="转换 repositories 仓库"></a>转换 repositories 仓库</h1><p>gradle 可以兼容使用 maven 或者 lvy 的 repository。gradle 没有默认的仓库地址，所以你必须手动指定一个。</p><p>你可以在 gradle 使用 maven 的仓库：</p><pre class="line-numbers language-xml"><code class="language-xml">repositories {    mavenCentral()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们还可以直接指定 maven 仓库的地址：</p><pre class="line-numbers language-xml"><code class="language-xml">repositories {    maven {        url "http://repo.mycompany.com/maven2"    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你想使用 maven 本地的仓库，则可以这样使用：</p><pre class="line-numbers language-xml"><code class="language-xml">repositories {    mavenLocal()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是 mavenLocal 是不推荐使用的，为什么呢？</p><p>mavenLocal 只是 maven 在本地的一个 cache，它包含的内容并不完整。比如说一个本地的 maven repository module 可能只包含了 jar 包文件，并没有包含 source 或者 javadoc 文件。那么我们将不能够在 gradle 中查看这个 module 的源代码，因为 gradle 会首先在 maven 本地的路径中查找这个 module。</p><p>并且本地的 repository 是不可信任的，因为里面的内容可以轻易被修改，并没有任何的验证机制。</p><h1 id="控制依赖的版本"><a href="#控制依赖的版本" class="headerlink" title="控制依赖的版本"></a>控制依赖的版本</h1><p>如果同一个项目中对同一个模块有不同版本的两个依赖的话，默认情况下 Gradle 会在解析完 DAG 之后，选择版本最高的那个依赖包。</p><p>但是这样做并不一定就是正确的， 所以我们需要自定义依赖版本的功能。</p><p>首先就是上面我们提到的使用 platform() 和 enforcedPlatform() 来导入 BOM（packaging 类型是 POM 的）文件。</p><p>如果我们项目中依赖了某个 module，而这个 module 又依赖了另外的 module，我们叫做传递依赖。在这种情况下，如果我们希望控制传递依赖的版本，比如说将传递依赖的版本升级为一个新的版本，那么可以使用 dependency constraints：</p><pre class="line-numbers language-xml"><code class="language-xml">dependencies {    implementation 'org.apache.httpcomponents:httpclient'    constraints {        implementation('org.apache.httpcomponents:httpclient:4.5.3') {            because 'previous versions have a bug impacting this application'        }        implementation('commons-codec:commons-codec:1.11') {            because 'version 1.9 pulled from httpclient has bugs affecting this application'        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，dependency constraints 只对传递依赖有效，如果上面的例子中 commons-codec 并不是传递依赖，那么将不会有任何影响。</p><p>同时 Dependency constraints 需要 Gradle Module Metadata 的支持，也就是说只有你的 module 是发布在 gradle 中才支持这个特性，如果是发布在 maven 或者 ivy 中是不支持的。</p></blockquote><p>上面讲的是传递依赖的版本升级。同样是传递依赖，如果本项目也需要使用到这个传递依赖的 module，但是需要使用到更低的版本（因为默认 gradle 会使用最新的版本），就需要用到版本降级了。</p><pre class="line-numbers language-xml"><code class="language-xml">dependencies {    implementation 'org.apache.httpcomponents:httpclient:4.5.4'    implementation('commons-codec:commons-codec') {        version {            strictly '1.9'        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以在 implementation 中指定特定的 version 即可。</p><p>strictly 表示的是强制匹配特定的版本号，除了 strictly 之外，还有 require，表示需要的版本号大于等于给定的版本号。prefer，如果没有指定其他的版本号，那么就使用 prefer 这个。reject，拒绝使用这个版本。</p><p>除此之外，你还可以使用 Java Platform Plugin 来指定特定的 platform，从而限制版本号。</p><p>最后看一下如何 exclude 一个依赖：</p><pre class="line-numbers language-xml"><code class="language-xml">dependencies {    implementation('commons-beanutils:commons-beanutils:1.9.4') {        exclude group: 'commons-collections',        module: 'commons-collections'    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多模块项目"><a href="#多模块项目" class="headerlink" title="多模块项目"></a>多模块项目</h2><p>maven 中可以创建多模块项目：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>simple-weather<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>simple-webapp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以在 gradle 中做同样的事情 settings.gradle：</p><pre class="line-numbers language-gradle"><code class="language-gradle">rootProject.name = 'simple-multi-module'  include 'simple-weather', 'simple-webapp'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="profile-和属性"><a href="#profile-和属性" class="headerlink" title="profile 和属性"></a>profile 和属性</h1><p>maven 中可以使用 profile 来区别不同的环境，在 gradle 中，我们可以定义好不同的 profile 文件，然后通过脚本来加载他们：</p><p>build.gradle：</p><pre class="line-numbers language-gradle"><code class="language-gradle">if (!hasProperty('buildProfile')) ext.buildProfile = 'default'apply from: "profile-${buildProfile}.gradle"task greeting {    doLast {        println message    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>profile-default.gradle：</p><pre class="line-numbers language-gradle"><code class="language-gradle">ext.message = 'foobar'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>profile-test.gradle：</p><pre class="line-numbers language-gradle"><code class="language-gradle">ext.message = 'testing 1 2 3'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以这样来运行：</p><pre class="line-numbers language-gradle"><code class="language-gradle">> gradle greetingfoobar> gradle -PbuildProfile=test greetingtesting 1 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="资源处理"><a href="#资源处理" class="headerlink" title="资源处理"></a>资源处理</h1><p>在 maven 中有一个 process-resources 阶段，可以执行 resources:resources 用来进行 resource 文件的拷贝操作。</p><p>在 Gradle 中的 Java plugin 的 processResources task 也可以做相同的事情。</p><p>比如我可以执行 copy 任务：</p><pre class="line-numbers language-gradle"><code class="language-gradle">task copyReport(type: Copy) {    from file("buildDir/reports/my-report.pdf")    into file("buildDir/toArchive")}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>更加复杂的拷贝：</p><pre class="line-numbers language-gradle"><code class="language-gradle">task copyPdfReportsForArchiving(type: Copy) {    from "buildDir/reports"    include "*.pdf"    into "buildDir/toArchive"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然拷贝还有更加复杂的应用。这里就不详细讲解了。</p><!-- # 参考资料 --><!-- > -[]() -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210206215843.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;gradle 和 maven 都可以用来构建 java 程序，甚至在某些情况下，两者还可以互相转换，那么他们两个的共同点和不同点是什么？我们如何在项目中选择使用哪种技术呢？一起来看看吧。&lt;/p&gt;
&lt;p&gt;虽然 gradle 和 maven 都可以作为 java 程序的构建工具。但是两者还是有很大的不同之处的。我们可以从下面几个方面来进行分析。&lt;/p&gt;
&lt;h1 id=&quot;可扩展性&quot;&gt;&lt;a href=&quot;#可扩展性&quot; class=&quot;headerlink&quot; title=&quot;可扩展性&quot;&gt;&lt;/a&gt;可扩展性&lt;/h1&gt;&lt;p&gt;Google 选择 gradle 作为 android 的构建工具不是没有理由的，其中一个非常重要的原因就是因为 gradle 够灵活。一方面是因为 gradle 使用的是 groovy 或者 kotlin 语言作为脚本的编写语言，这样极大的提高了脚本的灵活性，但是其本质上的原因是 gradle 的基础架构能够支持这种灵活性。&lt;/p&gt;
&lt;p&gt;你可以使用 gradle 来构建 native 的 C/C++ 程序，甚至扩展到任何语言的构建。&lt;/p&gt;
&lt;p&gt;相对而言，maven 的灵活性就差一些，并且自定义起来也比较麻烦，但是 maven 的项目比较容易看懂，并且上手简单。&lt;/p&gt;
&lt;p&gt;所以如果你的项目没有太多自定义构建需求的话还是推荐使用 maven，但是如果有自定义的构建需求，那么还是投入 gradle 的怀抱吧。&lt;/p&gt;
&lt;h1 id=&quot;性能比较&quot;&gt;&lt;a href=&quot;#性能比较&quot; class=&quot;headerlink&quot; title=&quot;性能比较&quot;&gt;&lt;/a&gt;性能比较&lt;/h1&gt;&lt;p&gt;虽然现在大家的机子性能都比较强劲，好像在做项目构建的时候性能的优势并不是那么的迫切，但是对于大型项目来说，一次构建可能会需要很长的时间，尤其对于自动化构建和 CI 的环境来说，当然希望这个构建是越快越好。&lt;/p&gt;
&lt;p&gt;Gradle 和 Maven 都支持并行的项目构建和依赖解析。但是 gradle 的三个特点让 gradle 可以跑的比 maven 快上一点：&lt;/p&gt;
    
    </summary>
    
      <category term="Android Development" scheme="http://www.jifu.io/categories/Android-Development/"/>
    
    
      <category term="Android" scheme="http://www.jifu.io/tags/Android/"/>
    
      <category term="gradle" scheme="http://www.jifu.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>在 M1 芯片 Mac 上使用 Homebrew</title>
    <link href="http://www.jifu.io/posts/1525358532/"/>
    <id>http://www.jifu.io/posts/1525358532/</id>
    <published>2021-01-02T11:00:00.000Z</published>
    <updated>2021-02-28T13:25:18.351Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Homebrew 是 Mac 上管理软件包的最实用工具之一。但截至目前，它还没有对搭载 Apple silicon 的新 Mac 机型完成适配。根据维护者在 GitHub 上发布的<a href="https://github.com/Homebrew/brew/issues/7857#issue-647960270" target="_blank" rel="noopener">说明</a>，Homebrew 正在积极适配新架构的过程中，但目前还面临一些较大障碍，如缺少基于 ARM 架构的持续集成框架、很多软件包依赖的框架或编译器（<code>go</code>、<code>gcc</code>、<code>qt</code>）未适配等。</p><p>但是，Homebrew 目前在新 Mac 上仍然是可用的，并且已经发布了原生支持 ARM 架构的实验性版本。本文总结我在设置过程中探索出可行、相对实用的做法。</p><p>概括而言：</p><ul><li>在不同路径分别安装针对 X86 和 ARM 架构的两个 Homebrew 版本；</li><li>优先使用 ARM 版 Homebrew 安装软件包，用 X86 版 Homebrew 安装尚未支持新平台的命令行软件；</li><li>使用 Homebrew Bundle 功能从旧 Mac 或 X86 版 Homebrew 迁移软件包。</li></ul><p>后文将展开说明具体步骤。由于 ARM 版 Homebrew 仍然处于早期开发阶段，且我对终端环境下系统管理的了解相对粗浅，文章内容难免存在过时或不准确之处，请不吝指正。</p><p><img src="https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210104012409.png" alt=""></p><a id="more"></a><h2 id="1-安装-ARM-版-Homebrew"><a href="#1-安装-ARM-版-Homebrew" class="headerlink" title="1. 安装 ARM 版 Homebrew"></a>1. 安装 ARM 版 Homebrew</h2><p>根据官方规划，ARM 版 Homebrew 必须安装在 <code>/opt/homebrew</code> 路径下，而非此前的 <code>/usr/local/Homebrew</code>。由于官方的安装脚本还未更新，可以通过如下命令手动安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /opt <span class="token comment" spellcheck="true"># 切换到 /opt 目录</span><span class="token function">mkdir</span> homebrew <span class="token comment" spellcheck="true"># 创建 homebrew 目录</span>curl -L https://github.com/Homebrew/brew/tarball/master <span class="token operator">|</span> <span class="token function">tar</span> xz --strip 1 -C homebrew<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（<strong>注：</strong> 如果安装和使用过程中报错，可能是因为当前用户对于 <code>/opt/homebrew</code> 路径没有权限。对此，可以通过 <code>sudo chown -R $(whoami) /opt/homebrew</code> 接管该目录。）</p><p>虽然上面的步骤已经安装了 ARM 版 Homebrew，但此时在终端中运行 <code>brew</code> 命令并不能直接启动该版本。这是因为默认情况下，ARM 版 Homebrew 用来安装程序的路径 <code>/opt/homebrew/bin</code> 并不在环境变量 <code>PATH</code> 中，因此终端无法检索到该路径下的 <code>brew</code> 程序。</p><p>为此，编辑配置文件 <code>~/.zshrc</code>，加入如下内容：</p><pre class="line-numbers language-bash"><code class="language-bash">path<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'/opt/homebrew/bin'</span> <span class="token variable">$path</span><span class="token punctuation">)</span><span class="token function">export</span> PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（<strong>注：</strong> 本文推定读者使用 macOS Big Sur 的默认终端 zsh，如使用 bash 或 fish，则修改 <code>~/.bashrc</code> 或 <code>~/.config/fish/config.fish</code>，后同。）</p><p>然后重新启动终端。这样，直接执行 <code>brew</code> 就可以启动 ARM 版的 Homebrew 了。</p><hr><h3 id="跑题：为什么-ARM-版-Mac-要使用-opt-路径？"><a href="#跑题：为什么-ARM-版-Mac-要使用-opt-路径？" class="headerlink" title="跑题：为什么 ARM 版 Mac 要使用 /opt 路径？"></a>跑题：为什么 ARM 版 Mac 要使用 <code>/opt</code> 路径？</h3><p>根据《文件系统层次结构标准》（<a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html" target="_blank" rel="noopener">Filesystem Hierarchy Standard</a>，主要为 Linux 系统制定，但对具有共同 UNIX 基因的 macOS 也有参考价值）：</p><ul><li><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch04s09.html" target="_blank" rel="noopener"><code>/usr/local</code></a> 目录用于系统管理员在本地安装软件。系统软件更新时，该目录应免于被覆盖。</li><li><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s13.html" target="_blank" rel="noopener"><code>/opt</code></a> 目录留作附加应用程序（add-on application）软件包的安装。安装在该目录下的软件包必须将其静态文件放置在单独的 <code>/opt/&lt;package&gt;</code> 或 <code>/opt/&lt;provider&gt;</code> 路径下。</li></ul><p>历史上，<code>/usr/local</code> 主要用于放置在本地编译并另行安装的程序，避免和 <code>/usr</code> 下的系统自带版本冲突；而 <code>/opt</code> 则用于安装非系统自带的、第三方预先编译并发行的独立软件包。</p><p>显然，在如今的 macOS 使用场景下，用户很少会需要自行编译软件包，<code>/usr/local</code> 和 <code>/opt</code> 的区分一定程度上已经成为名义上的了。Homebrew 启用 <code>/opt</code> 作为 ARM 版的安装路径，可能更多是出于确保与 X86 版相互区隔的考虑。</p><hr><h2 id="2-安装-X86-版-Homebrew"><a href="#2-安装-X86-版-Homebrew" class="headerlink" title="2. 安装 X86 版 Homebrew"></a>2. 安装 X86 版 Homebrew</h2><p>如上所述，由于很多软件包目前还没有适配 ARM 架构（可以在 <a href="https://github.com/Homebrew/brew/issues/7857" target="_blank" rel="noopener">Homebrew 的 Apple silicon issue 页面</a>查询），无法通过 ARM 版 Homebrew 安装，因此我们还需要安装一份 X86 版的 Homebrew 备用。</p><p>X86 版 Homebrew 无法在 ARM 环境下安装。为此，需要先启动一个 X86 环境的终端。网络上<a href="https://osxdaily.com/2020/11/18/how-run-homebrew-x86-terminal-apple-silicon-mac/" target="_blank" rel="noopener">传播较广</a>的方法是创建一个 Terminal.app 的副本，然后令其在 Rosetta 兼容模式下运行，显得有些麻烦。</p><p>其实，注意到在任何命令前增加 <code>arch -x86_64</code>，就可以以 X86 模式运行该命令。因此，运行：</p><pre class="line-numbers language-bash"><code class="language-bash">arch -x86_64 <span class="token variable">$SHELL</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以启动一个 X86 模式终端，使得之后运行的命令都在 X86 模式下运行。</p><p>此时，运行 Homebrew 的官方安装脚本</p><pre class="line-numbers language-bash"><code class="language-bash">/bin/bash -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh<span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以完成 X86 版 Homebrew 的安装。</p><h2 id="3-ARM-和-X86-版-Homebrew-的共存问题"><a href="#3-ARM-和-X86-版-Homebrew-的共存问题" class="headerlink" title="3. ARM 和 X86 版 Homebrew 的共存问题"></a>3. ARM 和 X86 版 Homebrew 的共存问题</h2><p>经过上面的步骤，系统中目前有了两个 <code>brew</code> 程序，即 X86 版的 <code>/usr/local/bin/brew</code> 和 ARM 版的 <code>/opt/homebrew/bin/brew</code>。那么，当在终端中执行 <code>brew</code> 命令时，系统会以哪个为准呢？</p><p>当存在重名程序时，终端会按照重名程序在环境变量 <code>PATH</code> 中的先后顺序选择要执行的版本。由于之前配置 <code>~/.zshrc</code> 时，将 ARM 版 Homebrew 的路径放在了 <code>PATH</code> 的最前面，因此执行 <code>brew</code> 时，位于 <code>/opt/homebrew/bin/brew</code> 的 ARM 版将被优先运行。如果要运行 X86 版，则需要手动输入完整路径 <code>arch -x86_64 /usr/local/bin/brew</code>。</p><p>如果觉得输入这么长的命令过于麻烦，可以在 <code>~/.zshrc</code> 中为两个版本分别设置简称（alias）：</p><pre class="line-numbers language-bash"><code class="language-bash">abrew<span class="token operator">=</span><span class="token string">'/opt/homebrew/bin/brew'</span> <span class="token comment" spellcheck="true"># ARM Homebrew</span>ibrew<span class="token operator">=</span><span class="token string">'arch -x86_64 /usr/local/bin/brew'</span> <span class="token comment" spellcheck="true"># X86 Homebrew</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，执行 <code>abrew install &lt;package&gt;</code> 就可以调用 ARM 版 Homebrew 安装软件包，执行 <code>ibrew install &lt;package&gt;</code> 就可以调用 X86 版，从而不容易混淆。</p><p>至于应该使用哪个版本的 Homebrew 安装软件包，需要区别考虑：</p><ul><li>对于<strong>命令行（CLI）程序</strong>：可以<strong>优先尝试使用 ARM 版 Homebrew 安装</strong>，保证获得针对新架构编译的版本，实现最佳的运行效果。但注意：</li><li>有的软件包已经兼容新架构、但还没有发布相应的编译版，需要安装的过程中在本地编译，耗时会相对很长；</li><li>如果软件包还没有兼容新架构，使用 ARM 版 Homebrew 安装会报错，此时可以换用 X86 版 Homebrew 安装。</li><li>对于<strong>图形界面（GUI）程序</strong>，即通过 Homebrew Cask 安装的 <code>.app</code> 程序：对于这类软件，Homebrew 起的作用只是从官方渠道下载这些软件的安装包，然后安装到 <code>/Applications</code> 路径（及执行安装脚本，如果有）。因此无论其是否针对新架构优化，通过任一版本 Homebrew 都可以安装。考虑到日后维护方便，建议<strong>直接用 ARM 版 Homebrew 安装</strong>即可。</li></ul><h2 id="4-从旧-Mac（或-X86-版-Homebrew）迁移软件包"><a href="#4-从旧-Mac（或-X86-版-Homebrew）迁移软件包" class="headerlink" title="4. 从旧 Mac（或 X86 版 Homebrew）迁移软件包"></a>4. 从旧 Mac（或 X86 版 Homebrew）迁移软件包</h2><p>如果你在拿到 M1 版 Mac 以后，选择了从旧 Mac 迁移数据、或恢复 Time Machine 备份，那么系统中可能已经有了遗留的 X86 版 Homebrew 和用它安装的软件包。此外，你可能也希望将以往惯用的软件包无遗漏地迁移到新 Mac。这些情况下，可以使用 Homebrew Bundle 功能辅助迁移工作。</p><p>要导出使用 X86 版 Homebrew 安装的软件包列表，运行：</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/local/bin/brew bundle dump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就能在当前目录下得到一个名为 <code>Brewfile</code> 的备份文件。该文件可以用普通文本编辑器打开，列举了所有已安装软件包、添加的第三方软件源（tap）、Homebrew Cask 管理的 GUI 程序和 <a href="https://github.com/mas-cli/mas" target="_blank" rel="noopener">mas-cli</a> 管理的 Mac App Store 程序：</p><pre class="line-numbers language-bash"><code class="language-bash">tap <span class="token string">"homebrew/bundle"</span>tap <span class="token string">"homebrew/cask"</span><span class="token punctuation">[</span>…<span class="token punctuation">]</span>brew <span class="token string">"dash"</span>brew <span class="token string">"ffmpeg"</span><span class="token punctuation">[</span>…<span class="token punctuation">]</span>cask <span class="token string">"bartender"</span>cask <span class="token string">"bettertouchtool"</span><span class="token punctuation">[</span>…<span class="token punctuation">]</span>mas <span class="token string">"Apple Configurator 2"</span>, id: 1037126344mas <span class="token string">"Aviary"</span>, id: 1522043420<span class="token punctuation">[</span>…<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>记下 Brewfile 的路径。然后，使用 ARM 版 Homebrew 导入其内容并安装：</p><pre class="line-numbers language-bash"><code class="language-bash">/opt/homebrew/bin/brew bundle --file /path/to/Brewfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就完成了迁移。</p><p>需要注意的是，如果你是在同一台机器的两版 Homebrew 间迁移，那么并不需要迁移通过 Homebrew Cask 和 App Store 安装的 GUI 程序（Homebrew 也不会允许覆盖安装）。这时，可以手动编辑上述 <code>Brewfile</code>，将以 <code>cask</code> 和 <code>mas</code> 开头的记录删除，然后再通过 <code>brew bundle</code> 导入。</p><p>如果想让 ARM 版 Homebrew 接管已经安装的 Homebrew Cask 软件，只要将位于 <code>/usr/local/Caskroom</code> 下的各文件夹移动到 <code>/opt/homebrew/Caskroom</code> 即可：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mv</span> /usr/local/Caskroom/* /opt/homebrew/Caskroom<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;Homebrew 是 Mac 上管理软件包的最实用工具之一。但截至目前，它还没有对搭载 Apple silicon 的新 Mac 机型完成适配。根据维护者在 GitHub 上发布的&lt;a href=&quot;https://github.com/Homebrew/brew/issues/7857#issue-647960270&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;说明&lt;/a&gt;，Homebrew 正在积极适配新架构的过程中，但目前还面临一些较大障碍，如缺少基于 ARM 架构的持续集成框架、很多软件包依赖的框架或编译器（&lt;code&gt;go&lt;/code&gt;、&lt;code&gt;gcc&lt;/code&gt;、&lt;code&gt;qt&lt;/code&gt;）未适配等。&lt;/p&gt;
&lt;p&gt;但是，Homebrew 目前在新 Mac 上仍然是可用的，并且已经发布了原生支持 ARM 架构的实验性版本。本文总结我在设置过程中探索出可行、相对实用的做法。&lt;/p&gt;
&lt;p&gt;概括而言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在不同路径分别安装针对 X86 和 ARM 架构的两个 Homebrew 版本；&lt;/li&gt;
&lt;li&gt;优先使用 ARM 版 Homebrew 安装软件包，用 X86 版 Homebrew 安装尚未支持新平台的命令行软件；&lt;/li&gt;
&lt;li&gt;使用 Homebrew Bundle 功能从旧 Mac 或 X86 版 Homebrew 迁移软件包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后文将展开说明具体步骤。由于 ARM 版 Homebrew 仍然处于早期开发阶段，且我对终端环境下系统管理的了解相对粗浅，文章内容难免存在过时或不准确之处，请不吝指正。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jifu-pub-images.oss-ap-southeast-2.aliyuncs.com/20210104012409.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OPS" scheme="http://www.jifu.io/categories/OPS/"/>
    
      <category term="MacOS" scheme="http://www.jifu.io/categories/OPS/MacOS/"/>
    
    
      <category term="Homebrew" scheme="http://www.jifu.io/tags/Homebrew/"/>
    
      <category term="Mac" scheme="http://www.jifu.io/tags/Mac/"/>
    
      <category term="M1" scheme="http://www.jifu.io/tags/M1/"/>
    
      <category term="Mac Silicon" scheme="http://www.jifu.io/tags/Mac-Silicon/"/>
    
  </entry>
  
  <entry>
    <title>REST Client 简单好用的接口测试辅助工具</title>
    <link href="http://www.jifu.io/posts/4165683660/"/>
    <id>http://www.jifu.io/posts/4165683660/</id>
    <published>2020-09-26T01:00:23.000Z</published>
    <updated>2020-09-26T08:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>今天给大家介绍一个后端开发辅助的好工具 —— REST Client，插件如其名这就是一个 REST 的客户端插件，把我们的 VSCode 转化为一个 REST 接口测试的利器</p><p><img src="https://www.jifu.io/images/2/rest-client-1024x357.png" alt="REST Client"></p><p>我们一般都会用 PostMan 来完成接口测试的工作，因为用起来十分简单快捷，但是一直以来我也在寻找更好的方案，一个不用切换窗口多开一个 app 的方案 —— 终于在使用 VSCode 一段时版本间，我找到了 REST Client 插件，初看 REST Client 插件的时候，会觉得他十分的简陋，但是在使用一段时间后会发现在 REST Client 插件中已经有完成接口测试所需的所有东西</p><ul><li><p>优势</p><ul><li>基于 HTTP 语言，HTTP 语言是一门非常简单的语言，使用 HTTP 语言可以轻松的描述请求</li><li>纯文本记录，不同于 PostMan 保存在云端，或是 Paw 那样保存二进制文件，并且纯文本可以使用 git 追踪内容的变化</li><li>无需切换窗口，测试，调试，代码编辑都在一个 VSCode 中完成</li></ul></li><li><p>劣势</p><ul><li>操作和使用不像 PostMan 之类的图形化工具那么直观</li><li>不支持请求前后对数据进行操作的脚本，不过这个已经在作者的开发计划中</li></ul></li></ul><p>很多时候我们只是需要写完代码后手边有一个小工具可以轻松愉快的看一眼接口是否正常，那么 REST Client 就是我们的首选了</p><a id="more"></a><h1 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h1><h2 id="安装和入门"><a href="#安装和入门" class="headerlink" title="安装和入门"></a>安装和入门</h2><p>插件的安装非常简单，搜索 rest client 即可安装</p><p><img src="https://www.jifu.io/images/2/rest-client-1024x357.png" alt="REST Client"></p><p>安装完成后，可以在命令菜单中找到 REST Client 相关的功能</p><p><img src="https://www.jifu.io/images/2/3051655427-5c551c5dee7cd_articlex.png" alt="菜单"></p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>我们先从发送最简单的请求开始</p><p>首先需要新建一个 http 文件，创建文件时后缀为 http 即可，例如 test.http</p><p>之后输入下面的内容：</p><pre class="line-numbers language-bash"><code class="language-bash">GET http://localhost:8000/api/v1/public/echo?msg<span class="token operator">=</span>1345asdf HTTP/1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>echo 是一个测试服务，他会返回你传入的 msg 的内容，输入完上面的</p><p>这时候请求上面会显示一个 “Send Request” 按钮，点击即可发送请求，请求完成后，插件会分割当前窗口将新的结果打开在右侧的窗口中，下图中显示了请求的所有相关信息</p><p><img src="https://www.jifu.io/images/2/4044108620-5c551c5e13765_articlex.png" alt="Send Request"></p><h2 id="HTTP-语言基础"><a href="#HTTP-语言基础" class="headerlink" title="HTTP 语言基础"></a>HTTP 语言基础</h2><h3 id="语言入门"><a href="#语言入门" class="headerlink" title="语言入门"></a>语言入门</h3><p>HTTP 是一个非常简单的语言，入门仅需几分钟</p><p><img src="https://www.jifu.io/images/2/4065194796-5c551c5e1eb16_articlex.png" alt="HTTP 语言入门"></p><p>最基本的 HTTP 语言语法入门可以参看上面的内容，配合 VSCode 的自动提示功能，用起来简直不要太快</p><p>也不用担心是否记得 header 里面那些选项，想不起来的时候 <code>Ctrl + 空格</code> 调出自动提示即可</p><p>要注意的地方</p><ol><li>请求文本最后面需要有一个空行，或者一个 <code>#</code> 开头的行，建议空行，这样多个请求看起来会非常好看</li><li>如果需要把 <code>form</code> 类型的参数拆分为多行，那么第二个参数开始必须以 <code>&amp;</code> 开始（如图）</li><li>GET 请求也可以将参数拆分多行，每行开头必须以 <code>?</code> 或者 <code>&amp;</code> 开始</li></ol><h3 id="发送文件"><a href="#发送文件" class="headerlink" title="发送文件"></a>发送文件</h3><p>一般来说，我们使用 <code>multipart/form-data</code> 请求方式来完成</p><p><img src="https://www.jifu.io/images/2/1893282788-5c551c5dad0b8_articlex.png" alt="multipart/form-data"></p><p>如图配置，REST Client 就会将文件内容填充到相应的区域完成发送</p><h4 id="保存请求结果"><a href="#保存请求结果" class="headerlink" title="保存请求结果"></a>保存请求结果</h4><p>对于返回图片的接口在 VSCode 中是可以直接预览的，如果是 Excel 之类的二进制文件，那么这里可能会显示乱码（二进制文件）</p><p><img src="https://www.jifu.io/images/2/1457627467-5c551c5d89561_articlex.png" alt="返回图片的接口"></p><p>选中相应结果页，右上角提供了保存结果的按钮</p><p><img src="https://www.jifu.io/images/2/1873457666-5c551c5d5cd39_articlex.png" alt="保存结果"></p><h3 id="查看请求历史"><a href="#查看请求历史" class="headerlink" title="查看请求历史"></a>查看请求历史</h3><p>使用 <code>Ctrl + Alt + H</code>（macOS 使用 <code>Cmd + option + H</code>）查看请求历史</p><p><img src="https://www.jifu.io/images/2/1319977100-5c551c5d64ae9_articlex.png" alt="请求历史"></p><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>变量的好处，在开发过程中我们都知道，在 HTTP 语言中同样可以使用变量来帮助我们组织请求代码</p><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><p>我们可以在 http 文件中直接定义变量，使用 <code>@</code> 符号开头，以 <code>{ {variable name} }</code> 的格式来使用</p><pre><code>@host = http://localhost:8000@token = adsfasdfasdfadsfasdfasdfas### testGET { {host} }/api/v1/public/echo HTTP/1.1    ?msg=1345asdf    &amp;bundle_id=demo    &amp;test=1    &amp;token={ {token} }### test requestPOST { {host} }/api/v1/public/echo HTTP/1.1Content-Type: application/x-www-form-urlencodedUser-Agent: iPhonetest=1&amp;bundle_id=demo&amp;msg=123123&amp;token={ {token} }</code></pre><p>这样在测试验证不同环境接口正确性的场合，我们可以很方便的在不同服务器之间切换，或是所有接口都使用同一个参数的时候非常方便例如上面的 token 应该是大部分接口都会使用到的</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>除了使用自定义变量以外还可以对当前的项目或是创建编辑器全局的环境变量</p><pre><code>&quot;rest-client.environmentVariables&quot;: {    &quot;$shared&quot;: {        &quot;version&quot;: &quot;v1&quot;    },    &quot;local&quot;: {        &quot;version&quot;: &quot;v2&quot;,        &quot;host&quot;: &quot;http://localhost:8000&quot;,        &quot;token&quot;: &quot;tokentokentokentoken1&quot;    },    &quot;prod&quot;: {        &quot;host&quot;: &quot;http://api.xxxxxx.com&quot;,        &quot;token&quot;: &quot;tokentokentoken2&quot;    }}</code></pre><p>上面 <code>$shared</code> 中的变量表示在所有环境设置中都可以使用的</p><p>设置后可通过 <code>Ctrl + Alt + E</code>（<code>Cmd + option + E</code>）切换环境</p><p><img src="https://www.jifu.io/images/2/2890371372-5c551c5d44fd0_articlex.png" alt="环境变量切换"></p><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>REST Client 提供了一些自带的系统变量，方便我们直接使用（这里由于我没有使用过 Azure 所以跳过了 Azure 相关的变量，大家可以参考文档使用）</p><ul><li><code>{ { $guid} }</code>: 生成一个 UUID</li><li><code>{ { $randomInt min max} }</code>: 生成随机整数</li><li><code>{ { $timestamp [offset option]} }</code>: 生成时间戳，可以使用类似 <code>{ { $timestamp -3 d} }</code> 生成3天前的时间戳，或是使用 <code>{ { $timestamp 2 h} }</code> 这样的形式生成2小时后的时间戳</li><li><code>{ { $datetime rfc1123|iso8601 [offset option]} }</code>: 生成日期字符串</li></ul><h2 id="VSCode-提供的辅助功能"><a href="#VSCode-提供的辅助功能" class="headerlink" title="VSCode 提供的辅助功能"></a>VSCode 提供的辅助功能</h2><p>VSCode 对我们使用 HTTP 语言提供了包括自动提示，Outline 代码导航功能，方便我们编写接口测试代码</p><h3 id="自动提示"><a href="#自动提示" class="headerlink" title="自动提示"></a>自动提示</h3><p><img src="https://www.jifu.io/images/2/666268994-5c551c5d3186b_articlex.png" alt="自动提示"></p><h3 id="Outline-以及代码导航"><a href="#Outline-以及代码导航" class="headerlink" title="Outline 以及代码导航"></a>Outline 以及代码导航</h3><p><img src="https://www.jifu.io/images/2/2194056873-5c551c5d03233_articlex.png" alt="Outline 和代码导航"></p><h3 id="验证和证书"><a href="#验证和证书" class="headerlink" title="验证和证书"></a>验证和证书</h3><h4 id="Basic-Auth"><a href="#Basic-Auth" class="headerlink" title="Basic Auth"></a>Basic Auth</h4><p>Basic Auth 可以使用已经 Base64 后的 <code>username:password</code>，也可以直接填入 <code>username</code> 和 <code>password</code>，也就是下面两种形式都是可以的</p><p>使用 Base64 的结果</p><pre class="line-numbers language-bash"><code class="language-bash">POST <span class="token punctuation">{</span> <span class="token punctuation">{</span> host<span class="token punctuation">}</span> <span class="token punctuation">}</span> /api/v1/public/echo HTTP/1.1Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 <code>username</code> 和 <code>password</code></p><pre class="line-numbers language-bash"><code class="language-bash">POST <span class="token punctuation">{</span> <span class="token punctuation">{</span> host<span class="token punctuation">}</span> <span class="token punctuation">}</span> /api/v1/public/echo HTTP/1.1Authorization: Basic username password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Digest-Auth"><a href="#Digest-Auth" class="headerlink" title="Digest Auth"></a>Digest Auth</h4><p>Digest Auth 直接填入 <code>username</code> 和 <code>password</code> 即可</p><pre class="line-numbers language-bash"><code class="language-bash">POST <span class="token punctuation">{</span> <span class="token punctuation">{</span> host<span class="token punctuation">}</span> <span class="token punctuation">}</span> /api/v1/public/echo HTTP/1.1Authorization: Digest username password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="SSL-证书"><a href="#SSL-证书" class="headerlink" title="SSL 证书"></a>SSL 证书</h4><p>ssl 证书在设置文件中对特定域名指定证书路径后，就可以自动生效了</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"rest-client.certificates"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"localhost:8081"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"cert"</span><span class="token keyword">:</span> <span class="token string">"/Users/demo/Certificates/client.crt"</span>,        <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token string">"/Users/demo/Keys/client.key"</span>    <span class="token punctuation">}</span>,    <span class="token string">"example.com"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"cert"</span><span class="token keyword">:</span> <span class="token string">"/Users/demo/Certificates/client.crt"</span>,        <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token string">"/Users/demo/Keys/client.key"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个 host 我们可以设置下面的内容：</p><ul><li>cert: x509 证书路径</li><li>key: 私钥路径</li><li>pfx: PKCS #12 或者 PFX 证书路径</li><li>passphrase: 证书密码（需要时设置）</li></ul><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>曾经使用 Postman 的时候，Postman 的代码生成功能为我提供了非常多的方便，REST Client 中提供了同样的功能</p><p>选中一个请求后，点击右键选择 <code>Copy Request As cURL</code> 可以把当前的请求复制成 curl 的命令，也可以使用 <code>Ctrl + Alt + C</code>（macOS 下<code>Cmd + Option + C</code>）呼出代码生成菜单，选择需要生成的语言</p><p><img src="https://www.jifu.io/images/2/1429311122-5c551c5d0c361_articlex.png" alt="选择代码生成语言"></p><p>选择语言后选择具体代码调用的方式，比如 python 可以使用 <code>http.client</code> 库或者 <code>Requests</code> 库来发送请求</p><p><img src="https://www.jifu.io/images/2/2502776079-5c551c5cda9f9_articlex.png" alt="Python 请求方式"></p><h3 id="命名请求"><a href="#命名请求" class="headerlink" title="命名请求"></a>命名请求</h3><p>之前我们发送的所有请求都是匿名请求，匿名请求和命名请求的区别就是在一个 http 文件内，可以引用命名请求的请求信息和响应信息，在请求之间有依赖关系时这个功能非常有用，例如每次登录成功后其他请求都需要更新登录返回的 token，命名请求可以用过 JSONPath 或者 XPath 获取响应数据</p><p><img src="https://www.jifu.io/images/2/2266769285-5c551c5cddf2d_articlex.png" alt="命名请求"></p><p>在响应中也会显示使用到当前命名请求的变量值的更新</p><p><img src="https://www.jifu.io/images/2/3979257242-5c551c5cb7dbe_articlex.png" alt="请求响应"></p><h4 id="一些有用的设置"><a href="#一些有用的设置" class="headerlink" title="一些有用的设置"></a>一些有用的设置</h4><h5 id="设置响应显示内容"><a href="#设置响应显示内容" class="headerlink" title="设置响应显示内容"></a>设置响应显示内容</h5><p>在 REST Client 设置中的 “Preview Option” 可以设置请求响应显示什么内容，总共有四种，<code>full</code>，<code>body</code>，<code>header</code>，<code>exchang</code></p><p><img src="https://www.jifu.io/images/2/2090009302-5c551c5c75020_articlex.png" alt="设置选项"></p><p>我们分别来看下四种结果显示什么内容</p><ul><li>full：Header + Body</li></ul><p><img src="https://www.jifu.io/images/2/3434190680-5c551c5c4cd6f_articlex.png" alt="full"></p><ul><li>body：只显示 Body</li></ul><p><img src="https://www.jifu.io/images/2/3645244011-5c551c5c70909_articlex.png" alt="body"></p><ul><li>header：只显示 Header</li></ul><p><img src="https://www.jifu.io/images/2/4284328095-5c551c5c79fb5_articlex.png" alt="header"></p><ul><li>exchange：显示请求 + Header + Body</li></ul><p><img src="https://www.jifu.io/images/2/36316858-5c551c5c4ec18_articlex.png" alt="exchange"></p><h4 id="其他常用的设置选项"><a href="#其他常用的设置选项" class="headerlink" title="其他常用的设置选项"></a>其他常用的设置选项</h4><ul><li><code>rest-client.timeoutinmilliseconds</code>: 设置请求超时，单位毫秒</li><li><code>rest-client.showResponseInDifferentTab</code>: 每个响应请求创建一个新的 tab，为 false 时，每次请求会覆盖上一次的请求结果，设置为 true 时每次请求都会打开一个新的 tab，方便对比多次请求结果</li><li><code>rest-client.previewColumn</code>: 请求结果显示，<code>current</code> 表示显示在当前的编辑器分组 <code>beside</code> 表示显示在侧面编辑器分组（这个侧面根据编辑器的 <code>workbench.editor.openSideBySideDirection</code> 选项会显示在右面或是下面</li><li>代理：使用<code>http.proxy</code> 和 <code>http.proxyStrictSSL</code></li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>其实 Postman 和 Paw 都提供更为强力的辅助工具，这里使用 REST Client 单纯觉得 Postman 和 Paw 大部分功能我其实都用不到，因为仅仅验证接口是否正常，业务是否能跑通，所以一直在寻找一个简单的工具，REST Client 刚好满足了我所有的需求</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;今天给大家介绍一个后端开发辅助的好工具 —— REST Client，插件如其名这就是一个 REST 的客户端插件，把我们的 VSCode 转化为一个 REST 接口测试的利器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.jifu.io/images/2/rest-client-1024x357.png&quot; alt=&quot;REST Client&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们一般都会用 PostMan 来完成接口测试的工作，因为用起来十分简单快捷，但是一直以来我也在寻找更好的方案，一个不用切换窗口多开一个 app 的方案 —— 终于在使用 VSCode 一段时版本间，我找到了 REST Client 插件，初看 REST Client 插件的时候，会觉得他十分的简陋，但是在使用一段时间后会发现在 REST Client 插件中已经有完成接口测试所需的所有东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 HTTP 语言，HTTP 语言是一门非常简单的语言，使用 HTTP 语言可以轻松的描述请求&lt;/li&gt;
&lt;li&gt;纯文本记录，不同于 PostMan 保存在云端，或是 Paw 那样保存二进制文件，并且纯文本可以使用 git 追踪内容的变化&lt;/li&gt;
&lt;li&gt;无需切换窗口，测试，调试，代码编辑都在一个 VSCode 中完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;劣势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作和使用不像 PostMan 之类的图形化工具那么直观&lt;/li&gt;
&lt;li&gt;不支持请求前后对数据进行操作的脚本，不过这个已经在作者的开发计划中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多时候我们只是需要写完代码后手边有一个小工具可以轻松愉快的看一眼接口是否正常，那么 REST Client 就是我们的首选了&lt;/p&gt;
    
    </summary>
    
      <category term="OPS" scheme="http://www.jifu.io/categories/OPS/"/>
    
      <category term="Editor" scheme="http://www.jifu.io/categories/OPS/Editor/"/>
    
    
      <category term="vscode" scheme="http://www.jifu.io/tags/vscode/"/>
    
      <category term="restful" scheme="http://www.jifu.io/tags/restful/"/>
    
      <category term="REST Client" scheme="http://www.jifu.io/tags/REST-Client/"/>
    
      <category term="Plugin" scheme="http://www.jifu.io/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>Homebrew：让你从 Mac 切换到 Linux 更轻松</title>
    <link href="http://www.jifu.io/posts/581320548/"/>
    <id>http://www.jifu.io/posts/581320548/</id>
    <published>2020-09-25T12:03:23.000Z</published>
    <updated>2020-09-26T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>不管你是想要更舒服地从 Mac 搬到 Linux，还是不满意常规的 Linux 包管理器，都可以试试 Homebrew。</p></blockquote><p><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 项目最初是为了给 Mac 用户提供一个非官方的 Linux 式的包管理器。用户很快就爱上了它友好的界面以及帮助性的提示，而且，它已经被移植到 Linux 系统 —— 这看起来像是一个奇怪的命运转折。</p><p>一开始，有两个分开的项目分别针对 macOS 和 Linux （Homebrew 与 Linuxbrew），但是现在是由 Homebrew 核心管理着这两个操作系统。由于我正 <a href="https://opensource.com/article/19/10/why-switch-mac-linux" target="_blank" rel="noopener">从 Mac 切换到 Linux</a>，所以一直在研究我在 macOS 最常用的开源软件在 Linux 表现如何，最终，我很高兴地发现 Homebrew 对 Linux 的支持太赞了！</p><p><img src="https://www.jifu.io/images/2/homebrew-social-card.png" alt=""></p><a id="more"></a><h1 id="为什么要在-Linux-使用-Homebrew-呢"><a href="#为什么要在-Linux-使用-Homebrew-呢" class="headerlink" title="为什么要在 Linux 使用 Homebrew 呢?"></a>为什么要在 Linux 使用 Homebrew 呢?</h1><p>长期使用 Linux 的用户对 Homebrew 的第一反应是：“为什么不直接使用……呢”，省略号代表他们喜欢的某个 Linux 包管理器。基于 Debian 的系统早就有了 <code>apt</code>，基于 Fedora 的系统则有 <code>dnf</code> 和 <code>yum</code>，并且像 Flatpak 跟 AppImage 这样的项目，在两种系统上都能流畅运行。我花了不少时间尝试这些技术，不得不说，它们都有其强大之处。</p><p>那我为什么还要 <a href="https://opensource.com/article/20/6/homebrew-mac" target="_blank" rel="noopener">坚持使用 Homebrew</a> 呢？首先，我对它非常熟悉。在为我过去使用的专有软件寻找开源替代品的过程中，我已经学会了许多使用方法，而保持一些熟悉的东西，比如 Homebrew，可以让我专注于一次学习一件事情，而不是被不同系统间的差异搞垮。</p><p>此外，我没有看到哪一个包管理器像 Homebrew 一样，对用户如此友好。正如默认的帮助命令一样，命令井然有序：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ brew -h<span class="token variable">`</span></span>2.  <span class="token variable"><span class="token variable">`</span>Example usage:<span class="token variable">`</span></span>3.   <span class="token variable"><span class="token variable">`</span>brew search <span class="token punctuation">[</span>TEXT<span class="token operator">|</span>/REGEX/<span class="token punctuation">]</span><span class="token variable">`</span></span>4.   <span class="token variable"><span class="token variable">`</span>brew info <span class="token punctuation">[</span>FORMULA<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token variable">`</span></span>5.   <span class="token variable"><span class="token variable">`</span>brew <span class="token function">install</span> FORMULA<span class="token punctuation">..</span>.<span class="token variable">`</span></span>6.   <span class="token variable"><span class="token variable">`</span>brew update<span class="token variable">`</span></span>7.   <span class="token variable"><span class="token variable">`</span>brew upgrade <span class="token punctuation">[</span>FORMULA<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token variable">`</span></span>8.   <span class="token variable"><span class="token variable">`</span>brew uninstall FORMULA<span class="token punctuation">..</span>.<span class="token variable">`</span></span>9.   <span class="token variable"><span class="token variable">`</span>brew list <span class="token punctuation">[</span>FORMULA<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token variable">`</span></span>11.  <span class="token variable"><span class="token variable">`</span>Troubleshooting:<span class="token variable">`</span></span>12.   <span class="token variable"><span class="token variable">`</span>brew config<span class="token variable">`</span></span>13.   <span class="token variable"><span class="token variable">`</span>brew doctor<span class="token variable">`</span></span>14.   <span class="token variable"><span class="token variable">`</span>brew <span class="token function">install</span> --verbose --debug FORMULA<span class="token variable">`</span></span>16.  <span class="token variable"><span class="token variable">`</span>Contributing:<span class="token variable">`</span></span>17.   <span class="token variable"><span class="token variable">`</span>brew create <span class="token punctuation">[</span>URL <span class="token punctuation">[</span>--no-fetch<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token variable">`</span></span>18.   <span class="token variable"><span class="token variable">`</span>brew edit <span class="token punctuation">[</span>FORMULA<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token variable">`</span></span>20.  <span class="token variable"><span class="token variable">`</span>Further help:<span class="token variable">`</span></span>21.   <span class="token variable"><span class="token variable">`</span>brew commands<span class="token variable">`</span></span>22.   <span class="token variable"><span class="token variable">`</span>brew <span class="token function">help</span> <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span><span class="token variable">`</span></span>23.   <span class="token variable"><span class="token variable">`</span><span class="token function">man</span> brew<span class="token variable">`</span></span>24.   <span class="token variable"><span class="token variable">`</span><span class="token operator">&lt;</span>https://docs.brew.sh<span class="token operator">></span><span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>过于简短的输出可能会被误解为它功能局限，但是你简单看看每一个子命令，都有很丰富的功能。虽然上面的列表只有短短 23 行，但对高级用户来说，光是子命令 <code>install</code> 就包含整整 79 行的帮助信息：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ brew --help <span class="token operator">|</span> <span class="token function">wc</span> -l<span class="token variable">`</span></span>2.  <span class="token variable"><span class="token variable">`</span>23<span class="token variable">`</span></span>3.  <span class="token variable"><span class="token variable">`</span>$ brew <span class="token function">install</span> --help <span class="token operator">|</span> <span class="token function">wc</span> -l<span class="token variable">`</span></span>4.  <span class="token variable"><span class="token variable">`</span>79<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它可以选择忽略或者安装依赖关系，也可以选择用源代码编译以及用什么编译器来编译某个确切的上游 Git 提交，或者选择应用的官方 “灌装” 版。总而言之，Homebrew 即适合新手，也同样能满足老鸟。</p><h1 id="开始在-Linux-使用-Homebrew"><a href="#开始在-Linux-使用-Homebrew" class="headerlink" title="开始在 Linux 使用 Homebrew"></a>开始在 Linux 使用 Homebrew</h1><p>如果你想要试着使用 Homebrew，可以用这个单行脚本在 Mac 或者 Linux 上进行安装：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  `$ /bin/bash -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh<span class="token variable">)</span></span>"</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令会立即开始安装 Homebrew。如果你比较谨慎，可以使用 <code>curl</code> 将该文件下载到本地，检查完毕之后再运行。</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh --output homebrew_installer.sh<span class="token variable">`</span></span>2.  `$ <span class="token function">more</span> homebrew_installer.sh <span class="token comment" spellcheck="true"># 审核该脚本，直到你觉得没问题了`</span>3.  <span class="token variable"><span class="token variable">`</span>$ <span class="token function">bash</span> homebrew_installer.sh<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对 Linux 的安装步骤还包括如何配置点文件，对于 Debian 系统来说是 <code>~/.profile</code>，对于 Fedora 系统是 <code>~/.bash_profile</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ <span class="token function">test</span> -d /home/linuxbrew/.linuxbrew <span class="token operator">&amp;&amp;</span> <span class="token function">eval</span> <span class="token punctuation">$(</span>/home/linuxbrew/.linuxbrew/bin/brew shellenv<span class="token punctuation">)</span><span class="token variable">`</span></span>2.  `$ <span class="token function">test</span> -r ~/.bash_profile <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"eval \<span class="token variable"><span class="token variable">$(</span><span class="token variable">$(</span>brew --prefix<span class="token variable">)</span></span>/bin/brew shellenv)"</span> <span class="token operator">>></span>~/.bash_profile<span class="token variable"><span class="token variable">`</span>3.  <span class="token variable">`</span></span>$ <span class="token keyword">echo</span> <span class="token string">"eval \<span class="token variable"><span class="token variable">$(</span><span class="token variable">$(</span>brew --prefix<span class="token variable">)</span></span>/bin/brew shellenv)"</span> <span class="token operator">>></span>~/.profile`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为了确认已经安装好，Homebrew 团队提供一个空的 <code>hello</code> “秘方” 供测试：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ brew <span class="token function">install</span> hello<span class="token variable">`</span></span>2.  <span class="token variable"><span class="token variable">`</span><span class="token operator">==</span><span class="token operator">></span> Downloading https://linuxbrew.bintray.com/bottles/hello-2.10.x86_64_linux.bottle.tar.gz<span class="token variable">`</span></span>3.  `<span class="token comment" spellcheck="true">######################################################################## 100.0%`</span>4.  <span class="token variable"><span class="token variable">`</span><span class="token operator">==</span><span class="token operator">></span> Pouring hello-2.10.x86_64_linux.bottle.tar.gz<span class="token variable">`</span></span>5.  <span class="token variable"><span class="token variable">`</span>🍺  /home/linuxbrew/.linuxbrew/Cellar/hello/2.10: 52 files, 595.6KB<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来安装毫无问题，让我来试试更多操作。</p><h1 id="命令行工具-Brew"><a href="#命令行工具-Brew" class="headerlink" title="命令行工具 Brew"></a>命令行工具 Brew</h1><p>Homebrew 宣称自己是一款默认只 “安装你需要而 [Linux] 没有的东西”的应用程序。</p><p>你可以用 <code>brew</code> 命令安装任何打包在 Homebrew 中的命令行软件。这些包的定义文件叫做 “秘方formula”，而且它们通过“瓶子bottle”来编译并分享。在 Homebrew 的世界里，还有许多 “啤酒方面” 的术语，但这个包管理器主要目的是让软件便于使用。</p><p>都有些什么样的软件呢？对我这样的技术玩家（既然你已经在读这篇文章，估计你也是）来说最方便的东西。例如，便利的 <code>tree</code> 命令，可以展示目录结构，或者 <code>pyenv</code>，我用它来 <a href="https://opensource.com/article/20/4/pyenv" target="_blank" rel="noopener">在 Mac 管理不同版本 Python</a>。</p><p>你可以用 <code>search</code> 命令查看所有可以安装的“秘方”，在后面加上 <code>wc</code> 命令看看一共有多少：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  `<span class="token comment" spellcheck="true"># -l 选项统计行数`</span>2.  <span class="token variable"><span class="token variable">`</span>$ brew search <span class="token operator">|</span> <span class="token function">wc</span> -l<span class="token variable">`</span></span>3.   <span class="token variable"><span class="token variable">`</span>5087<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>迄今为止，一共有 5000 多个 “秘方”，这囊括了很多软件。需要注意的是：并非所有 “秘方” 都能在 Linux 运行。在 <code>brew search --help</code> 输出中有一节提到可以按软件运行的操作系统来筛选软件。它会在浏览器打开用于每个操作系统的软件仓库。我运行的是 Fedora，所以我会用它来试一试：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ brew search --fedora tree<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览器打开了网址 <code>https://apps.fedoraproject.org/packages/s/tree</code>，向我展示了所有 Fedora 的可用选项。你也可以通过其它方法进行浏览。“秘方” 被集中整理到由操作系统划分的核心仓库当中（Mac 在 <a href="https://github.com/Homebrew/homebrew-core" target="_blank" rel="noopener">Homebrew Core</a>，Linux 在 <a href="https://github.com/Homebrew/linuxbrew-core" target="_blank" rel="noopener">Linux Core</a>）。同样也可以通过 Homebrew API <a href="https://formulae.brew.sh/formula/" target="_blank" rel="noopener">在网页显示</a>。</p><p>即使有这些选择，我还是通过其它用户的推荐找到很多新工具。我列出一些我最喜欢的工具，你可以在里面找点灵感：</p><ul><li><code>pyenv</code>、<code>rbenv</code> 和 <code>nodenv</code> 用来管理（相应的） Python、Ruby 和 Node.js 版本</li><li><code>imagemagick</code> 用于脚本化编辑图片</li><li><code>pandoc</code> 用于脚本化转换文档格式（我通常将 .docx 文件转成 .md 或者 .html）</li><li><code>hub</code> 为 GitHub 用户提供 <a href="https://opensource.com/article/20/3/github-hub" target="_blank" rel="noopener">更好的 Git 体验</a></li><li><code>tldr</code> 展示了命令工具的使用范例</li></ul><p>想要深入了解 Homebrew，可以去 <a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">trldr 页面</a> 看看，比起应用的 man 页面，它要友好得多。使用 <code>search</code> 命令确认你可以安装：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ brew search tldr<span class="token variable">`</span></span>2.  <span class="token variable"><span class="token variable">`</span><span class="token operator">==</span><span class="token operator">></span> Formulae<span class="token variable">`</span></span>3.  <span class="token variable"><span class="token variable">`</span>tldr ✔<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>太好了！对勾说明你可以安装。那么继续吧：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ brew <span class="token function">install</span> tldr<span class="token variable">`</span></span>2.  <span class="token variable"><span class="token variable">`</span><span class="token operator">==</span><span class="token operator">></span> Downloading https://linuxbrew.bintray.com/bottles/tldr-1.3.0_2.x86_64_linux.bottle.1.tar.gz<span class="token variable">`</span></span>3.  `<span class="token comment" spellcheck="true">######################################################################## 100.0%`</span>4.  <span class="token variable"><span class="token variable">`</span><span class="token operator">==</span><span class="token operator">></span> Pouring tldr-1.3.0_2.x86_64_linux.bottle.1.tar.gz<span class="token variable">`</span></span>5.  <span class="token variable"><span class="token variable">`</span>🍺  /home/linuxbrew/.linuxbrew/Cellar/tldr/1.3.0_2: 6 files, 63.2KB<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Homebrew 提供了编译好的二进制文件，所以你不必在本地机器上从源码编译。这能节省很多时间，也不用听 CPU 风扇的噪声。我很欣赏 Homebrew 的另外一点是，你不完全理解每一个选项的含义也不会影响正常使用。若你想自己编译，可以在 <code>brew install</code> 命令后面加上 <code>-s</code> 或者 <code>--build-from-source</code> 标识，这样就能从源码编译 “秘方”（即便已经有一个 “瓶子” 存在）。</p><p>同样，软件底层的复杂性也很有意思。使用 <code>info</code> 可以查看 <code>tldr</code> 软件的依赖管理，“秘方” 的源代码存放在磁盘上的何处，甚至还能查看公开分析。</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ brew info tldr<span class="token variable">`</span></span>2.  <span class="token variable"><span class="token variable">`</span>tldr: stable 1.3.0 <span class="token punctuation">(</span>bottled<span class="token punctuation">)</span>, HEAD<span class="token variable">`</span></span>3.  <span class="token variable"><span class="token variable">`</span>Simplified and community-driven <span class="token function">man</span> pages<span class="token variable">`</span></span>4.  <span class="token variable"><span class="token variable">`</span>https://tldr.sh/<span class="token variable">`</span></span>5.  <span class="token variable"><span class="token variable">`</span>Conflicts with:<span class="token variable">`</span></span>6.   `<span class="token variable"><span class="token variable">`</span>tealdeer <span class="token punctuation">(</span>because both <span class="token function">install</span> <span class="token variable">`</span></span>tldr<span class="token variable"><span class="token variable">`</span> binaries<span class="token punctuation">)</span><span class="token variable">`</span></span><span class="token variable"><span class="token variable">`</span>7.  <span class="token variable">`</span></span>/home/linuxbrew/.linuxbrew/Cellar/tldr/1.3.0_2 <span class="token punctuation">(</span>6 files, 63.2KB<span class="token punctuation">)</span> *<span class="token variable"><span class="token variable">`</span>8.   <span class="token variable">`</span></span>Poured from bottle on 2020-06-08 at 15:56:15<span class="token variable"><span class="token variable">`</span>9.  <span class="token variable">`</span></span>From: https://github.com/Homebrew/linuxbrew-core/blob/master/Formula/tldr.rb<span class="token variable"><span class="token variable">`</span>10.  <span class="token variable">`</span></span><span class="token operator">==</span><span class="token operator">></span> Dependencies<span class="token variable"><span class="token variable">`</span>11.  <span class="token variable">`</span></span>Build: pkg-config ✔<span class="token variable"><span class="token variable">`</span>12.  <span class="token variable">`</span></span>Required: libzip ✔, curl ✔<span class="token variable"><span class="token variable">`</span>13.  <span class="token variable">`</span></span><span class="token operator">==</span><span class="token operator">></span> Options<span class="token variable"><span class="token variable">`</span>14.  <span class="token variable">`</span></span>--HEAD<span class="token variable"><span class="token variable">`</span>15.   <span class="token variable">`</span></span>Install HEAD version<span class="token variable"><span class="token variable">`</span>16.  <span class="token variable">`</span></span><span class="token operator">==</span><span class="token operator">></span> Analytics<span class="token variable"><span class="token variable">`</span>17.  <span class="token variable">`</span></span>install: 197 <span class="token punctuation">(</span>30 days<span class="token punctuation">)</span>, 647 <span class="token punctuation">(</span>90 days<span class="token punctuation">)</span>, 1,546 <span class="token punctuation">(</span>365 days<span class="token punctuation">)</span><span class="token variable"><span class="token variable">`</span>18.  <span class="token variable">`</span></span>install-on-request: 197 <span class="token punctuation">(</span>30 days<span class="token punctuation">)</span>, 646 <span class="token punctuation">(</span>90 days<span class="token punctuation">)</span>, 1,546 <span class="token punctuation">(</span>365 days<span class="token punctuation">)</span><span class="token variable"><span class="token variable">`</span>19.  <span class="token variable">`</span></span>build-error: 0 <span class="token punctuation">(</span>30 days<span class="token punctuation">)</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="从-Mac-到-Linux-的一点不足"><a href="#从-Mac-到-Linux-的一点不足" class="headerlink" title="从 Mac 到 Linux 的一点不足"></a>从 Mac 到 Linux 的一点不足</h1><p>在 macOS，Homebrew 的 <code>cask</code>（“酒桶”）子命令可以让用户使用命令行安装、管理整个应用软件。不幸的是，<code>cask</code>还不能在任何 Linux 发行版上使用。我在安装一个开源工具时发现了这点：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ brew cask <span class="token function">install</span> tusk<span class="token variable">`</span></span>2.  <span class="token variable"><span class="token variable">`</span>Error: Installing casks is supported only on macOS<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我在 <a href="https://discourse.brew.sh/t/add-linux-support-to-existing-cask/5766" target="_blank" rel="noopener">论坛上</a> 问了一下，很快得到其他用户的反馈。总结一下，方案如下：</p><ul><li>复刻 Homebrew 项目，构建这个特性，然后像别人展示其价值</li><li>给该软件写一个 “秘方”，然后从源代码编译</li><li>为该软件创建一个第三方仓库</li></ul><p>最后一个是我最感兴趣的。Homebrew 通过 <a href="https://docs.brew.sh/How-to-Create-and-Maintain-a-Tap" target="_blank" rel="noopener">创建并维护 “水龙头tap”</a> （另一个受啤酒影响的术语）管理第三方仓库。随着你对系统越来越熟悉，并想加入生态系统， “水龙头” 是值得研究的。</p><h1 id="备份-Homebrew-的安装记录"><a href="#备份-Homebrew-的安装记录" class="headerlink" title="备份 Homebrew 的安装记录"></a>备份 Homebrew 的安装记录</h1><p>我最中意的 Homebrew 特性之一就是你可以像其它任何 <a href="https://opensource.com/article/19/3/move-your-dotfiles-version-control" target="_blank" rel="noopener">用版本控制工具来备份点文件</a> 一样备份你的安装记录。为了实现这个目的，Homebrew 提供 <code>bundle</code>（“捆扎”）子命令，它可以控制一个叫 <code>dump</code>（“倾倒”）的子命令生成一个 <code>Brewfile</code>。这个文件包含你目前所有安装的工具列表，可以重复使用。进入你想使用的目录然后运行命令，它会根据你所安装的软件生成 <code>Brewfile</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  `$ <span class="token function">cd</span> ~/Development/dotfiles <span class="token comment" spellcheck="true"># This is my dotfile folder`</span>2.  <span class="token variable"><span class="token variable">`</span>$ brew bundle dump<span class="token variable">`</span></span>3.  <span class="token variable"><span class="token variable">`</span>$ <span class="token function">ls</span> Brewfile<span class="token variable">`</span></span>4.  <span class="token variable"><span class="token variable">`</span>Brewfile<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当我换了一台机器，想要安装一样的软件时，进入含有 <code>Brewfile</code> 的文件夹，然后重新安装：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ <span class="token function">ls</span> Brewfile<span class="token variable">`</span></span>2.  <span class="token variable"><span class="token variable">`</span>Brewfile<span class="token variable">`</span></span>3.  <span class="token variable"><span class="token variable">`</span>$ brew bundle<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它会在我的新机器上安装所有列出的 “秘方”。</p><h2 id="在-Mac-和-Linux-同时管理-Brewfile"><a href="#在-Mac-和-Linux-同时管理-Brewfile" class="headerlink" title="在 Mac 和 Linux 同时管理 Brewfile"></a>在 Mac 和 Linux 同时管理 Brewfile</h2><p><code>Brewfile</code> 非常适合备份你目前的安装记录，但是如果某些在 Mac 上运行的软件无法运行在 Linux 呢？或者刚好相反？我发现不管是 Mac 还是 Linux，如果软件无法在当前操作系统运行，Homebrew 会优雅地忽略那一行。如果它遇到不兼容的请求（比如使用 <code>brew</code> 在 Linux 安装 “酒桶cask” 时），它会选择跳过，继续安装过程：</p><pre class="line-numbers language-bash"><code class="language-bash">1.  <span class="token variable"><span class="token variable">`</span>$ brew bundle --file<span class="token operator">=</span>Brewfile.example<span class="token variable">`</span></span>3.  <span class="token variable"><span class="token variable">`</span>Skipping cask licecap <span class="token punctuation">(</span>on Linux<span class="token punctuation">)</span><span class="token variable">`</span></span>4.  <span class="token variable"><span class="token variable">`</span>Skipping cask macdown <span class="token punctuation">(</span>on Linux<span class="token punctuation">)</span><span class="token variable">`</span></span>5.  <span class="token variable"><span class="token variable">`</span>Installing fish<span class="token variable">`</span></span>6.  <span class="token variable"><span class="token variable">`</span>Homebrew Bundle complete<span class="token operator">!</span> 1 Brewfile dependency now installed.<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了保持配置文件的简洁，我在两个操作系统上使用同一份 <code>Brewfile</code>，因为它只安装与操作系统相关的版本，所以我一直没有遇到任何问题。</p><h1 id="使用-Homebrew-管理软件包"><a href="#使用-Homebrew-管理软件包" class="headerlink" title="使用 Homebrew 管理软件包"></a>使用 Homebrew 管理软件包</h1><p>Homebrew 已经成了我必备的命令行工具，由于我很熟悉它，所以在 Linux 上的体验也充满乐趣。Homebrew 让我的工具井然有序，并且时刻保持更新，我愈发欣赏它在实用性与功能上找到的平衡点。我更喜欢将软件包管理的细节保持在用户需要了解的最小程度，大多数人都会从中受益。如果你已经很熟悉 Linux 包管理器了，Homebrew 可能会让你觉得很基础，但稍微深入一点看，就会发现它的高级选项远远超过本文的内容。</p><p>对 Linux 用户来说，他们有很多包管理器可以选择。如果你来自 MacOS，Homebrew 会让你宾至如归。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;不管你是想要更舒服地从 Mac 搬到 Linux，还是不满意常规的 Linux 包管理器，都可以试试 Homebrew。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://brew.sh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Homebrew&lt;/a&gt; 项目最初是为了给 Mac 用户提供一个非官方的 Linux 式的包管理器。用户很快就爱上了它友好的界面以及帮助性的提示，而且，它已经被移植到 Linux 系统 —— 这看起来像是一个奇怪的命运转折。&lt;/p&gt;
&lt;p&gt;一开始，有两个分开的项目分别针对 macOS 和 Linux （Homebrew 与 Linuxbrew），但是现在是由 Homebrew 核心管理着这两个操作系统。由于我正 &lt;a href=&quot;https://opensource.com/article/19/10/why-switch-mac-linux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从 Mac 切换到 Linux&lt;/a&gt;，所以一直在研究我在 macOS 最常用的开源软件在 Linux 表现如何，最终，我很高兴地发现 Homebrew 对 Linux 的支持太赞了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.jifu.io/images/2/homebrew-social-card.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OPS" scheme="http://www.jifu.io/categories/OPS/"/>
    
      <category term="MacOS" scheme="http://www.jifu.io/categories/OPS/MacOS/"/>
    
    
      <category term="MacOS" scheme="http://www.jifu.io/tags/MacOS/"/>
    
      <category term="Homebrew" scheme="http://www.jifu.io/tags/Homebrew/"/>
    
      <category term="command" scheme="http://www.jifu.io/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>命令行信息截图工具 - ScreenFetch</title>
    <link href="http://www.jifu.io/posts/3895039994/"/>
    <id>http://www.jifu.io/posts/3895039994/</id>
    <published>2020-08-11T05:17:21.000Z</published>
    <updated>2020-08-11T05:17:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.jifu.io/images/2/20190427135657.jpg" alt=""></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>screenFetch 是一个“命令行信息截图工具”。它可以在终端上显示系统信息，并进行桌面截图。它能生成漂亮的文本的系统信息和ASCII艺术的发行版LOGO，然后显示在截屏图片中。</p><p>它会自动检测你的发行版并显示其ASCII版本的LOGO，在其右侧显示系统信息。可以通过选项来指定是否显示LOGO、指定颜色，进行截图，甚至可以自定义截图的命令。screenFectch非常容易添加和扩展。</p><h1 id="screenFetch将显示以下系统信息"><a href="#screenFetch将显示以下系统信息" class="headerlink" title="screenFetch将显示以下系统信息"></a>screenFetch将显示以下系统信息</h1><ul><li>当前登录用户</li><li>操作系统版本</li><li>内核版本</li><li>总计运行时间</li><li>已安装包数量</li><li>当前shell详情</li><li>当前屏幕分辨率</li><li>当前桌面环境</li><li>当前窗口管理器（文件管理器）</li><li>总计及空闲磁盘使用百分比</li><li>CPU详情，如处理器速度、类型</li><li>总计及当前内存使用量</li></ul><h1 id="在Linux上安装screenFectch"><a href="#在Linux上安装screenFectch" class="headerlink" title="在Linux上安装screenFectch"></a>在Linux上安装screenFectch</h1><p>您可以通过直接从项目页下载源码包的方式安装，或者从<code>screenFetch git</code>库克隆。</p><a id="more"></a><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><p>下载 最新版. 我下载并安装在<code>/home/sk/Downloads</code>目录.</p><p>用命令解压：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable">$unzip</span> Downloads/screenfetch-3.1.0.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入screenFectch目录，并设置执行权限.</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable">$cd</span> screenfetch-3.1.0/<span class="token variable">$chmod</span> +x screenfetch-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在命令行运行：</p><pre class="line-numbers language-bash"><code class="language-bash">$./screenfetch-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出示例：</p><p><img src="https://www.jifu.io/images/2/20190427135043.png" alt=""></p><h2 id="通过git库安装"><a href="#通过git库安装" class="headerlink" title="通过git库安装"></a>通过git库安装</h2><p>首先确认你是否安装了git.</p><p>如果没有安装，基于RHEL系统的用户用以下命令安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># yum install git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基于Debian系统的用户用以下命令安装:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># apt-get install git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用命令克隆screenFectch库:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># git clone git://github.com/KittyKatt/screenFetch.git screenfetch</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制文件到/usr/bin/目录，并设置执行权限:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cp screenfetch/screenfetch-dev /usr/bin/screenfetch</span><span class="token comment" spellcheck="true"># chmod +x /usr/bin/screenfetch</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行screenFectch:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># screenfetch</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您将会看到如上面截图所示的结果.</p><p><img src="https://www.jifu.io/images/2/20190427135043.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.jifu.io/images/2/20190427135657.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;screenFetch 是一个“命令行信息截图工具”。它可以在终端上显示系统信息，并进行桌面截图。它能生成漂亮的文本的系统信息和ASCII艺术的发行版LOGO，然后显示在截屏图片中。&lt;/p&gt;
&lt;p&gt;它会自动检测你的发行版并显示其ASCII版本的LOGO，在其右侧显示系统信息。可以通过选项来指定是否显示LOGO、指定颜色，进行截图，甚至可以自定义截图的命令。screenFectch非常容易添加和扩展。&lt;/p&gt;
&lt;h1 id=&quot;screenFetch将显示以下系统信息&quot;&gt;&lt;a href=&quot;#screenFetch将显示以下系统信息&quot; class=&quot;headerlink&quot; title=&quot;screenFetch将显示以下系统信息&quot;&gt;&lt;/a&gt;screenFetch将显示以下系统信息&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;当前登录用户&lt;/li&gt;
&lt;li&gt;操作系统版本&lt;/li&gt;
&lt;li&gt;内核版本&lt;/li&gt;
&lt;li&gt;总计运行时间&lt;/li&gt;
&lt;li&gt;已安装包数量&lt;/li&gt;
&lt;li&gt;当前shell详情&lt;/li&gt;
&lt;li&gt;当前屏幕分辨率&lt;/li&gt;
&lt;li&gt;当前桌面环境&lt;/li&gt;
&lt;li&gt;当前窗口管理器（文件管理器）&lt;/li&gt;
&lt;li&gt;总计及空闲磁盘使用百分比&lt;/li&gt;
&lt;li&gt;CPU详情，如处理器速度、类型&lt;/li&gt;
&lt;li&gt;总计及当前内存使用量&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;在Linux上安装screenFectch&quot;&gt;&lt;a href=&quot;#在Linux上安装screenFectch&quot; class=&quot;headerlink&quot; title=&quot;在Linux上安装screenFectch&quot;&gt;&lt;/a&gt;在Linux上安装screenFectch&lt;/h1&gt;&lt;p&gt;您可以通过直接从项目页下载源码包的方式安装，或者从&lt;code&gt;screenFetch git&lt;/code&gt;库克隆。&lt;/p&gt;
    
    </summary>
    
      <category term="OPS" scheme="http://www.jifu.io/categories/OPS/"/>
    
      <category term="Others" scheme="http://www.jifu.io/categories/OPS/Others/"/>
    
    
      <category term="command" scheme="http://www.jifu.io/tags/command/"/>
    
      <category term="screenfetch" scheme="http://www.jifu.io/tags/screenfetch/"/>
    
      <category term="系统信息" scheme="http://www.jifu.io/tags/%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>用好这些隐藏「小开关」，让 Chrome 浏览器更好用</title>
    <link href="http://www.jifu.io/posts/1413974522/"/>
    <id>http://www.jifu.io/posts/1413974522/</id>
    <published>2019-12-17T13:14:30.000Z</published>
    <updated>2020-08-11T05:17:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.jifu.io/images/posts/1413974522/223592376156316015.jpg" alt=""></p><p>相比移动端的 Chrome 浏览器，功能性能更强更全面的桌面端 Chrome 可能是你我每天使用频次最多的桌面软件。多端数据同步、实用的扩展插件都让其成为电脑上的「超级应用」。近乎无限制的桌面平台也让其可以在第一时间运用起新的功能和技术，这也是限制重重的移动端 Chrome 所无法比拟的。</p><p>当然因为桌面端 Chrome 的广泛使用性，新功能的推出和运用反而会更为谨慎。如果想要尝鲜新功能一样是通过 Feature flags —— 当然比起移动端，桌面端的新功能主要针对的键鼠操作，和移动端有相当大的区别。</p><h1 id="尝鲜新功能，善用-Chrome-flags"><a href="#尝鲜新功能，善用-Chrome-flags" class="headerlink" title="尝鲜新功能，善用 Chrome flags"></a>尝鲜新功能，善用 Chrome flags</h1><p>Chrome 之所以被认为是「超级应用」，很大程度上在于起功能增添和更新上像极了操作系统，新功能会首先出现在 Dev 版、然后经过 Beta 测试后，最后推送到稳定通道中。而新开发的功能则被隐藏在 Chrome flags —— 作为新功能的试验田，通过开启特定的 flags 来在稳定版中尝鲜新功能，即可以尝鲜也避免了可能的不稳定风险，下面我们挑选了一些稳定性尚可且比较实用的 flags， 通过开启对应的开关来让 电脑版的 Chrome 变得更好用。</p><p><img src="https://www.jifu.io/images/posts/1413974522/62091785b5a850e5581.png" alt=""></p><blockquote><p>注：本文 Chrome 版本为稳定通道 v78，电脑系统为 Windows 10 v1909</p></blockquote><h1 id="开启并行下载功能"><a href="#开启并行下载功能" class="headerlink" title="开启并行下载功能"></a>开启并行下载功能</h1><p>移动端 Chrome 考虑到带宽和设备性能问题，只允许单进程下载其实并无不妥，而桌面端至今依旧默认单进程下载似乎就有点说不过去了，所以相比移动端，在桌面端开启并行下载功能要更为迫切一些。</p><a id="more"></a><p><img src="https://www.jifu.io/images/posts/1413974522/3fcda253bfa14e0f814b.png" alt=""></p><p>开启方法和移动端一样， 在 Chrome flags 上搜索「Parallel downloading」来开启 Chrome 的并行下载功能，你可以尝试下大个文件以及多个文件，你会发现速度会提高那么一些。当然如果有条件的话，选择第三方下载工具进行资源下载反而更为合适。</p><h2 id="开启方法"><a href="#开启方法" class="headerlink" title="开启方法"></a>开启方法</h2><p><code>chrome://flags/#enable-parallel-downloading</code></p><h1 id="给标签页进行分组"><a href="#给标签页进行分组" class="headerlink" title="给标签页进行分组"></a>给标签页进行分组</h1><p>多标签页浏览器有时也会给我们带来烦恼——我们会不自觉的打开 n 多标签页，时间一长就会忘记哪些标签页是有关联的，比如像我就经常遇到已经打开了某个标签页但最后又重复打开的，其实对标签页分组就可以妥善解决这些问题。</p><p><img src="https://www.jifu.io/images/posts/1413974522/df7342dc6a874ba63e1.png" alt=""></p><p>这个很实用的功能同样也是默认隐藏，需要在 Chrome Flags 中搜索「Tab Groups」开启，之后将开启自动分组功能。自动分组功能将根据你的打开新标签页的方式，比如从少数派中打开的新内容页面将会自动添加到一个组中，这时会在标签页前面出现一个「组标记点」。</p><p><img src="https://www.jifu.io/images/posts/1413974522/58089a109692ee602.png" alt=""></p><p>你还可以手动创建新的组或者将当前标签页加入组中，通过拖拽的标签页将起放在「组标记点」后面就可以添加到当前组，而移除则只需要将标签页从组中拖拽出即可，而为了标记的更清楚，点击组的标记点还可以更改颜色，也可以为组进行命名让其更明显。</p><h2 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h2><p><code>chrome://flags/#tab-groups</code></p><h1 id="桌面端开启阅读模式"><a href="#桌面端开启阅读模式" class="headerlink" title="桌面端开启阅读模式"></a>桌面端开启阅读模式</h1><p>无论是 Firefox 还是旧版本的 Edge 浏览器，都内置有阅读模式，这些功能并非是多此一举，而是可以极大的提高内容阅读体验，去除广告、无关的框架样式等干扰性元素，内容重新排版之后方便进一步的深入阅读，即便不使用稍后读服务也能做到类似的信息阅读体验。</p><p><img src="https://www.jifu.io/images/posts/1413974522/4f7f0969da3baf0103.png" alt=""></p><p>奇怪的是这个功能在桌面端的 Chrome 中依旧被隐藏在 flag 中，而开启方式是在 Chrome Flags 中找到「Enable Reader Mode 」来开启这个功能，打开之后重启浏览器，在地址栏的最右侧会出现一个新的图标，点击之后就会直接将当前网页转换成阅读模式，不过比起移动端功能丰富的设置项，桌面端的阅读模式要简陋很多，也无法对主题、字体和字号大小进行调整。</p><h1 id="开启方式-1"><a href="#开启方式-1" class="headerlink" title="开启方式"></a>开启方式</h1><p><code>chrome://flags/#enable-reader-mode</code></p><h1 id="让网页内容强制显示为深色主题"><a href="#让网页内容强制显示为深色主题" class="headerlink" title="让网页内容强制显示为深色主题"></a>让网页内容强制显示为深色主题</h1><p>macOS Mojave 开始支持系统深色主题的同时，Safari 也加入了一个新的 API，允许已经加入深色主题的网站跟随系统调整深色主题，只不过目前绝大多数的网站并不支持这一特性，而在 Chrome 中其实也支持类似功能，只不过该选项并非是默认开启同样需要通过在 Chrome flags 中手动开启。</p><p><img src="https://www.jifu.io/images/posts/1413974522/cc69183fe94cdbd6c66.png" alt=""></p><p>在 Chrome Flags 中搜索「Force Dark Mode」就可以看到设置选项，并且提供了相当多的显示效果选择，选择「Enable」重启后就可以看到强制开启后的基本效果，对于没有提供网页深色主题的网站，强制开启可以认为是原先网页配色在色环上对应的反色，所以看上去的展示效果比较一般，并且不同的网站的深色主题展示效果不佳，有些网站甚至完全无法用，只能用来进行一定程度的尝鲜。</p><h2 id="开启方式-2"><a href="#开启方式-2" class="headerlink" title="开启方式"></a>开启方式</h2><p><code>chrome://flags/#enable-force-dark</code></p><h1 id="开启全局媒体播放控制"><a href="#开启全局媒体播放控制" class="headerlink" title="开启全局媒体播放控制"></a>开启全局媒体播放控制</h1><p>播放在线多媒体时，如果需要暂停，快进等操作都要进入到标签页中进行调整，有时候标签页开的多，实在没法立即定位到播放页面就会很麻烦。有一个全局媒体播放控制可以简化这些步骤，这样就不用打开对应的标签页也可进行全局控制。</p><p><img src="https://www.jifu.io/images/posts/1413974522/b49f14d9852579a21a.png" alt=""></p><p>开启方法也很简单，同样是在 Chrome Flags 中搜索「 Global Media Controls 」找到之后选择「Enable」重启浏览器，这时候你打开一个视频播放页面并播放视频，同时在工具栏中就会出现一个多媒体按钮，点击就可以看到一个媒体播放选项卡，无需打开对应标签页就可以控制多媒体内容播放。</p><h2 id="开启方式-3"><a href="#开启方式-3" class="headerlink" title="开启方式"></a>开启方式</h2><p><code>chrome://flags/#global-media-controls</code></p><h1 id="鼠标悬停标签页展示网页预览图"><a href="#鼠标悬停标签页展示网页预览图" class="headerlink" title="鼠标悬停标签页展示网页预览图"></a>鼠标悬停标签页展示网页预览图</h1><p>开的标签页多了之后会逐步挤占标签页的标题文本信息，想要知道里面网页内容就只能切换到该标签页查看，那么如何不切换到当前标签页就能看到到网页里面的大致内容呢？这项早已出现在经典版 Edge 浏览器上的功能在 Chrome 竟然也是隐藏功能，开启方式当然还是在 Chrome Flag —— 搜素「Tab Hover Card Images」选择开启就可以看到效果了。</p><p><img src="https://www.jifu.io/images/posts/1413974522/6ca6786fb81aed7164.png" alt=""></p><p>开启之后当鼠标悬停在标签页时将可以看到网页内容的预览窗口了，不用切换标签页就可以看到内容可以说更为方便一些，不过这项功能对系统性能有一定的要求，如果想要更好的浏览体验可以酌情开启。</p><h2 id="开启方式-4"><a href="#开启方式-4" class="headerlink" title="开启方式"></a>开启方式</h2><p><code>chrome://flags/#tab-hover-card-images</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.jifu.io/images/posts/1413974522/223592376156316015.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;相比移动端的 Chrome 浏览器，功能性能更强更全面的桌面端 Chrome 可能是你我每天使用频次最多的桌面软件。多端数据同步、实用的扩展插件都让其成为电脑上的「超级应用」。近乎无限制的桌面平台也让其可以在第一时间运用起新的功能和技术，这也是限制重重的移动端 Chrome 所无法比拟的。&lt;/p&gt;
&lt;p&gt;当然因为桌面端 Chrome 的广泛使用性，新功能的推出和运用反而会更为谨慎。如果想要尝鲜新功能一样是通过 Feature flags —— 当然比起移动端，桌面端的新功能主要针对的键鼠操作，和移动端有相当大的区别。&lt;/p&gt;
&lt;h1 id=&quot;尝鲜新功能，善用-Chrome-flags&quot;&gt;&lt;a href=&quot;#尝鲜新功能，善用-Chrome-flags&quot; class=&quot;headerlink&quot; title=&quot;尝鲜新功能，善用 Chrome flags&quot;&gt;&lt;/a&gt;尝鲜新功能，善用 Chrome flags&lt;/h1&gt;&lt;p&gt;Chrome 之所以被认为是「超级应用」，很大程度上在于起功能增添和更新上像极了操作系统，新功能会首先出现在 Dev 版、然后经过 Beta 测试后，最后推送到稳定通道中。而新开发的功能则被隐藏在 Chrome flags —— 作为新功能的试验田，通过开启特定的 flags 来在稳定版中尝鲜新功能，即可以尝鲜也避免了可能的不稳定风险，下面我们挑选了一些稳定性尚可且比较实用的 flags， 通过开启对应的开关来让 电脑版的 Chrome 变得更好用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.jifu.io/images/posts/1413974522/62091785b5a850e5581.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：本文 Chrome 版本为稳定通道 v78，电脑系统为 Windows 10 v1909&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;开启并行下载功能&quot;&gt;&lt;a href=&quot;#开启并行下载功能&quot; class=&quot;headerlink&quot; title=&quot;开启并行下载功能&quot;&gt;&lt;/a&gt;开启并行下载功能&lt;/h1&gt;&lt;p&gt;移动端 Chrome 考虑到带宽和设备性能问题，只允许单进程下载其实并无不妥，而桌面端至今依旧默认单进程下载似乎就有点说不过去了，所以相比移动端，在桌面端开启并行下载功能要更为迫切一些。&lt;/p&gt;
    
    </summary>
    
      <category term="OPS" scheme="http://www.jifu.io/categories/OPS/"/>
    
      <category term="Others" scheme="http://www.jifu.io/categories/OPS/Others/"/>
    
    
      <category term="技巧" scheme="http://www.jifu.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Chrome" scheme="http://www.jifu.io/tags/Chrome/"/>
    
      <category term="Chrome flags" scheme="http://www.jifu.io/tags/Chrome-flags/"/>
    
  </entry>
  
  <entry>
    <title>Linux swap分区及作用详解</title>
    <link href="http://www.jifu.io/posts/4024224000/"/>
    <id>http://www.jifu.io/posts/4024224000/</id>
    <published>2019-11-16T03:44:24.000Z</published>
    <updated>2020-08-11T05:17:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.jifu.io/images/2/20191116165053.png" alt=""></p><p>我们在安装系统的时候已经建立了 swap 分区。swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。</p><p>也就是说，当内存不够用时，我们使用 swap 分区来临时顶替。这种“拆东墙，补西墙”的方式应用于几乎所有的操作系统中。</p><p>使用 swap 交换分区，显著的优点是，通过操作系统的调度，应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比 RAM 要低，因此这种方式无疑是经济实惠的。当然，频繁地读写硬盘，会显著降低操作系统的运行速率，这也是使用 swap 交换分区最大的限制。</p><blockquote><p>相比较而言，Windows 不会为 swap 单独划分一个分区，而是使用分页文件实现相同的功能，在概念上，Windows 称其为虚拟内存，从某种意义上将，这个叫法更容易理解。因此，初学者将 swap 交换分区理解为虚拟内存是没有任何问题的。</p></blockquote><p>具体使用多大的 swap 分区，取决于物理内存大小和硬盘的容量。一般来讲，swap 分区容量应大于物理内存大小，建议是内存的两倍，但不超过 2GB。但是，有时服务器的访问量确实很大，有可能出现 swap 分区不够用的情况，所以我们需要学习 swap 分区的构建方法。</p><p>建立新的 swap 分区，只需要执行以下几个步骤。</p><ol><li><p>分区：不管是 fdisk 命令还是 parted 命令，都需要先区。</p></li><li><p>格式化：格式化命令稍有不同，使用 mkswap 命令把分区格式化成 swap 分区。</p></li><li><p>使用 swap 分区。</p></li></ol><a id="more"></a><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># fdisk /dev/sdb</span><span class="token comment" spellcheck="true">#以/dev/sdb分区为例</span>WARNING: DOS-compatible mode is deprecated.It<span class="token string">'s strongly recommended to switch off the mode (command '</span>c<span class="token string">') and change display units to sectors (command '</span>u'<span class="token punctuation">)</span>.Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> help<span class="token punctuation">)</span>: n<span class="token comment" spellcheck="true">#新建</span>Command action e extended p primary partition <span class="token punctuation">(</span>1-4<span class="token punctuation">)</span>P<span class="token comment" spellcheck="true">#主分区</span>Partition number <span class="token punctuation">(</span>1-4<span class="token punctuation">)</span>: 1<span class="token comment" spellcheck="true">#分区编号</span>First cylinder <span class="token punctuation">(</span>1-2610, default 1<span class="token punctuation">)</span>:<span class="token comment" spellcheck="true">#起始柱面</span>Using default value 1Last cylinder, +cylinders or +size<span class="token punctuation">{</span>K, M, G<span class="token punctuation">}</span> <span class="token punctuation">(</span>1-2610, default 2610<span class="token punctuation">)</span>: +500M<span class="token comment" spellcheck="true">#大小</span>Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> help<span class="token punctuation">)</span>: p<span class="token comment" spellcheck="true">#查看一下</span>Disk /dev/sdb: 21.5GB, 21474836480 bytes255 heads, 63 sectors/track, 2610 cylindersUnits <span class="token operator">=</span> cylinders of 16065 *512 <span class="token operator">=</span> 8225280 bytesSector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: 512 bytes / 512 bytesI/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: 512 bytes 1512 bytesDisk identifier: OxOOOOOebdDevice Boot Start End Blocks Id System/dev/sdb1 1 65 522081 83 Linux<span class="token comment" spellcheck="true">#刚分配的分区ID是83，是Linux分区，我们在这里要分配swap分区</span>Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> help<span class="token punctuation">)</span>: t<span class="token comment" spellcheck="true">#修改分区的系统ID</span>Selected partition 1<span class="token comment" spellcheck="true">#只有一个分区，所以不用选择分区了</span>Hex code <span class="token punctuation">(</span>type L to list codes<span class="token punctuation">)</span>: 82<span class="token comment" spellcheck="true">#改为swap分区的ID</span>Changed system <span class="token function">type</span> of partition 1 to 82 <span class="token punctuation">(</span>Linux swap / Solaris<span class="token punctuation">)</span>Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> help<span class="token punctuation">)</span>: p<span class="token comment" spellcheck="true">#再查看一下</span>Disk /dev/sdb: 21.5 GB, 21474836480 bytes255 heads, 63 sectors/track, 2610 cylindersUnits <span class="token operator">=</span> cylinders of 16065 *512 <span class="token operator">=</span> 8225280 bytes Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: 512 bytes / 512 bytes I/O size <span class="token punctuation">(</span>minimum/optimal<span class="token punctuation">)</span>: 512 bytes 1512 bytes Disk identifier: OxOOOOOebdDevice Boot Start End Blocks Id System/dev/sdb1 1 65 522081 82 Linux swap / Solaris<span class="token comment" spellcheck="true">#修改过来了</span>Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> help<span class="token punctuation">)</span>: w<span class="token comment" spellcheck="true">#记得保存退出</span>The partition table has been altered<span class="token operator">!</span>Calling ioctl<span class="token punctuation">(</span><span class="token punctuation">)</span> to re-read partition table.Syncing disks.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仍以 /dev/sdb 分区作为实验对象。不过，如果分区刚刚使用 parted 命令转变为 GPT 分区表，则记得转换回 MBR 分区表，fdisk 命令才能识别，否则干脆新添加一块硬盘做实验。</p><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>因为要格式化成 swap 分区，所以格式化命令是 mkswap。命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkswap /dev/sdb1</span>Setting up swapspace version 1, size <span class="token operator">=</span> 522076 KiBno label, UUID<span class="token operator">=</span>c3351 dc3-f403-419a-9666-c24615e170fb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="使用swap分区"><a href="#使用swap分区" class="headerlink" title="使用swap分区"></a>使用swap分区</h2><p>在使用 swap 分区之前，我们先来说说 free 命令。命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#free</span>total used <span class="token function">free</span> shared buffers cachedMem: 1030796 130792 900004 0 15292 55420-/+ buffers/cache: 60080 970716Swap: 2047992 0 2047992<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>free 命令主要是用来查看内存和 swap 分区的使用情况的，其中：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>total</td><td>是指总数</td></tr><tr><td>used</td><td>是指已经使用的</td></tr><tr><td>free</td><td>是指空闲的</td></tr><tr><td>shared</td><td>是指共享的</td></tr><tr><td>buffers</td><td>是指缓冲内存数</td></tr><tr><td>cached</td><td>是指缓存内存数，单位是KB</td></tr></tbody></table><p>我们需要解释一下 buffers（缓冲）和 cached（缓存）的区别。简单来讲，cached 是给读取数据时加速的，buffers 是给写入数据加速的。cached 是指把读取出来的数据保存在内存中，当再次读取时，不用读取硬盘而直接从内存中读取，加速了数据的读取过程；buffers 是指在写入数据时，先把分散的写入操作保存到内存中，当达到一定程度后再集中写入硬盘，减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程。</p><p>我们已经看到，在加载进新的 swap 分区之前，swap 分区的大小是 2000MB，接下来只要加入 swap 分区就可以了，使用命令 swapon。命令格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># swapon 分区设备文件名</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># swapon /dev/sdb1</span>swap分区已加入，我们查看一下。<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#free</span>total used <span class="token function">free</span> shared buffers cachedMem: 1030796 131264 899532 0 15520 55500-/+ buffers/cache: 60244 970552 Swap: 2570064 0 2570064swap 分区的大小变成了 2500MB，加载成功了。如果要取消新加入的 swap 分区，则也很简单，命令如下：<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># swapoff /dev/sdb1</span>如果想让 swap 分区开机之后自动挂载，就需要修改 /etc/fstab 文件，命令如下：<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#vi /etc/fstab</span>UUID<span class="token operator">=</span>c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults 1 1UUID<span class="token operator">=</span>0b23d315-33a7-48a4-bd37-9248e5c443451 boot ext4 defaults 1 2UUID<span class="token operator">=</span>4021be19-2751-4dd2-98cc-383368c39edb swap swap defaults 0 0tmpfs /dev/shmtmpfs defaults 0 0devpts /dev/ptsdevpts gid<span class="token operator">=</span>5, mode<span class="token operator">=</span>620 0 0sysfs /syssysfs defaults 0 0proc /procproc defaults 0 0/dev/sdb1 swap swapdefaults 0 0<span class="token comment" spellcheck="true">#加入新swap分区的相关内容，这里直接使用分区的设备文件名，也可以使用UUID。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.jifu.io/images/2/20191116165053.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们在安装系统的时候已经建立了 swap 分区。swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。&lt;/p&gt;
&lt;p&gt;也就是说，当内存不够用时，我们使用 swap 分区来临时顶替。这种“拆东墙，补西墙”的方式应用于几乎所有的操作系统中。&lt;/p&gt;
&lt;p&gt;使用 swap 交换分区，显著的优点是，通过操作系统的调度，应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比 RAM 要低，因此这种方式无疑是经济实惠的。当然，频繁地读写硬盘，会显著降低操作系统的运行速率，这也是使用 swap 交换分区最大的限制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相比较而言，Windows 不会为 swap 单独划分一个分区，而是使用分页文件实现相同的功能，在概念上，Windows 称其为虚拟内存，从某种意义上将，这个叫法更容易理解。因此，初学者将 swap 交换分区理解为虚拟内存是没有任何问题的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体使用多大的 swap 分区，取决于物理内存大小和硬盘的容量。一般来讲，swap 分区容量应大于物理内存大小，建议是内存的两倍，但不超过 2GB。但是，有时服务器的访问量确实很大，有可能出现 swap 分区不够用的情况，所以我们需要学习 swap 分区的构建方法。&lt;/p&gt;
&lt;p&gt;建立新的 swap 分区，只需要执行以下几个步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;分区：不管是 fdisk 命令还是 parted 命令，都需要先区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;格式化：格式化命令稍有不同，使用 mkswap 命令把分区格式化成 swap 分区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 swap 分区。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="OPS" scheme="http://www.jifu.io/categories/OPS/"/>
    
      <category term="Linux" scheme="http://www.jifu.io/categories/OPS/Linux/"/>
    
      <category term="System Service" scheme="http://www.jifu.io/categories/OPS/Linux/System-Service/"/>
    
    
      <category term="swap" scheme="http://www.jifu.io/tags/swap/"/>
    
  </entry>
  
</feed>
